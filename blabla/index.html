<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <title>Blablas - ChiakiMayuzumi</title>
    <meta name="generator" content="Hugo 0.15" />

    
    <meta name="description" content="A material design theme for documentations.">
    
    <link rel="canonical" href="http://chiakimayuzumi.github.io/blabla/">
    
    <meta name="author" content="ChiakiMayuzumi">
    

    <meta property="og:url" content="http://chiakimayuzumi.github.io/blabla/">
    <meta property="og:title" content="ChiakiMayuzumi">
    <meta property="og:image" content="http://chiakimayuzumi.github.io/images/cm.png">
    <meta name="apple-mobile-web-app-title" content="ChiakiMayuzumi">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://chiakimayuzumi.github.io/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="http://chiakimayuzumi.github.io/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('http://chiakimayuzumi.github.io/fonts/icon.eot?52m981');
        src: url('http://chiakimayuzumi.github.io/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('http://chiakimayuzumi.github.io/fonts/icon.woff?52m981')
               format('woff'),
             url('http://chiakimayuzumi.github.io/fonts/icon.ttf?52m981')
               format('truetype'),
             url('http://chiakimayuzumi.github.io/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/application.css">
    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu%2bMono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://chiakimayuzumi.github.io/javascripts/modernizr.js"></script>

    
    <link href="http://chiakimayuzumi.github.io/blabla/index.xml" rel="alternate" type="application/rss+xml" title="ChiakiMayuzumi" />
    <link href="http://chiakimayuzumi.github.io/blabla/index.xml" rel="feed" type="application/rss+xml" title="ChiakiMayuzumi" />
    

  </head>
  <body class="palette-primary-light red palette-accent-light green">


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        Blabla
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/ChiakiMayuzumi" title="@ChiakiMayuzumi on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://chiakimayuzumi.github.io/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://chiakimayuzumi.github.io/images/cm.png">
        </div>
      
      <div class="name">
        <strong>ChiakiMayuzumi </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="博客目录" href="http://chiakimayuzumi.github.io/">
	
	博客目录
</a>


  
</li>



<li>
  
    



<a  title="联系方式" href="http://chiakimayuzumi.github.io/sketch/">
	
	联系方式
</a>


  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/ChiakiMayuzumi" target="_blank" title="@ChiakiMayuzumi on GitHub">
              @ChiakiMayuzumi on GitHub
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>Pages in Blabla</h1>

			
			<a href="http://chiakimayuzumi.github.io/blabla/factory/" title="设计模式-工厂模式">
				<h2>设计模式-工厂模式</h2>
			</a>

			<br>
			#设计模式概要 Apple 的 Cocoa Fundamentals Guide上有这样一句话： &gt; Design Pattern is a solution to a problem in a context. 也就是说，设计模式是针对特定上下文的特定问题的解决方案，在忽略掉不重要的细节后，这种解决方案被抽象化，发现问题的一般性本质并将其模版化，找到普遍适用的解决方案从而形成了设计模式。 设计模式的本质是面向对象方法的实际运用。具体而言，是封装、继承、多态和关联的反复使用。通过封装、继承和多态把程序的耦合度降低；用设计模式使得程序更加灵活，在支持可维护性的同时，提高系统的可复用性。 设计模式主要有以下四个基本要素： 1. 模式名称（pattem name） 一个名称用来描述模式的问题、解决方案和效果。 2. 问题（problem） 描述了设计模式在何种情形使用。它解释了设计模式形成的前因后果，描述了特定的设计问题。问题往往就是模式必须满足的一系列先决条件。 3. 解决方案（solution） 描述模式的组成成分，成分之间的相互关系以及各自的指着和协作方式。 4. 效果（consequences） 效果用来描述设计模式的利弊，效果往往是我们权衡模式是否可用的重要因素。 一般来说，大家还同意模式包含以下的这些要素： 力（Force） 举例（Example） 末态环境（Resulting Context） 推理（Rationale） 其他有关模式（Related Patterns） 已知的应用（Known Uses） 还需要了解的是设计模式应当遵循的七大原则，包括：开-闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成/聚合复用原则、抽象原则和迪米特法则。由于篇幅有限这里不再介绍，附上别人的博客地址： Java设计模式遵循的七大原则 最后，我们可以把设计模式类比为各种武功招式，习武都崇尚无招胜有招，码代码亦是如此，达到最高境界后只记住一句内功心法：低耦合，高内聚。相信随着对设计模式的深入了解能够更加体会到这点的玄妙之处。 工厂模式 工厂模式专门负责将大量有共有接口的类实例化，可以动态决定将哪个类实例化，不必事先知道每次要实例化哪一个类。该模式往往是设计模式初学者入门的模式，可以称得上为典型又最具启发效果的模式。 工厂模式有三种形态，分别是简单工厂（Simple Factory）模式，工厂方法（Factory Method）模式和抽象工厂（Abstract Factory）模式。下面就从上一节中提到的基本要素开始分析三种形态的工厂模式，通过对比来理解三种模式的作用和不同之处。 名字 简单工厂（Simple Factory）：又称静态工厂方法模式（Static Factory Method Pattern），简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例，通常它返回的类都有一个公共的父类（或者接口对象）。 简单结构如图： 在简单工厂模式中，工厂类是整个模式的关键，其包含必要的判断逻辑，能够根据外界给定的信息，决定究竟创建哪个类的实例，外界可以不用去关注对象的创建，仅需要负责“消费”对象就可以了，明确区分了责任，有利于结构的优化。 工厂方法（Factory Method）：又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式。 它定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 简单结构如图： 工厂方法模式是我们在简单工厂模式的基础上再次进行抽象，为了扩展的方便和修改封闭，把一些对功能的判断不在放到一个类中，而是抽象出操作的工厂接口，各个工厂再去实现这个接口，变得更为固定，就像是机械般的。逻辑判断是在客户端通过实例化哪个具体的工厂来代替了简单工厂中工厂类中的逻辑判断。 抽象工厂（Abstract

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/blabla/composite/" title="设计模式-组合模式">
				<h2>设计模式-组合模式</h2>
			</a>

			<br>
			#模式名称（pattem name） 组合(Composite)模式的其它翻译名称也很多，比如合成模式、树模式等等。在《设计模式》一书中给出的定义是： &gt; 将对象以树形结构组织起来，以达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。 #问题（problem） 以下情况下适用组合模式： 你想表示对象的部分-整体层次结构；你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。 组合模式让你可以优化处理递归或分级数据结构。 #解决方案（solution） 在我们学习组合模式（Composite）之前，让我们先讲解一下透明方式和安全方式。 透明方式：在Component中声明所有用来管理子对象的方法，如Add()方法，Remove()方法及GetChild()方法，所有实现Component接口的子类都具备这些方法，这使得Component和子类具备一致的行为接口，使得对客户端无需区别树叶和树枝对象。 正由于我们的Composite和Leaf都具备一致的接口行为，但我们知道Leaf不应该具有Add()，Remove()及GetChild()方法，因为我们叶子节点不能再添加和移除节点了。 安全模式：在透明模式基础上把Component中声明所有用来管理子对象的方法移到Composite中，在Composite实现子对象的管理方法，那么Leaf就没有子对象管理方法，这使得Composite和Leaf的行为接口不一致，所以客户端在调用时要知道树叶和树枝对象存在。 基本结构如下： 抽象构件（Component）：定义参加组合的对象的共有方法和属性，可以定义一些默认的行为或属性。 叶子构件（Leaf）：叶子对象，其下没有分支。 树枝构件（Composit）：树枝对象，它的作用是组合树枝节点和叶子节点。 #效果（consequences） 组合模式的优点： 高层模块调用简单；一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。 节点自由增加；使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易呀，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。 组合模式的缺点： 使用组合模式后，控制树枝构件的类型不太容易。 用继承的方法来增加新的行为很困难。 组合模式的应用： 维护和展示部分－整体关系的场景，如树形菜单、文件和文件夹管理等能 从一个整体中能够独立出部分模块或功能的场景。 组合模式的注意事项： 只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧。 #示例 下面分别用两种方法实现公司的树形结构。 安全模式下的代码： 抽象构件（Component）类： package com.test.company; public abstract class Company { private String name; public Company(String name) { this.name = name; } public Company() { } public String getName() { return name; } public void setName(String name) { this.name = name; } protected abstract void display(int depth); } 树枝构件（Composit）类： package com.test.company; import java.util.ArrayList; import java.util.List; public class ConcreteCompany extends Company { private List&lt;Company&gt; cList; public ConcreteCompany() { cList = new ArrayList&lt;Company&gt;(); } public ConcreteCompany(String name) { super(name); cList = new ArrayList&lt;Company&gt;(); } public void add(Company company) { cList.add(company); } @Override protected void display(int depth) { StringBuilder sb = new StringBuilder(&quot;&quot;); for (int i =0;i&lt;depth ;i++ ) { sb.append(&quot;-&quot;); } System.out.println(new String(sb) + this.getName()); for (Company c : cList) { c.display(depth + 2); } } public void remove(Company company) { cList.remove(company); } } 叶子构件（Leaf）类： package com.test.company; public class FinanceDepartment extends Company { public FinanceDepartment(){ } public FinanceDepartment(String name){ super(name); } @Override protected void display(int depth) { StringBuilder sb = new StringBuilder(&quot;&quot;); for (int i = 0; i &lt; depth; i++) { sb.append(&quot;-&quot;); } System.out.println(new String(sb) + this.getName() ) ; } } 另一个叶子构件（Leaf）类： package com.test.company; public class HRDepartment extends Company { public HRDepartment(){ } public HRDepartment(String name){ super(name); } @Override protected void display(int depth) { StringBuilder sb = new StringBuilder(&quot;&quot;); for (int i = 0; i &lt; depth; i++) { sb.append(&quot;-&quot;); } System.out.println(new String(sb) + this.getName() ) ; } } 透明模式下的代码： 抽象构件（Component）类： package com.test.company; public abstract class Company { private String name; public Company(String name) { this.name = name; } public Company() { } public String getName() { return name; } public void setName(String name) { this.name = name; } protected abstract void add(Company company); protected abstract void remove(Company company); protected abstract void display(int depth); } 树枝构件（Composit）类： package com.test.company; import java.util.ArrayList; import java.util.List; public class ConcreteCompany extends Company { private List cList; public ConcreteCompany() { cList = new ArrayList&lt;Company&gt;(); } public ConcreteCompany(String name) { super(name); cList = new ArrayList&lt;Company&gt;(); } @Override public void add(Company company) { cList.add(company); } @Override protected void display(int depth) { StringBuilder sb = new StringBuilder(&quot;&quot;); for (int i =0;i&lt;depth ;i++ ) { sb.append(&quot;-&quot;); } System.out.println(new String(sb) + this.getName()); for (Company c : cList) { c.display(depth + 2); } } @Override protected void remove(Company company) { cList.remove(company); } } 叶子构件（Leaf）类： package com.test.company; public class FinanceDepartment extends Company { public FinanceDepartment(){ } public FinanceDepartment(String name){ super(name); } @Override protected void add(Company company) { } @Override protected void display(int depth) { StringBuilder sb = new StringBuilder(&quot;&quot;); for (int i = 0; i &lt; depth; i++) { sb.append(&quot;-&quot;); } System.out.println(new String(sb) + this.getName() ) ; } @Override protected void remove(Company company) { } } 另一个叶子构件（Leaf）类： package com.test.company; public class HRDepartment extends Company { public HRDepartment(){ } public HRDepartment(String name){ super(name); } @Override protected void add(Company company) { } @Override protected void display(int depth) { StringBuilder sb = new StringBuilder(&quot;&quot;); for (int i = 0; i &lt; depth; i++) { sb.append(&quot;-&quot;); } System.out.println(new String(sb) + this.getName() ) ; } @Override protected void remove(Company company) { } } 运行客户端，均能得到以下结果： #Android源码中的应用 在Android源码中，都能找到使用组合模式的例子，其中ViewGroup和View的结构就是非常典型的组合模式，结构图如下所示： 现在来看看它们是如何利用组合模式组织在一起的，首先在View类定义了有关具体操作，然后在ViewGroup类中继承View类，并添加相关的增加、删除和查找孩子View节点，代码如下： public abstract class ViewGroup extends View implements ViewParent, ViewManager { …… ｝ 接着看增加addView方法： /** * Adds a child view.

			<hr>
			

			<aside class="copyright" role="note">
				
				&copy; 2016 Released under the MIT license &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://chiakimayuzumi.github.io/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;
            
            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }
        

        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//gohugo.io/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
