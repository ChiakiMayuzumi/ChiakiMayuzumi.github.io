<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thirdlibs on ChiakiMayuzumi</title>
    <link>http://chiakimayuzumi.github.io/thirdlib/</link>
    <description>Recent content in Thirdlibs on ChiakiMayuzumi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Mar 2016 20:10:46 +0100</lastBuildDate>
    <atom:link href="http://chiakimayuzumi.github.io/thirdlib/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ObservableScrollView分析 —— ObservableRecyclerView 源码分析</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/recyclerview/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/recyclerview/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;前面的章节，我们主要介绍了如何利用开源库 ObservableScrollView 来实现出各种我们需要的滚动效果的实例和实现代码，却一直没有分析过在实现过程中所使用的一系列 &lt;code&gt;ObservablexxxView&lt;/code&gt; 的源代码，今天我们就来看看，在开源库中 ObservableRecyclerView 的源码。
ObservableRecyclerView 关系图如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableRecyclerView-源码分析.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableRecyclerView-源码分析.png&#34; alt=&#34;ObservableRecyclerView 源码分析&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由图可知：ObservableRecyclerView 继承自 RecyclerView 并实现 Scrollable 接口，与此同时，ObservableRecyclerView 还持有四个类的引用，这四个类分别是：ObservableScrollViewCallbacks、ScrollState、ViewGroup 和 MotionEvent，其中：&lt;/p&gt;

&lt;p&gt;ObservableScrollViewCallbacks 是开源库所定义的一个回调接口；&lt;/p&gt;

&lt;p&gt;ScrollState 是一个枚举类，表示了滑动的三个状态：&lt;code&gt;STOP&lt;/code&gt;、&lt;code&gt;UP&lt;/code&gt; 和 &lt;code&gt;DOWN&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;ViewGroup 用于在 Touch 事件拦截的过程中，指定父类 View；&lt;/p&gt;

&lt;p&gt;当用户触摸屏幕时则会产生一个 MotionEvent 对象，在 重写 &lt;code&gt;onTouchEvent()&lt;/code&gt; 方法和 &lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 方法时，都需要传入 MotionEvent 参数。&lt;/p&gt;

&lt;h2 id=&#34;scrollable&#34;&gt;Scrollable&lt;/h2&gt;

&lt;h3 id=&#34;接口方法&#34;&gt;接口方法&lt;/h3&gt;

&lt;p&gt;首先来看 Scrollable 接口，该接口是开源库所定义的一个接口，给所有接下来需要实现可观测，可滚动的控件（RecyclerView、ScrollView、ListView、WebView 和 GridView）提供了一个通用的应用程序接口，实现该接口必须实现以下几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;setScrollViewCallbacks(ObservableScrollViewCallbacks listener)：设置一个回调监听&lt;/li&gt;
&lt;li&gt;addScrollViewCallbacks(ObservableScrollViewCallbacks listener)：增加一个回调监听&lt;/li&gt;
&lt;li&gt;removeScrollViewCallbacks(ObservableScrollViewCallbacks listener)：删除一个回调监听&lt;/li&gt;
&lt;li&gt;clearScrollViewCallbacks()：清除所有回调监听&lt;/li&gt;
&lt;li&gt;scrollVerticallyTo(int y)：垂直滚动到坐标 y 处（y 为绝对坐标）&lt;/li&gt;
&lt;li&gt;getCurrentScrollY()：返回当前 y 坐标&lt;/li&gt;
&lt;li&gt;setTouchInterceptionViewGroup(ViewGroup viewGroup)：设置一个触摸事件拦截的 ViewGroup ，用来将拦截事件传递到该 View 的父类 View 中去，这也是为什么 ObservableRecyclerView 类中会有 ViewGroup 类的引用的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结一下 Scrollable 接口，主要完成对滚动控件回调接口的设置、增加、删除和清理的工作，还能实现滚动的功能，返回当前垂直方向上的坐标，并且对拦截事件的处理进行相关设置。&lt;/p&gt;

&lt;h3 id=&#34;具体实现&#34;&gt;具体实现&lt;/h3&gt;

&lt;p&gt;在 ObservableRecyclerView 中，这些方法分别是如何实现的？接下来让我们看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
  public void setScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
    mCallbacks = listener;
  }

  @Override
  public void addScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
    if (mCallbackCollection == null) {
      mCallbackCollection = new ArrayList&amp;lt;&amp;gt;();
    }
    mCallbackCollection.add(listener);
  }

  @Override
  public void removeScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
    if (mCallbackCollection != null) {
      mCallbackCollection.remove(listener);
    }
  }

  @Override
  public void clearScrollViewCallbacks() {
    if (mCallbackCollection != null) {
      mCallbackCollection.clear();
    }
  }

  @Override
  public void setTouchInterceptionViewGroup(ViewGroup viewGroup) {
    mTouchInterceptionViewGroup = viewGroup;
  }

  @Override
  public void scrollVerticallyTo(int y) {
    View firstVisibleChild = getChildAt(0);
    if (firstVisibleChild != null) {
      int baseHeight = firstVisibleChild.getHeight();
      int position = y / baseHeight;
      scrollVerticallyToPosition(position);
    }
  }
  
  @Override
  public int getCurrentScrollY() {
    return mScrollY;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ObservableRecyclerView 持有一个 ArrayList，如果需要添加多个回调接口，则将添加的接口放入该容器中，删除和清理操作也是基于该容器的操作。注意一下  &lt;code&gt;scrollVerticallyTo()&lt;/code&gt; 方法的实现，需要结合 &lt;code&gt;scrollVerticallyToPosition()&lt;/code&gt; 方法一起阅读：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void scrollVerticallyToPosition(int position) {
    LayoutManager lm = getLayoutManager();

    if (lm != null &amp;amp;&amp;amp; lm instanceof LinearLayoutManager) {
      ((LinearLayoutManager) lm).scrollToPositionWithOffset(position, 0);
    } else {
      scrollToPosition(position);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，在 &lt;code&gt;scrollVerticallyToPosition()&lt;/code&gt; 方法中，针对 LayoutManager 的类型会有一个判断，如果 LayoutManager 是 LinearLayoutManager，执行 &lt;code&gt;scrollToPositionWithOffset()&lt;/code&gt; 方法，否则执行 &lt;code&gt;scrollToPosition()&lt;/code&gt; 方法，完成最后的滚动操作。&lt;/p&gt;

&lt;h2 id=&#34;observablescrollviewcallbacks&#34;&gt;ObservableScrollViewCallbacks&lt;/h2&gt;

&lt;h3 id=&#34;接口方法-1&#34;&gt;接口方法&lt;/h3&gt;

&lt;p&gt;ObservableRecyclerView 持有 ObservableScrollViewCallbacks 的引用,该接口也是开源库所定义的接口，当使用 ObservableRecyclerView 的时候，由用户自己定义滚动时的回调函数，该接口中的方法如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onScrollChanged(int scrollY, boolean firstScroll, boolean dragging):在滚动状态发生改变的时候调用，但是不会在第一次加载页面的时候调用，如果需要在该方法中初始化布局，需要手动去调用一下。&lt;/li&gt;
&lt;li&gt;onDownMotionEvent():手指按下的事件发生时的回调函数。&lt;/li&gt;
&lt;li&gt;onUpOrCancelMotionEvent(ScrollState scrollState):手指抬起的事件发生或者滚动事件被取消时的回调函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;具体实现-1&#34;&gt;具体实现&lt;/h3&gt;

&lt;p&gt;总的来说，在使用的时候，设置监听后重写回调接口中的这三个方法，已经足够实现我们所希望的滚动监听效果了。还记得最简单的那个 ActionBar 的 &lt;code&gt;显示/隐藏&lt;/code&gt; 示例吗？首先，让 Activity 实现该接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ActionBarControlRecyclerViewActivity extends BaseActivity implements ObservableScrollViewCallbacks ……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们在 onCreate 中初始化 ObservableRecyclerView，并为它设置滚动监听：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObservableRecyclerView recyclerView = (ObservableRecyclerView) findViewById(R.id.recycler);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        recyclerView.setHasFixedSize(true);
        recyclerView.setScrollViewCallbacks(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置好监听后，必须要实现以上三个方法，为了达到 ActionBar 的 &lt;code&gt;显示/隐藏&lt;/code&gt; 效果，需要这样实现方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
    public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
    }

    @Override
    public void onDownMotionEvent() {
    }

    @Override
    public void onUpOrCancelMotionEvent(ScrollState scrollState) {
        ActionBar ab = getSupportActionBar();
        if (ab == null) {
            return;
        }
        if (scrollState == ScrollState.UP) {
            if (ab.isShowing()) {
                ab.hide();
            }
        } else if (scrollState == ScrollState.DOWN) {
            if (!ab.isShowing()) {
                ab.show();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了这个效果的实现。&lt;/p&gt;

&lt;p&gt;注意，由于该效果的代码是放在 &lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; 这个方法中，当你在滑动该页面的同时，并不会出现 &lt;code&gt;显示/隐藏&lt;/code&gt; 的效果，而是要在手指抬起的瞬间才会产生相应的效果，如果你希望在滚动的同时产生 &lt;code&gt;显示/隐藏&lt;/code&gt; 的效果，应该将实现该效果的代码放入 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法中去。&lt;/p&gt;

&lt;h2 id=&#34;observablerecyclerview-其他重要方法&#34;&gt;ObservableRecyclerView 其他重要方法&lt;/h2&gt;

&lt;p&gt;下面我们来看一下 ObservableRecyclerView 中其他的重要的方法，其中有些是重写的父类方法，有些是自己定义的方法。&lt;/p&gt;

&lt;p&gt;重写父类的方法有：
- onRestoreInstanceState(Parcelable state)
- onSaveInstanceState()
- onScrollChanged(int l, int t, int oldl, int oldt)
- onInterceptTouchEvent(MotionEvent ev)
- onTouchEvent(MotionEvent ev)
- getChildAdapterPosition(View child)
自己的方法：
- init()
- dispatchOnDownMotionEvent()
- dispatchOnScrollChanged(int scrollY, boolean firstScroll, boolean dragging)
- dispatchOnUpOrCancelMotionEvent(ScrollState scrollState)
- hasNoCallbacks()
以及一个内部类：&lt;code&gt;SavedState&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;保存状态&#34;&gt;保存状态&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 和 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 以及内部类 &lt;code&gt;SavedState&lt;/code&gt; 完成一些临时性的状态的保存工作，需要保存的属性如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mPrevFirstVisiblePosition;
private int mPrevFirstVisibleChildHeight = -1;
private int mPrevScrolledChildrenHeight;
private int mPrevScrollY;
private int mScrollY;
private SparseIntArray mChildrenHeights;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某个时刻 Activity 因为系统回收资源的问题要被杀掉，通过 onSaveInstanceState 将有机会保存其用户界面状态，使得将来用户返回到 Activity 时能通过  onCreate(Bundle) 或者 onRestoreInstanceState(Bundle) 恢复界面的状态。&lt;/p&gt;

&lt;h3 id=&#34;onscrollchanged&#34;&gt;onScrollChanged&lt;/h3&gt;

&lt;p&gt;onScrollChanged(int l, int t, int oldl, int oldt)
重写 View 中的方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
  protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if (hasNoCallbacks()) {
      return;
    }
    if (getChildCount() &amp;gt; 0) {
      int firstVisiblePosition = getChildAdapterPosition(getChildAt(0));
      int lastVisiblePosition = getChildAdapterPosition(getChildAt(getChildCount() - 1));
      for (int i = firstVisiblePosition, j = 0; i &amp;lt;= lastVisiblePosition; i++, j++) {
        int childHeight = 0;
        View child = getChildAt(j);
        if (child != null) {
          if (mChildrenHeights.indexOfKey(i) &amp;lt; 0 || (child.getHeight() != mChildrenHeights.get(i))) {
            childHeight = child.getHeight();
          }
        }
        mChildrenHeights.put(i, childHeight);
      }

      View firstVisibleChild = getChildAt(0);
      if (firstVisibleChild != null) {
        if (mPrevFirstVisiblePosition &amp;lt; firstVisiblePosition) {
          // 向下滑动
          int skippedChildrenHeight = 0;
          if (firstVisiblePosition - mPrevFirstVisiblePosition != 1) {
            for (int i = firstVisiblePosition - 1; i &amp;gt; mPrevFirstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // 把每个 item 的高度近似为第一个可见子 View 的高度
                // 这样计算也许不正确，但如果不这样做，当从底部向上滑动时scrollY会出错
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight += mPrevFirstVisibleChildHeight + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition &amp;lt; mPrevFirstVisiblePosition) {
          // 向上滑动
          int skippedChildrenHeight = 0;
          if (mPrevFirstVisiblePosition - firstVisiblePosition != 1) {
            for (int i = mPrevFirstVisiblePosition - 1; i &amp;gt; firstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // 把每个 item 的高度近似为第一个可见子 View 的高度
                // 这样计算也许不正确，但如果不这样做，当从底部向上滑动时 scrollY 会出错
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight -= firstVisibleChild.getHeight() + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition == 0) {
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
          mPrevScrolledChildrenHeight = 0;
        }
        if (mPrevFirstVisibleChildHeight &amp;lt; 0) {
          mPrevFirstVisibleChildHeight = 0;
        }
        mScrollY = mPrevScrolledChildrenHeight - firstVisibleChild.getTop() + getPaddingTop();
        mPrevFirstVisiblePosition = firstVisiblePosition;

        dispatchOnScrollChanged(mScrollY, mFirstScroll, mDragging);
        if (mFirstScroll) {
          mFirstScroll = false;
        }

        if (mPrevScrollY &amp;lt; mScrollY) {
          //向下
          mScrollState = ScrollState.UP;
        } else if (mScrollY &amp;lt; mPrevScrollY) {
          //向上
          mScrollState = ScrollState.DOWN;
        } else {
          mScrollState = ScrollState.STOP;
        }
        mPrevScrollY = mScrollY;
      }
    }
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码我们可以得知：
1、没有设置回调的话，直接返回，不会将触摸事件进行分发；
2、子布局的数量大于0的情况下，获取第一个子布局的位置 &lt;code&gt;firstVisiblePosition&lt;/code&gt; 和最后一个子布局的位置 &lt;code&gt;lastVisiblePosition&lt;/code&gt;；
3、循环遍历所有子布局，当 SparseIntArray 容器中没有保存该子布局的高度，或者保存的值跟该子布局现在的高度不一致时，将该值存入容器中；
4、比较 &lt;code&gt;mPrevFirstVisiblePosition&lt;/code&gt; 和 &lt;code&gt;firstVisiblePosition&lt;/code&gt; 的差值，判断此时的滑动方向（是 &lt;code&gt;UP&lt;/code&gt; 还是 &lt;code&gt;DOWN&lt;/code&gt;），分别求 &lt;code&gt;mPrevScrolledChildrenHeight&lt;/code&gt; 和 &lt;code&gt;mPrevFirstVisibleChildHeight&lt;/code&gt; 的大小，最终求得 &lt;code&gt;mScrollY&lt;/code&gt; 的值，调用 &lt;code&gt;dispatchOnScrollChanged()&lt;/code&gt;，让回调方法去实现最终的 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h3 id=&#34;事件分发&#34;&gt;事件分发&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 和 &lt;code&gt;onTouchEvent()&lt;/code&gt; 重写了 ViegGroup 中的方法，前者完成对触摸事件的拦截，如果检测到手指按下，则调用方法&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;。在方法 &lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;中，对事件进行处理，处理方式为：如果设置了回调，就调用回调方法中的&lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法（具体是什么操作需要用户自己在使用时实现），如果存放回调接口的容器不为零，将遍历容器中的每一个接口，调用每个接口的 &lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法。
&lt;code&gt;onTouchEvent()&lt;/code&gt; 方法中，如果检测到触摸事件被取消，则调用&lt;code&gt;dispatchOnUpOrCancelMotionEvent()&lt;/code&gt; 方法，跟上面的&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;方法类似，也会调用回调方法中的&lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; 方法，或者遍历容器。&lt;/p&gt;

&lt;p&gt;而当检测到触摸事件为 &lt;code&gt;MOVE&lt;/code&gt; 时，情况就复杂了许多，我们看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      case MotionEvent.ACTION_MOVE:
        if (mPrevMoveEvent == null) {
          mPrevMoveEvent = ev;
        }
        float diffY = ev.getY() - mPrevMoveEvent.getY();
        mPrevMoveEvent = MotionEvent.obtainNoHistory(ev);
        if (getCurrentScrollY() - diffY &amp;lt;= 0) {

          if (mIntercepted) {
            return false;
          }

          final ViewGroup parent;
          if (mTouchInterceptionViewGroup == null) {
            parent = (ViewGroup) getParent();
          } else {
            parent = mTouchInterceptionViewGroup;
          }

          float offsetX = 0;
          float offsetY = 0;
          for (View v = this; v != null &amp;amp;&amp;amp; v != parent; v = (View) v.getParent()) {
            offsetX += v.getLeft() - v.getScrollX();
            offsetY += v.getTop() - v.getScrollY();
          }
          
          final MotionEvent event = MotionEvent.obtainNoHistory(ev);
          event.offsetLocation(offsetX, offsetY);

          if (parent.onInterceptTouchEvent(event)) {
            mIntercepted = true;

            event.setAction(MotionEvent.ACTION_DOWN);

            post(new Runnable() {
              @Override
              public void run() {
                parent.dispatchTouchEvent(event);
              }
            });
            return false;
          }
          return super.onTouchEvent(ev);
        }
        break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该方法中，&lt;code&gt;mTouchInterceptionViewGroup&lt;/code&gt; 将设置好的拦截 View 赋值给 &lt;code&gt;parent&lt;/code&gt;，如果没有设置，则自动赋值当前 View 的父类给 &lt;code&gt;parent&lt;/code&gt;。得到 &lt;code&gt;parent&lt;/code&gt; 以后，就可以完成物理坐标向逻辑坐标的转换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event.offsetLocation(offsetX, offsetY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果父类已经将该事件拦截，则返回 false，并且启动线程调用父类的 &lt;code&gt;dispatchTouchEvent()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h3 id=&#34;getchildadapterposition-和-init&#34;&gt;getChildAdapterPosition 和 init&lt;/h3&gt;

&lt;p&gt;最后，&lt;code&gt;getChildAdapterPosition()&lt;/code&gt; 方法重写自 View 中的方法，根据 &lt;code&gt;recyclerViewLibraryVersion&lt;/code&gt; 的值判断是调用&lt;code&gt;getChildAdapterPosition()&lt;/code&gt; 还是 &lt;code&gt;getChildPosition()&lt;/code&gt;，而 &lt;code&gt;init()&lt;/code&gt; 方法在构造器中被调用，它新建一个SparseIntArray（比 HashMap 效率更高，可以提高性能），同时调用 &lt;code&gt;checkLibraryVersion()&lt;/code&gt; 检查 RecyclerView 库的版本号。&lt;/p&gt;

&lt;p&gt;ObservableRecyclerView 的源码分析到这里也就差不多了，通过阅读 ObservableRecyclerView 的源码，又学到了许多的知识，尤其是巩固了之前学的不是很明白的 View 的事件拦截和事件处理这部分的内容，让我受益匪浅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— ObservableScrollView 源码分析</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/scrollview/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/scrollview/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;前面的章节，我们主要介绍了如何利用开源库 ObservableScrollView 来实现出各种我们需要的滚动效果的实例和实现代码，却一直没有分析过在实现过程中所使用的一系列 &lt;code&gt;ObservablexxxView&lt;/code&gt; 的源代码，今天我们就来看看，在开源库中 ObservableScrollView 的源码。&lt;/p&gt;

&lt;p&gt;ObservableScrollView 关系图如下：
&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableScrollView-源码分析.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableScrollView-源码分析.png&#34; alt=&#34;ObservableScrollView 源码分析&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由图可知：ObservableScrollView 继承自 ScrollView 并实现 Scrollable 接口，与此同时，ObservableScrollView 还持有四个类的引用，这四个类分别是：ObservableScrollViewCallbacks、ScrollState、ViewGroup 和 MotionEvent，其中：&lt;/p&gt;

&lt;p&gt;ObservableScrollViewCallbacks 是开源库所定义的一个回调接口；&lt;/p&gt;

&lt;p&gt;ScrollState 是一个枚举类，表示了滑动的三个状态：&lt;code&gt;STOP&lt;/code&gt;、&lt;code&gt;UP&lt;/code&gt; 和 &lt;code&gt;DOWN&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;ViewGroup 用于在 Touch 事件拦截的过程中，指定父类 View；&lt;/p&gt;

&lt;p&gt;当用户触摸屏幕时则会产生一个 MotionEvent 对象，在 重写 &lt;code&gt;onTouchEvent()&lt;/code&gt; 方法和 &lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 方法时，都需要传入 MotionEvent 参数。&lt;/p&gt;

&lt;h2 id=&#34;scrollable&#34;&gt;Scrollable&lt;/h2&gt;

&lt;p&gt;该接口的方法已经在上一节中详细描述了，接下来我们直接看在 ObservableScrollView 中是如何实现该接口的。&lt;/p&gt;

&lt;h3 id=&#34;具体实现&#34;&gt;具体实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Override
    public void setScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        mCallbacks = listener;
    }

    @Override
    public void addScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        if (mCallbackCollection == null) {
            mCallbackCollection = new ArrayList&amp;lt;&amp;gt;();
        }
        mCallbackCollection.add(listener);
    }

    @Override
    public void removeScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        if (mCallbackCollection != null) {
            mCallbackCollection.remove(listener);
        }
    }

    @Override
    public void clearScrollViewCallbacks() {
        if (mCallbackCollection != null) {
            mCallbackCollection.clear();
        }
    }
    
    @Override
    public void setTouchInterceptionViewGroup(ViewGroup viewGroup) {
        mTouchInterceptionViewGroup = viewGroup;
    }

    @Override
    public void scrollVerticallyTo(int y) {
        scrollTo(0, y);
    }

    @Override
    public int getCurrentScrollY() {
        return mScrollY;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与上一节中 ObservableRecyclerView 的实现方法不同的是  &lt;code&gt;scrollVerticallyTo()&lt;/code&gt; 方法，该方法更为简洁，因为它可以直接调用继承自 ScrollView 的方法 &lt;code&gt;scrollTo()&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;observablescrollviewcallbacks&#34;&gt;ObservableScrollViewCallbacks&lt;/h2&gt;

&lt;p&gt;该接口的方法已经在上一节中详细描述了，接下来我们直接看在 ObservableScrollView 中是如何实现该接口的。&lt;/p&gt;

&lt;h3 id=&#34;具体实现-1&#34;&gt;具体实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Override
  protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if (hasNoCallbacks()) {
      return;
    }
    if (getChildCount() &amp;gt; 0) {
      int firstVisiblePosition = getChildAdapterPosition(getChildAt(0));
      int lastVisiblePosition = getChildAdapterPosition(getChildAt(getChildCount() - 1));
      for (int i = firstVisiblePosition, j = 0; i &amp;lt;= lastVisiblePosition; i++, j++) {
        int childHeight = 0;
        View child = getChildAt(j);
        if (child != null) {
          if (mChildrenHeights.indexOfKey(i) &amp;lt; 0 || (child.getHeight() != mChildrenHeights.get(i))) {
            childHeight = child.getHeight();
          }
        }
        mChildrenHeights.put(i, childHeight);
      }

      View firstVisibleChild = getChildAt(0);
      if (firstVisibleChild != null) {
        if (mPrevFirstVisiblePosition &amp;lt; firstVisiblePosition) {
          // scroll down
          int skippedChildrenHeight = 0;
          if (firstVisiblePosition - mPrevFirstVisiblePosition != 1) {
            for (int i = firstVisiblePosition - 1; i &amp;gt; mPrevFirstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // Approximate each item&#39;s height to the first visible child.
                // It may be incorrect, but without this, scrollY will be broken
                // when scrolling from the bottom.
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight += mPrevFirstVisibleChildHeight + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition &amp;lt; mPrevFirstVisiblePosition) {
          // scroll up
          int skippedChildrenHeight = 0;
          if (mPrevFirstVisiblePosition - firstVisiblePosition != 1) {
            for (int i = mPrevFirstVisiblePosition - 1; i &amp;gt; firstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // Approximate each item&#39;s height to the first visible child.
                // It may be incorrect, but without this, scrollY will be broken
                // when scrolling from the bottom.
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight -= firstVisibleChild.getHeight() + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition == 0) {
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
          mPrevScrolledChildrenHeight = 0;
        }
        if (mPrevFirstVisibleChildHeight &amp;lt; 0) {
          mPrevFirstVisibleChildHeight = 0;
        }
        mScrollY = mPrevScrolledChildrenHeight - firstVisibleChild.getTop() + getPaddingTop();
        mPrevFirstVisiblePosition = firstVisiblePosition;

        dispatchOnScrollChanged(mScrollY, mFirstScroll, mDragging);
        if (mFirstScroll) {
          mFirstScroll = false;
        }

        if (mPrevScrollY &amp;lt; mScrollY) {
          //down
          mScrollState = ScrollState.UP;
        } else if (mScrollY &amp;lt; mPrevScrollY) {
          //up
          mScrollState = ScrollState.DOWN;
        } else {
          mScrollState = ScrollState.STOP;
        }
        mPrevScrollY = mScrollY;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析详解可以参考上一节的方法。&lt;/p&gt;

&lt;h2 id=&#34;observablescrollview-其他重要方法&#34;&gt;ObservableScrollView 其他重要方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;onRestoreInstanceState(Parcelable state)&lt;/li&gt;
&lt;li&gt;onSaveInstanceState()&lt;/li&gt;
&lt;li&gt;onScrollChanged(int l, int t, int oldl, int oldt)&lt;/li&gt;
&lt;li&gt;onInterceptTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;li&gt;onTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;li&gt;getChildAdapterPosition(View child)
自己的方法：&lt;/li&gt;
&lt;li&gt;dispatchOnDownMotionEvent()&lt;/li&gt;
&lt;li&gt;dispatchOnScrollChanged(int scrollY, boolean firstScroll, boolean dragging)&lt;/li&gt;
&lt;li&gt;dispatchOnUpOrCancelMotionEvent(ScrollState scrollState)&lt;/li&gt;
&lt;li&gt;hasNoCallbacks()
以及一个内部类：&lt;code&gt;SavedState&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;保存状态&#34;&gt;保存状态&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 和 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 以及内部类 &lt;code&gt;SavedState&lt;/code&gt; 完成一些临时性的状态的保存工作，需要保存的属性如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mPrevScrollY;
private int mScrollY;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某个时刻 Activity 因为系统回收资源的问题要被杀掉，通过 onSaveInstanceState 将有机会保存其用户界面状态，使得将来用户返回到 Activity 时能通过  onCreate(Bundle) 或者 onRestoreInstanceState(Bundle) 恢复界面的状态。&lt;/p&gt;

&lt;h3 id=&#34;onscrollchanged&#34;&gt;onScrollChanged&lt;/h3&gt;

&lt;p&gt;onScrollChanged(int l, int t, int oldl, int oldt)
重写 View 中的方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
    protected void onScrollChanged(int l, int t, int oldl, int oldt) {
        super.onScrollChanged(l, t, oldl, oldt);
        if (hasNoCallbacks()) {
            return;
        }
        mScrollY = t;

        dispatchOnScrollChanged(t, mFirstScroll, mDragging);
        if (mFirstScroll) {
            mFirstScroll = false;
        }

        if (mPrevScrollY &amp;lt; t) {
            mScrollState = ScrollState.UP;
        } else if (t &amp;lt; mPrevScrollY) {
            mScrollState = ScrollState.DOWN;
        }
        mPrevScrollY = t;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码我们可以得知：
1、没有设置回调的话，直接返回，不会将触摸事件进行分发；
2、如果 &lt;code&gt;mPrevScrollY&lt;/code&gt; 小于 &lt;code&gt;t&lt;/code&gt;，则滚动状态为 &lt;code&gt;UP&lt;/code&gt;，如果 &lt;code&gt;mPrevScrollY&lt;/code&gt; 大于 &lt;code&gt;t&lt;/code&gt;，则滚动状态为 &lt;code&gt;DOWN&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;事件分发&#34;&gt;事件分发&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 和 &lt;code&gt;onTouchEvent()&lt;/code&gt; 重写了 ViegGroup 中的方法，前者完成对触摸事件的拦截，如果检测到手指按下，则调用方法&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;。在方法 &lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;中，对事件进行处理，处理方式为：如果设置了回调，就调用回调方法中的&lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法（具体是什么操作需要用户自己在使用时实现），如果存放回调接口的容器不为零，将遍历容器中的每一个接口，调用每个接口的 &lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法。
&lt;code&gt;onTouchEvent()&lt;/code&gt; 方法中，如果检测到触摸事件被取消，则调用&lt;code&gt;dispatchOnUpOrCancelMotionEvent()&lt;/code&gt; 方法，跟上面的&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;方法类似，也会调用回调方法中的&lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; 方法，或者遍历容器。
而当检测到触摸事件为 &lt;code&gt;MOVE&lt;/code&gt; 时，情况依然复杂，我们看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case MotionEvent.ACTION_MOVE:
                if (mPrevMoveEvent == null) {
                    mPrevMoveEvent = ev;
                }
                float diffY = ev.getY() - mPrevMoveEvent.getY();
                mPrevMoveEvent = MotionEvent.obtainNoHistory(ev);
                if (getCurrentScrollY() - diffY &amp;lt;= 0) {
                    // Can&#39;t scroll anymore.

                    if (mIntercepted) {
                        // Already dispatched ACTION_DOWN event to parents, so stop here.
                        return false;
                    }

                    // Apps can set the interception target other than the direct parent.
                    final ViewGroup parent;
                    if (mTouchInterceptionViewGroup == null) {
                        parent = (ViewGroup) getParent();
                    } else {
                        parent = mTouchInterceptionViewGroup;
                    }

                    // Get offset to parents. If the parent is not the direct parent,
                    // we should aggregate offsets from all of the parents.
                    float offsetX = 0;
                    float offsetY = 0;
                    for (View v = this; v != null &amp;amp;&amp;amp; v != parent; v = (View) v.getParent()) {
                        offsetX += v.getLeft() - v.getScrollX();
                        offsetY += v.getTop() - v.getScrollY();
                    }
                    final MotionEvent event = MotionEvent.obtainNoHistory(ev);
                    event.offsetLocation(offsetX, offsetY);

                    if (parent.onInterceptTouchEvent(event)) {
                        mIntercepted = true;

                        // If the parent wants to intercept ACTION_MOVE events,
                        // we pass ACTION_DOWN event to the parent
                        // as if these touch events just have began now.
                        event.setAction(MotionEvent.ACTION_DOWN);

                        // Return this onTouchEvent() first and set ACTION_DOWN event for parent
                        // to the queue, to keep events sequence.
                        post(new Runnable() {
                            @Override
                            public void run() {
                                parent.dispatchTouchEvent(event);
                            }
                        });
                        return false;
                    }
                
                    return super.onTouchEvent(ev);
                }
                break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该方法中，&lt;code&gt;mTouchInterceptionViewGroup&lt;/code&gt; 将设置好的拦截 View 赋值给 &lt;code&gt;parent&lt;/code&gt;，如果没有设置，则自动赋值当前 View 的父类给 &lt;code&gt;parent&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果父类已经将该事件拦截，则返回 false，并且启动线程调用父类的 &lt;code&gt;dispatchTouchEvent()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;ObservableScrollView 的源码分析到这里也就差不多了，通过阅读 ObservableScrollView 的源码，跟上一节的 ObservableRecyclerView 源码进行了对比，也让我再一次了解到了 RecyclerView 跟 ScrollView 的不同之处。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— Sticky header 顶部固定</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/header/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/header/</guid>
      <description>

&lt;p&gt;这一节主要说明了如何实现在滚动视图中将顶部固定在屏幕最上方的效果，并给出在各个 View 上如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;StickyHeaderListViewActivity&lt;/li&gt;
&lt;li&gt;StickyHeaderRecyclerViewActivity&lt;/li&gt;
&lt;li&gt;StickyHeaderScrollViewActivity&lt;/li&gt;
&lt;li&gt;StickyHeaderWebViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;顶部固定效果是 &lt;code&gt;显示/隐藏 Toolbar&lt;/code&gt; 效果的更加复杂的版本，将一半的 &lt;code&gt;header view&lt;/code&gt; 保留在屏幕的顶部。这一次我们用 ScrollView 来示范，方法套用到其他的 view 上也并不困难。&lt;/p&gt;

&lt;h2 id=&#34;使用-scrollview&#34;&gt;使用 ScrollView&lt;/h2&gt;

&lt;h3 id=&#34;scrollview-的布局&#34;&gt;ScrollView 的布局&lt;/h3&gt;

&lt;p&gt;先看布局，以下是 ScrollView 的顶部固定样式的基本结构，比之前的 &lt;code&gt;显示/隐藏 Toolbar&lt;/code&gt; 布局要复杂许多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ObservableScrollView android:id=&amp;quot;@+id/scroll&amp;quot;&amp;gt;
    &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
      &amp;lt;View android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
      &amp;lt;View android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
      &amp;lt;TextView/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
  &amp;lt;/ObservableScrollView&amp;gt;
  &amp;lt;LinearLayout
    android:id=&amp;quot;@+id/header&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
    &amp;lt;Toolbar
      android:id=&amp;quot;@+id/toolbar&amp;quot;
      android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
    &amp;lt;TextView
      android:id=&amp;quot;@+id/sticky&amp;quot;
      android:layout_height=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
  &amp;lt;/LinearLayout&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;显示/隐藏 Toolbar&lt;/code&gt; 样式中，我们只使用了 ObservableScrollView 和 Toolbar，这一次我们让每一个视图都变得更加复杂了。&lt;/p&gt;

&lt;h4 id=&#34;为-scrollview-创造顶部空间&#34;&gt;为 ScrollView 创造顶部空间&lt;/h4&gt;

&lt;p&gt;初始化时，ScrooView 需要一个两倍体积于 ActionBar的空间，其中一半会在滑动的过程中固定住，因此简单的在 TextView 布局上使用高度  &lt;code&gt;?attr/actionBarSize&lt;/code&gt; 添加两个 view 就可以了。&lt;/p&gt;

&lt;p&gt;也可以直接用确定的 dp 值来添加一个 view 即可，不过这样的话，就不能更好的适应不同尺寸的屏幕。&lt;/p&gt;

&lt;p&gt;需要注意的是，TextView 是 ScrollView 里的实际内容。你可以用其他的 view 来替换它。&lt;/p&gt;

&lt;h4 id=&#34;为-toolbar-制作固定部分&#34;&gt;为 Toolbar 制作固定部分&lt;/h4&gt;

&lt;p&gt;跟显示/隐藏 Toolbar不同的是，这里我们用 &lt;code&gt;LinearLayout&lt;/code&gt; 替换掉了之前的 Toolbar 布局，这个 &lt;code&gt;LinearLayout&lt;/code&gt; 里面包涵了一个 Toolbar 和一个 TextView，这里 TextView 将会是被固定的部分，你也可以用一些其他更复杂的 view 来代替。&lt;/p&gt;

&lt;h3 id=&#34;使用-scrollview-的回调让视图动画起来&#34;&gt;使用 ScrollView 的回调让视图动画起来&lt;/h3&gt;

&lt;p&gt;使用了两个回调： &lt;code&gt;onScrollChanged()&lt;/code&gt; 和  &lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; ，让视图动起来，我们需要实现下面的动画效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 ScrollView 滚动时，让 Toolbar 和固定 view 都动起来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Toolbar 会随着滚动移出屏幕，但是当我们再滚动屏幕的时候，固定的视图必须保持在屏幕的顶部。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Toolbar 还未完全移出屏幕，停止滚动时：如果我们正在上滑，则完全隐藏 Toolbar；如果我们正在下滑，则完全显示 Toolbar。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;向下滚动 ScrollView 并且抬起手指后，&lt;code&gt;header view&lt;/code&gt; 会立即出现，这被称为快速恢复模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;scrollview-滚动时移动-header-view&#34;&gt;ScrollView 滚动时移动 header view&lt;/h4&gt;

&lt;p&gt;重写方法 &lt;code&gt;onScrollChanged()&lt;/code&gt;，先写上伪代码 &lt;code&gt;if (dragging)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    // 完成剩下的代码
  //} else { // ScrollView 按照惯性滑动
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只想在拖拽的时候去移动 view，否则我们就无法实现上述的第三种情况：当滚动结束后自动的显示或者隐藏 Toolbar 。&lt;/p&gt;

&lt;p&gt;下一步，完成 &lt;code&gt;header view&lt;/code&gt; 的动画。&lt;/p&gt;

&lt;p&gt;首先，创建一个属性 &lt;code&gt;mHeaderView&lt;/code&gt; 并在 &lt;code&gt;onCreate()&lt;/code&gt; 里初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mHeaderView = findViewById(R.id.header);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mHeaderView&lt;/code&gt; 的高度随着 &lt;code&gt;scrollY&lt;/code&gt; 变量的增长而减少，因此代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    ViewHelper.setTranslationY(mHeaderView, -scrollY);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;固定的-view-应该留在屏幕顶端&#34;&gt;固定的 view 应该留在屏幕顶端&lt;/h4&gt;

&lt;p&gt;如果按照上面的写法，整个 &lt;code&gt;header view&lt;/code&gt; 都会随着滚动完全消失，这不是我们希望看到的结果，&lt;code&gt;mHeaderView&lt;/code&gt; 应该在移动到 Toolbar 高度以后就停止减少。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    int toolbarHeight = mToolbarView.getHeight();
    ViewHelper.setTranslationY(mHeaderView, Math.max(-toolbarHeight, -scrollY));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以把固定的部分一直留在顶部。&lt;/p&gt;

&lt;h4 id=&#34;toolbar-未完全消失时&#34;&gt;Toolbar 未完全消失时&lt;/h4&gt;

&lt;p&gt;我们应该使用 &lt;code&gt;onUpOrCancelMotionEvent&lt;/code&gt; 方法来达到我们想要达到的效果。&lt;/p&gt;

&lt;p&gt;如果向下滑，Toolbar 应该完全显示；如果向上滑，Toolbar 应该完全隐藏：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
  if (scrollState == ScrollState.DOWN) {
    showToolbar();
  } else if (scrollState == ScrollState.UP) {
    hideToolbar();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当我们上滑并且滚动的少于 Toolbar 高度时，隐藏 Toolbar 的时候会使得 ScrollView 的顶部出现一段空白，所以我们需要在&lt;code&gt;scrollY&lt;/code&gt; 少于 Toolbar 高度的时候使它显示而不是隐藏。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
  if (scrollState == ScrollState.DOWN) {
    showToolbar();
  } else if (scrollState == ScrollState.UP) {
    int toolbarHeight = mToolbarView.getHeight();
    int scrollY = mScrollView.getCurrentScrollY();
    if (toolbarHeight &amp;lt;= scrollY) {
      hideToolbar();
    } else {
      showToolbar();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候滑动状态变为停止（或者null）后， &lt;code&gt;header view&lt;/code&gt;  也会停止滑动，为了避免这种情况发生，我们写上else分支的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
  if (scrollState == ScrollState.DOWN) {
    showToolbar();
  } else if (scrollState == ScrollState.UP) {
    int toolbarHeight = mToolbarView.getHeight();
    int scrollY = mScrollView.getCurrentScrollY();
    if (toolbarHeight &amp;lt;= scrollY) {
      hideToolbar();
    } else {
      showToolbar();
    }
  } else {
    // 就算onScrollChanged 发生的时候scrollY没有改变，toolbar也应该调整位置
    if (!toolbarIsShown() &amp;amp;&amp;amp; !toolbarIsHidden()) {
      showToolbar();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将没写完的方法都写完。&lt;/p&gt;

&lt;p&gt;可以使用 &lt;code&gt;ViewPropertyAnimator.animate()&lt;/code&gt; 这样简单而又不改变 view 高度的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean toolbarIsShown() {
  return ViewHelper.getTranslationY(mHeaderView) == 0;
}

private boolean toolbarIsHidden() {
  return ViewHelper.getTranslationY(mHeaderView) == -mToolbarView.getHeight();
}

private void showToolbar() {
  float headerTranslationY = ViewHelper.getTranslationY(mHeaderView);
  if (headerTranslationY != 0) {
    ViewPropertyAnimator.animate(mHeaderView).cancel();
    ViewPropertyAnimator.animate(mHeaderView).translationY(0).setDuration(200).start();
  }
}

private void hideToolbar() {
  float headerTranslationY = ViewHelper.getTranslationY(mHeaderView);
  int toolbarHeight = mToolbarView.getHeight();
  if (headerTranslationY != -toolbarHeight) {
    ViewPropertyAnimator.animate(mHeaderView).cancel();
    ViewPropertyAnimator.animate(mHeaderView).translationY(-toolbarHeight).setDuration(200).start();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;ViewPropertyAnimator.animate()&lt;/code&gt; 后，在接下来的 200ms 会运行动画效果。如果下一个动画（ &lt;code&gt;showToolbar()&lt;/code&gt; 或者 &lt;code&gt;hideToolbar()&lt;/code&gt; ）在这个动画运行的时候被调用，则当前动画会被取消，因此在调用  &lt;code&gt;start()&lt;/code&gt; 之前，我们先调用 &lt;code&gt;ViewPropertyAnimator.animate(mHeaderView).cancel()&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;上滑让-header-view-滚动起来&#34;&gt;上滑让 header view 滚动起来&lt;/h4&gt;

&lt;p&gt;基本功能都快完成了，接下来还有一个地方没有实现。&lt;/p&gt;

&lt;p&gt;当我们滚动了很大一段距离以后，只需要稍稍向上滚动一点，即可显示 header view，但是当我们再向下滚动的时候，&lt;code&gt;header view&lt;/code&gt; 不会跟随 ScrollView 滚动。&lt;/p&gt;

&lt;p&gt;所以，即使在 &lt;code&gt;scrollY&lt;/code&gt; 比 Toolbar 的高度还要大的情况下，我们也要让它滚动起来。&lt;/p&gt;

&lt;p&gt;只需要计算第一次触摸屏幕的点和当前点的距离即可，当这个距离比 Toolbar 的高度要大，&lt;code&gt;header view&lt;/code&gt; 就不应该再滚动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mBaseTranslationY;

@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    int toolbarHeight = mToolbarView.getHeight();
    if (firstScroll) { // 添加这个if分句
      float currentHeaderTranslationY = ViewHelper.getTranslationY(mHeaderView);
      if (-toolbarHeight &amp;lt; currentHeaderTranslationY) {
        mBaseTranslationY = scrollY;
      }
    }
    // 把 -scrollY 换成 -(scrollY - mBaseTranslationY)
    float headerTranslationY = Math.max(-toolbarHeight, -(scrollY - mBaseTranslationY));
    ViewPropertyAnimator.animate(mHeaderView).cancel();
    ViewHelper.setTranslationY(mHeaderView, headerTranslationY);
  }
}

@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
    // 滚动结束后清零
    mBaseTranslationY = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是发现了一个奇怪的事情，&lt;code&gt;header view&lt;/code&gt; 离开了屏幕的最顶端，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ScrollView异常.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ScrollView异常.png&#34; alt=&#34;ScrollView异常&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是因为 &lt;code&gt;headerTranslationY&lt;/code&gt; 可以变得比0要大，应该将这个值用 &lt;code&gt;Math.min()&lt;/code&gt; 限定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float headerTranslationY = Math.min(0, Math.max(-toolbarHeight, -(scrollY - mBaseTranslationY));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果觉得表达太复杂，还可以使用本开源库提供的一个小的工具类 &lt;code&gt;ScrollUtils&lt;/code&gt;，可以将上面的 &lt;code&gt;Math.min(max, Math.max(min, value))&lt;/code&gt;替换成 &lt;code&gt;ScrollUtils.getFloat()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float headerTranslationY = ScrollUtils.getFloat(-(scrollY - mBaseTranslationY), -toolbarHeight, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成啦。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;当需要实现复杂的滚动和动画效果时，一定要仔细分析清楚其中的逻辑，将问题有条理的分开解决，这样才会达到自己想要的效果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— Toolbar上的弹性空白</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/toolbarblank/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/toolbarblank/</guid>
      <description>

&lt;p&gt;这一节主要说明了如何在 Toolbar 上方实现弹性空白布局，并给出在各个 View 上如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FlexibleSpaceToolbarScrollViewActivity&lt;/li&gt;
&lt;li&gt;FlexibleSpaceToolbarWebViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scrollview-实现弹性空白&#34;&gt;ScrollView 实现弹性空白&lt;/h2&gt;

&lt;h3 id=&#34;scrollview-布局&#34;&gt;ScrollView 布局&lt;/h3&gt;

&lt;h4 id=&#34;基本结构&#34;&gt;基本结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ObservableScrollView android:id=&amp;quot;@+id/scroll&amp;quot;&amp;gt;
    &amp;lt;FrameLayout android:id=&amp;quot;@+id/body&amp;quot;&amp;gt;
      &amp;lt;TextView/&amp;gt;
    &amp;lt;/FrameLayout&amp;gt;
  &amp;lt;/ObservableScrollView&amp;gt;
  &amp;lt;View android:id=&amp;quot;@+id/flexible_space&amp;quot;/&amp;gt;
  &amp;lt;Toolbar android:id=&amp;quot;@+id/toolbar&amp;quot;/&amp;gt;
  &amp;lt;RelativeLayout android:paddingLeft=&amp;quot;@dimen/toolbar_margin_start&amp;quot;&amp;gt;
    &amp;lt;TextView android:id=&amp;quot;@+id/title&amp;quot;/&amp;gt;
    &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
      &amp;lt;View android:layout_height=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
      &amp;lt;View android:layout_height=&amp;quot;@dimen/flexible_space_height&amp;quot;/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
  &amp;lt;/RelativeLayout&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看过之前章节的话一定知道，根布局 FrameLayout 可以实现分别移动其子布局的功能。
第二个位于 ScrollView 中的 FrameLayout 布局 （&lt;code&gt;@id/body&lt;/code&gt;）是主要的内容布局，如果需要的话，可以换成任何你想要的布局。这里我们就用一个 TextView 来充当当前布局的内容。&lt;/p&gt;

&lt;p&gt;View（&lt;code&gt;@id/flexible_space&lt;/code&gt;）构成了一个背景不透明的弹性空白空间，在滚动时，该视图会随着Y轴坐标的改变而垂直滚动。&lt;/p&gt;

&lt;p&gt;Toolbar 只是一个普通的 Toolbar ，不过这个 Toolbar 没有设置标题。&lt;/p&gt;

&lt;p&gt;接下来的 RelativeLayout 和它的子布局比较复杂，首先，TextView（&lt;code&gt;@id/title&lt;/code&gt;） 才是真正的 &lt;code&gt;title view&lt;/code&gt; ，其他的布局（LinearLayout，view）都只是填充，因为在这个弹性空白的样式里，TextView 里面内容的字体大小（也就是标题的字体大小）会有所变化，所以它需要额外的空间。要达到这样的动画效果，可以使得 TextView 动画起来，因此其他的填充都应该在 TextView 的外面。&lt;/p&gt;

&lt;p&gt;想要了解其他的属性，可以自己在 app 里面查看相应的布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res/layout/activity_flexiblespacetoolbarscrollview.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;初始化开始，将 Toolbar 设置成为 ActionBar ，并让其显示返回（ &lt;code&gt;homeAsUp&lt;/code&gt; ）箭头。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_flexiblespacetoolbarscrollview);

  setSupportActionBar((Toolbar) findViewById(R.id.toolbar));
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到这个 Activity 的标题并将它设置到 ID 为 &lt;code&gt;@id/title&lt;/code&gt; 的 TextView。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mTitleView = (TextView) findViewById(R.id.title);
  mTitleView.setText(getTitle());
  setTitle(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后初始化其他的视图和属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private View mFlexibleSpaceView;
private View mToolbarView;
private TextView mTitleView;
private int mFlexibleSpaceHeight;

@Override
protected void onCreate(Bundle savedInstanceState) {
  // 省略前面已经说明过的代码
  mFlexibleSpaceView = findViewById(R.id.flexible_space);
  mToolbarView = findViewById(R.id.toolbar);

  final ObservableScrollView scrollView = (ObservableScrollView) findViewById(R.id.scroll);
  scrollView.setScrollViewCallbacks(this);

  mFlexibleSpaceHeight = getResources().getDimensionPixelSize(R.dimen.flexible_space_height);
  int flexibleSpaceAndToolbarHeight = mFlexibleSpaceHeight + getActionBarSize();

  findViewById(R.id.body).setPadding(0, flexibleSpaceAndToolbarHeight, 0, 0);
  mFlexibleSpaceView.getLayoutParams().height = flexibleSpaceAndToolbarHeight;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以在 Activity 的声明后面添加 &lt;code&gt;implements ObservableScrollViewCallbacks&lt;/code&gt; 来得到上面的方法。&lt;/p&gt;

&lt;h3 id=&#34;动画&#34;&gt;动画&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法产生需要的动画效果。我们必须要实现以下的代码：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;移动弹性空白空间&lt;/li&gt;
&lt;li&gt;移动并缩放标题（&lt;code&gt;title view&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;移动弹性空白空间&#34;&gt;移动弹性空白空间&lt;/h4&gt;

&lt;p&gt;实现起来较为简单，只需要用 &lt;code&gt;scrollY&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  ViewHelper.setTranslationY(mFlexibleSpaceView, -scrollY);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;缩放标题&#34;&gt;缩放标题&lt;/h3&gt;

&lt;p&gt;需要思考的问题是如何改变字体的大小？直接在布局修改字体的 &lt;code&gt;size&lt;/code&gt; 显然是不可以的，应该考虑用缩放的效果去实现字体大小的改变。&lt;/p&gt;

&lt;p&gt;缩放的值从 &lt;code&gt;1&lt;/code&gt; 变化到 &lt;code&gt;1.x&lt;/code&gt;，你可以改变这个 &lt;code&gt;.x&lt;/code&gt; 的值，来达到你想要的缩放效果。或者可以使用弹性空白和 Toolbar 的高度来计算出一个最大的缩放值，也就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float maxScale = (float) (mFlexibleSpaceHeight - mToolbarView.getHeight()) / mToolbarView.getHeight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缩放值（指的是 &lt;code&gt;.x&lt;/code&gt; 值）从 0 变化到最大值 &lt;code&gt;maxScale&lt;/code&gt;，可以这样来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 对scrollY的值进行限制
int adjustedScrollY = (int) ScrollUtils.getFloat(scrollY, 0, mFlexibleSpaceHeight);

// scrollY为0时，缩放值应该为最大
// scrollY达到mFlexibleSpaceHeight的值时，缩放值应该为0 
float scale = maxScale * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当缩放视图的时候，我们需要设置一个缩放的中心点，也就是 &lt;code&gt;pivotX&lt;/code&gt; 和 &lt;code&gt;pivotY&lt;/code&gt; 两个参数，应该设置为 &lt;code&gt;（0，0）&lt;/code&gt; 。默认的缩放点如下图左，设置后的缩放点如下图右：
&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/滚动中心点设置.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/滚动中心点设置.png&#34; alt=&#34;滚动中心点设置&#34; /&gt;&lt;/a&gt;
先设置缩放中心点，然后改变缩放值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 设置标题的缩放中心点 (0, 0)
ViewHelper.setPivotX(mTitleView, 0);
ViewHelper.setPivotY(mTitleView, 0);

// 缩放标题
ViewHelper.setScaleX(mTitleView, 1 + scale);
ViewHelper.setScaleY(mTitleView, 1 + scale);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动标题&#34;&gt;移动标题&lt;/h4&gt;

&lt;p&gt;移动标题的实现较为复杂，我们先看下图：
&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/计算TextView的最大值.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/计算TextView的最大值.png&#34; alt=&#34;计算TextView的最大值&#34; /&gt;&lt;/a&gt;
最小的 &lt;code&gt;translationY&lt;/code&gt; 明显应该为 0 ，需要思考的是如何得到最大的 &lt;code&gt;translationY&lt;/code&gt; 值，从图中可以看出，最大的 &lt;code&gt;translationY&lt;/code&gt; 可以由 &lt;code&gt;ht1 + hf - ht2&lt;/code&gt; 计算得出，所以代码应该这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxTitleTranslationY = mToolbarView.getHeight() + mFlexibleSpaceHeight - (int) (mTitleView.getHeight() * (1 + scale));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;scrollY&lt;/code&gt; 来改变这个值，&lt;code&gt;scrollY&lt;/code&gt; 应该被限定，并且早就被计算为 &lt;code&gt;adjustedScrollY&lt;/code&gt; 值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; int titleTranslationY = (int) (maxTitleTranslationY * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight);
  ViewHelper.setTranslationY(mTitleView, titleTranslationY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，将转换和缩放的代码完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  ViewHelper.setTranslationY(mFlexibleSpaceView, -scrollY);

  // 计算缩放值
  int adjustedScrollY = (int) ScrollUtils.getFloat(scrollY, 0, mFlexibleSpaceHeight);
  float maxScale = (float) (mFlexibleSpaceHeight - mToolbarView.getHeight()) / mToolbarView.getHeight();
  float scale = maxScale * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight;

  // 设置标题的缩放中心点 (0, 0)
  ViewHelper.setPivotX(mTitleView, 0);
  ViewHelper.setPivotY(mTitleView, 0);

  // 缩放标题
  ViewHelper.setScaleX(mTitleView, 1 + scale);
  ViewHelper.setScaleY(mTitleView, 1 + scale);

  // 移动标题
  int maxTitleTranslationY = mToolbarView.getHeight() + mFlexibleSpaceHeight - (int) (mTitleView.getHeight() * (1 + scale));
  int titleTranslationY = (int) (maxTitleTranslationY * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight);
  ViewHelper.setTranslationY(mTitleView, titleTranslationY);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;调整-title-的初始状态&#34;&gt;调整 &lt;code&gt;title&lt;/code&gt; 的初始状态&lt;/h4&gt;

&lt;p&gt;也许你会注意到，当页面初始启动的时候，标题会固定在屏幕的顶部，而我们需要的应该是一开始就让它呆在头部视图的最下面，并且应该是最大的字体。&lt;/p&gt;

&lt;p&gt;出现这样的情况是因为在刚开始进入页面时，&lt;code&gt;onScrollChanged()&lt;/code&gt; 方法不会被调用，如果要改善，方法是在布局好 view 后立即调用 &lt;code&gt;onScrollChanged()&lt;/code&gt;。你也可以通过使用 &lt;code&gt;ViewTreeObserver#addOnGlobalLayoutListener()&lt;/code&gt; 处理这种布局方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
  // 其他的初始化代码省略
  ViewTreeObserver vto = mTitleView.getViewTreeObserver();
  vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
      if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.JELLY_BEAN) {
        view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
      } else {
        view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
      }
      updateFlexibleSpaceText(scrollView.getCurrentScrollY());
    }
  });
}

@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  updateFlexibleSpaceText(scrollY);
}

private void updateFlexibleSpaceText(scrollY) {
  // 省略原始动画代码
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将下面的 &lt;code&gt;ViewTreeObserver&lt;/code&gt; 代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewTreeObserver vto = mTitleView.getViewTreeObserver();
vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
  @Override
  public void onGlobalLayout() {
    if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.JELLY_BEAN) {
      view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
    } else {
      view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
    }
    updateFlexibleSpaceText(scrollView.getCurrentScrollY());
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ScrollUtils.addOnGlobalLayoutListener(mTitleView, new Runnable() {
  @Override
  public void run() {
    updateFlexibleSpaceText(scrollView.getCurrentScrollY());
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成了整个弹性空白效果的实现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— 使用图像的弹性空白布局</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/pictureblank/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/pictureblank/</guid>
      <description>

&lt;p&gt;这一节主要说明了使用图像来实现弹性空白布局，并给出在各个 View 上如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FlexibleSpaceWithImageListViewActivity&lt;/li&gt;
&lt;li&gt;FlexibleSpaceWithImageRecyclerViewActivity&lt;/li&gt;
&lt;li&gt;FlexibleSpaceWithImageScrollViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想要更好的读懂本节文章，请先阅读：&lt;a href=&#34;http://blog.qiji.tech/archives/10525&#34;&gt;[Android] ObservableScrollView分析（六）—— Toolbar上的弹性空白&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;scrollview-实现弹性空白&#34;&gt;ScrollView 实现弹性空白&lt;/h2&gt;

&lt;h3 id=&#34;scrollview-布局&#34;&gt;ScrollView 布局&lt;/h3&gt;

&lt;h4 id=&#34;基本结构&#34;&gt;基本结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
    &amp;lt;ImageView android:id=&amp;quot;@+id/image&amp;quot;/&amp;gt;
    &amp;lt;View android:id=&amp;quot;@+id/overlay&amp;quot;/&amp;gt;
    &amp;lt;ObservableScrollView android:id=&amp;quot;@+id/scroll&amp;quot;&amp;gt;
        &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
            &amp;lt;View/&amp;gt;
            &amp;lt;TextView/&amp;gt;
        &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;/ObservableScrollView&amp;gt;
    &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
        &amp;lt;TextView android:id=&amp;quot;@+id/title&amp;quot;/&amp;gt;
        &amp;lt;View/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;FloatingActionButton android:id=&amp;quot;@+id/fab&amp;quot;/&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根布局 FrameLayout 可以实现分别移动其子布局的功能。&lt;/p&gt;

&lt;p&gt;ImageView (&lt;code&gt;@id/image&lt;/code&gt;) 布局里放的是在移动时会产生视差效果的图片。&lt;/p&gt;

&lt;p&gt;View (&lt;code&gt;@id/overlay&lt;/code&gt;) 如同它的id名一样，是用来覆盖 ImageView 的一个视图。打开 &lt;code&gt;demo app&lt;/code&gt; 中的这个Activity （&lt;code&gt;FlexibleSpaceWithImageScrollViewActivity&lt;/code&gt;），滑动一下，你会发现图片会产生一种淡入淡出的效果，产生这个效果的原因就是覆盖在 ImageView 上面的 View 会随着滑动位置的改变而改变其不透明度。&lt;/p&gt;

&lt;p&gt;LinearLayout 及其子布局，是整个布局中真正的标题布局。这样的布局在上一节中也出现了，所以不再赘述。&lt;/p&gt;

&lt;p&gt;FloatingActionButton 是从 &lt;code&gt;FloatingActionButton&lt;/code&gt; 库中导入的一个简单又炫酷的小控件。
这个控件是可选项，如果你不需要它，可以将它移除。demo app 中放入这个控件是因为它是一个非常典型的遵循 Material Design 风格的控件，也许你们会喜欢。&lt;/p&gt;

&lt;p&gt;想要了解其他的属性，可以自己在 &lt;code&gt;demo app&lt;/code&gt; 里面查看相应的布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res/layout/activity_flexiblespacewithimagescrollview.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;省略掉那些简单的，或者跟本节无关的代码后，只放上相关的初始化代码：&lt;/p&gt;

&lt;p&gt;将 &lt;code&gt;title&lt;/code&gt; 的值赋给真正的 &lt;code&gt;title view&lt;/code&gt;（TextView），然后给原来的 &lt;code&gt;title&lt;/code&gt; 赋值为 &lt;code&gt;null&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mTitleView.setText(getTitle());
setTitle(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到资源文件中的尺寸信息，并将它们赋给相应的属性值（这样可以简化动画部分的代码）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mFlexibleSpaceImageHeight = getResources().getDimensionPixelSize(R.dimen.flexible_space_image_height);
mFlexibleSpaceShowFabOffset = getResources().getDimensionPixelSize(R.dimen.flexible_space_show_fab_offset);
mFabMargin = getResources().getDimensionPixelSize(R.dimen.margin_standard);
mActionBarSize = getActionBarSize();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到布局视图，并将它们赋给相应的属性值（这样可以简化动画部分的代码）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mImageView = findViewById(R.id.image);
mOverlayView = findViewById(R.id.overlay);
mScrollView = (ObservableScrollView) findViewById(R.id.scroll);
mScrollView.setScrollViewCallbacks(this);
mTitleView = (TextView) findViewById(R.id.title);
mFab = findViewById(R.id.fab);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管跟滚动动画的实现可能没什么关系，还是需要在 &lt;code&gt;onCreate（）&lt;/code&gt; 方法中将 floating action button (FAB) 的缩放值设置为 0，因为我们想要在一开始的时候将它隐藏，随着滚动慢慢增加缩放值从而让它显示出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setScaleX(mFab, 0);
ViewHelper.setScaleY(mFab, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有必要给这个 Activity 添加上接口 &lt;code&gt;implements ObservableScrollViewCallbacks&lt;/code&gt; 并将这些方法都实现。&lt;/p&gt;

&lt;h3 id=&#34;动画&#34;&gt;动画&lt;/h3&gt;

&lt;p&gt;用 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法来产生需要的动画
为了达到这个目标，需要实现以下的代码：
- 移动图像视图和它上面的覆盖视图
- 改变覆盖视图的 &lt;code&gt;alpha&lt;/code&gt; 值
- 移动并缩放 &lt;code&gt;title view&lt;/code&gt;
- 移动 FAB
- 显示/隐藏 FAB&lt;/p&gt;

&lt;h4 id=&#34;移动图像视图和它上面的覆盖视图&#34;&gt;移动图像视图和它上面的覆盖视图&lt;/h4&gt;

&lt;p&gt;参考上一节的内容，想要移动位于 ScrollView 外面的 ImageView 视图，需要使用参数 &lt;code&gt;-scrollY&lt;/code&gt; 并且将它除以 2 来产生视差效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  float flexibleRange = mFlexibleSpaceImageHeight - mActionBarSize;
  int minOverlayTransitionY = mActionBarSize - mOverlayView.getHeight();
  ViewHelper.setTranslationY(mOverlayView, ScrollUtils.getFloat(-scrollY, minOverlayTransitionY, 0));
  ViewHelper.setTranslationY(mImageView, ScrollUtils.getFloat(-scrollY / 2, minOverlayTransitionY, 0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使希望让覆盖图层随着图像一起移动，也不需要让覆盖图层跟着图像用一样的速度移动，所以可以把覆盖图像的移动设置为 &lt;code&gt;-scrollY&lt;/code&gt; 而非 &lt;code&gt;-scrollY/2&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;改变覆盖视图的-alpha-值&#34;&gt;改变覆盖视图的 &lt;code&gt;alpha&lt;/code&gt; 值&lt;/h4&gt;

&lt;p&gt;计算 &lt;code&gt;alpha&lt;/code&gt; 的值，只需要将 &lt;code&gt;scrollY&lt;/code&gt; 转换一下，让它在滚动的过程中 &lt;code&gt;alpha&lt;/code&gt; 值能从 0 变到 1。具体的操作是用 &lt;code&gt;scrollY&lt;/code&gt; 除以 &lt;code&gt;flexibleRange&lt;/code&gt;（这个值已经在上面初始化过了），同时用工具类的方法 &lt;code&gt;ScrollUtils.getFloat()&lt;/code&gt; 将它限定在 0 到 1 之间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ViewHelper.setAlpha(mOverlayView, ScrollUtils.getFloat((float) scrollY / flexibleRange, 0, 1));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动并缩放-title-view&#34;&gt;移动并缩放 &lt;code&gt;title view&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;跟上一节的做法基本上一样，不同的地方只是如何去计算缩放值以及 &lt;code&gt;translationY&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  // 省略了上面已经解释过的代码

  float scale = 1 + ScrollUtils.getFloat((flexibleRange - scrollY) / flexibleRange, 0, MAX_TEXT_SCALE_DELTA);
  ViewHelper.setPivotX(mTitleView, 0);
  ViewHelper.setPivotY(mTitleView, 0);
  ViewHelper.setScaleX(mTitleView, scale);
  ViewHelper.setScaleY(mTitleView, scale);

  int maxTitleTranslationY = (int) (mFlexibleSpaceImageHeight - mTitleView.getHeight() * scale);
  int titleTranslationY = maxTitleTranslationY - scrollY;
  ViewHelper.setTranslationY(mTitleView, titleTranslationY);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动fab&#34;&gt;移动FAB&lt;/h4&gt;

&lt;p&gt;基本思想是改变 FAB 的 &lt;code&gt;translationY&lt;/code&gt; 参数，然而在 &lt;code&gt;pre-Honeycomb&lt;/code&gt; 的设备上，当你用 &lt;code&gt;setOnClickListener（）&lt;/code&gt; 方法时可能不会起作用，为了解决这个问题，可以通过设置 FrameLayout 的 &lt;code&gt;margin&lt;/code&gt; 值，然后调用 &lt;code&gt;requestLayout（）&lt;/code&gt; 再次布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  // 省略了上面已经解释过的代码

  int maxFabTranslationY = mFlexibleSpaceImageHeight - mFab.getHeight() / 2;
  float fabTranslationY = ScrollUtils.getFloat(
      -scrollY + mFlexibleSpaceImageHeight - mFab.getHeight() / 2,
      mActionBarSize - mFab.getHeight() / 2,
      maxFabTranslationY);
  if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.HONEYCOMB) {
    FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mFab.getLayoutParams();
    lp.leftMargin = mOverlayView.getWidth() - mFabMargin - mFab.getWidth();
    lp.topMargin = (int) fabTranslationY;
    mFab.requestLayout();
  } else {
    ViewHelper.setTranslationX(mFab, mOverlayView.getWidth() - mFabMargin - mFab.getWidth());
    ViewHelper.setTranslationY(mFab, fabTranslationY);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算 &lt;code&gt;maxFabTranslationY&lt;/code&gt; 的表达式 &lt;code&gt;- mFab.getHeight() / 2&lt;/code&gt; 表明有一半高度的 FAB 会覆盖在图片的上方，有一个层叠的效果。&lt;/p&gt;

&lt;p&gt;也许你会认为 &lt;code&gt;fabTranslationY&lt;/code&gt; 值的计算表达式 &lt;code&gt;mActionBarSize - mFab.getHeight() / 2&lt;/code&gt; 的最小值可能没有意义，但是当你快速滚动视图的时候，这个最小值的计算是需要的，如果滚动速度快过了 FAB 缩放值变为 0 的速度，FAB 看起来就好像是突然消失了一样。&lt;/p&gt;

&lt;h4 id=&#34;显示-隐藏-fab&#34;&gt;显示/隐藏 FAB&lt;/h4&gt;

&lt;p&gt;显示或者隐藏 FAB 的效果比较简单，如果 FAB 的移动距离超过了某个阈值，就将它隐藏，否则，就显示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  // 省略了上面已经解释过的代码

  if (fabTranslationY &amp;lt; mFlexibleSpaceShowFabOffset) {
    hideFab();
  } else {
    showFab();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要自己将 &lt;code&gt;hideFab（）&lt;/code&gt; 和 &lt;code&gt;showFab（）&lt;/code&gt; 方法的代码完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean mFabIsShown;

  private void showFab() {
    if (!mFabIsShown) {
      ViewPropertyAnimator.animate(mFab).cancel();
      ViewPropertyAnimator.animate(mFab).scaleX(1).scaleY(1).setDuration(200).start();
      mFabIsShown = true;
    }
  }

  private void hideFab() {
    if (mFabIsShown) {
      ViewPropertyAnimator.animate(mFab).cancel();
      ViewPropertyAnimator.animate(mFab).scaleX(0).scaleY(0).setDuration(200).start();
      mFabIsShown = false;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义了一个状态变量来表明 FAB 目前是否显示。&lt;/p&gt;

&lt;p&gt;到这里就完成了整个图像弹性空白的布局。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;一个 view 的动画效果，也许刚开始看起来很复杂，但是，只要能搞清楚它的布局层次，将动画拆分成若干个子动画，并找到每个布局层次在坐标改变的时候对应的移动规律，就能够理解整个动画效果背后的玄机。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— 显示/隐藏 Toolbar</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/toolbar/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/toolbar/</guid>
      <description>&lt;p&gt;#Toolbar的显示/隐藏&lt;/p&gt;

&lt;p&gt;这一节描述了如何处理 ObservableScrollView 关于Toolbar 的显示/隐藏，并给出在各个 View 上是如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ToolbarControlBaseActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlGridViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlListViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlRecyclerViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlScrollViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlWebViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Toolbar 有关的文章如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/archives/6058&#34;&gt;Android:Toolbar使用心得&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tuicool.com/articles/7BJBZb&#34;&gt;android：Toolbar详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Toolbar 在 Android 5.0 中被引进，如果你需要在更低版本中使用这个控件的话，需要使用 v7 appcompat library 兼容包。&lt;/p&gt;

&lt;p&gt;#创建布局文件&lt;/p&gt;

&lt;p&gt;我们在布局中使用 ObservableListView 和 Toolbar，并将布局放入 FrameLayout 中，FrameLayout 和 RelativeLayout 这两个布局比较擅长用来转换它们内部的单独布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
android:layout_width=&amp;quot;match_parent&amp;quot;
android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

&amp;lt;android.support.v7.widget.Toolbar
android:id=&amp;quot;@+id/toolbar&amp;quot;
android:layout_width=&amp;quot;match_parent&amp;quot;
android:layout_height=&amp;quot;wrap_content&amp;quot;
android:background=&amp;quot;?attr/colorPrimary&amp;quot;
android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;
app:popupTheme=&amp;quot;@style/Theme.AppCompat.Light.DarkActionBar&amp;quot;
app:theme=&amp;quot;@style/Toolbar&amp;quot; /&amp;gt;

&amp;lt;com.github.ksoichiro.android.observablescrollview.ObservableListView
android:id=&amp;quot;@+id/scrollable&amp;quot;
android:layout_width=&amp;quot;match_parent&amp;quot;
android:layout_height=&amp;quot;match_parent&amp;quot;
android:layout_marginTop=&amp;quot;?attr/actionBarSize&amp;quot; /&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#如何显示/隐藏Toolbar&lt;/p&gt;

&lt;p&gt;参考上一节内容，我们可以考虑像显示/隐藏 ActionBar 那样来处理对 Toolbar 的显示/隐藏转换，然而，Toolbar 类却并没有 ActionBar 中的 show 方法和 hide 方法。因此，我们应该自己去完成类似的方法，从而做到 Toolbar 的显示/隐藏，初步设想如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
if (scrollState == ScrollState.UP) {
if (toolbarIsShown()) {   // 需要完成方法
hideToolbar(); // 需要完成方法
}
} else if (scrollState == ScrollState.DOWN) {
if (toolbarIsHidden()) { // 需要完成方法
showToolbar(); // 需要完成方法
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们开始完成方法前，应该确认一下，是否还要支持Honeycomb（API Level 11）之前的设备，因为我们可能需要使用一些合适的动画接口，这些接口可能不再支持上述设备。&lt;/p&gt;

&lt;p&gt;如果你需要兼容，可以用 NineOldAndroids 这个动画开源库，由于 View 的属性动画在 Android API 11 及其以后才支持，该库的作用就是让 API 11 以下的系统也能够正常的使用属性动画。&lt;/p&gt;

&lt;p&gt;在这个项目里面，我们使用的就是这个动画库，如果你不打算兼容 API 11 以下的设备，请将 ViewHelper.methodName(viewObject) 换成  viewObject.methodName()，否则可能无法正常运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NineOldAndroids: ViewHelper.getTranslationY(mToolbar)
Platform API:    mToolbar.getTranslationY()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你使用 NineOldAndroids 开源库，需要在 build.grade 中加入依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
compile &#39;com.nineoldandroids:library:2.4.0&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们来写我们需要实现的方法。为了避免冗余的显示隐藏转换，我们需要判断一下 Toolbar 现在的状态，是否出现或者隐藏。使用合适的动画接口（或者NineOldAndroids）我们只需要判断 translationY 的值就可以知道 Toolbar 此时的状态了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean toolbarIsShown() {
// Toolbar 在Y轴坐标为0，也就是正在显示
return ViewHelper.getTranslationY(mToolbar) == 0;
}

private boolean toolbarIsHidden() {
// Toolbar 在屏幕外，并且Y坐标的绝对值等于它的高度，也就是正在隐藏
return ViewHelper.getTranslationY(mToolbar) == -mToolbar.getHeight();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断完状态后，接下来就可以完善我们自己定义的 show 和 hide 方法代码了，先写好伪代码来简化问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void showToolbar() {
moveToolbar(0);
}

private void hideToolbar() {
moveToolbar(-mToolbar.getHeight());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们完成了 moveToolbar 方法，那么应该就可以就可以实现 Toolbar 的显示转换了。&lt;/p&gt;

&lt;p&gt;大部分的动画代码都跟属性值的计算相结合，如何正确的计算是一个非常关键的问题，虽然我们将方法命名为 moveToolbar，还需要注意一点，那就是在上一节中，不仅 ActionBar 移动了，view（Observable*View）的高度也改变了，我们需要把这一个功能也实现出来。&lt;/p&gt;

&lt;p&gt;为了使用改变的属性值，我们可以使用  ValueAnimator，它有一个回调方法叫  onAnimationUpdate，我们可以在这个方法里面得到动画的进度。ValueAnimator 自身不会有动画发生，我们需要使用一个变量来让动画实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ValueAnimator animator = ValueAnimator.ofFloat(0, 100).setDuration(200);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
@Override
public void onAnimationUpdate(ValueAnimator animation) {
float value = (float) animation.getAnimatedValue();
// 这里可以对 value 值做任何事情
}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，本地变量 value 在 200ms 内从 0f 变到 100f，在这种情况下，我们应该将 Toolbar 的 translationY 属性改变，并且将Observable*View高度也改变一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void moveToolbar(float toTranslationY) {
ValueAnimator animator = ValueAnimator.ofFloat(ViewHelper.getTranslationY(mToolbar), toTranslationY).setDuration(200);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
@Override
public void onAnimationUpdate(ValueAnimator animation) {
float translationY = (float) animation.getAnimatedValue();
ViewHelper.setTranslationY(mToolbar, translationY);
ViewHelper.setTranslationY((View) mScrollable, translationY);
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) ((View) mScrollable).getLayoutParams();
lp.height = (int) -translationY + getScreenHeight() - lp.topMargin;
((View) mScrollable).requestLayout();
}
});
animator.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;translationY从 ViewHelper.getTranslationY(mToolbar)( 等于current translationY) 变到了 toTranslationY，
为了显示隐藏 Toolbar 的，我们只需要调用ViewHelper.setTranslationY()。要改变最外层布局（FrameLayout）的高度，设置  FrameLayout.LayoutParams 参数，并通过调用requestLayout() 方法来更新。&lt;/p&gt;

&lt;p&gt;最好检查一下目前的 translationY 值，看是否已经等于 toTranslationY，如果是，就停止动画更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void moveToolbar(float toTranslationY) {
// 检查当前Y坐标
if (ViewHelper.getTranslationY(mToolbar) == toTranslationY) {
return;
}
// 省略……
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— 视差图像 Parallax image 实现</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/parallax/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/parallax/</guid>
      <description>

&lt;p&gt;这一节主要说明了如何在滚动视图中产生图像的视差效果，并给出在各个 View 上是如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ParallaxToolbarScrollViewActivity&lt;/li&gt;
&lt;li&gt;ParallaxToolbarListViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;h2 id=&#34;什么是视差滚动&#34;&gt;什么是视差滚动&lt;/h2&gt;

&lt;p&gt;视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。&lt;/p&gt;

&lt;p&gt;说的简单点就是界面元素在滚动屏幕时发生的位置的变化，然而各个不同的元素位置变化的速度不同，导致界面内的元素有层次错落的错觉，这和我们人体的眼球效果很像。&lt;/p&gt;

&lt;p&gt;视差滚动效果已经广泛运用到许多 app 中，起到了非常不错的效果。&lt;/p&gt;

&lt;h2 id=&#34;视差效果&#34;&gt;视差效果&lt;/h2&gt;

&lt;p&gt;本节中讨论的视差效果，指的是具有如下行为的布局：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;布局上有一张图像&lt;/li&gt;
&lt;li&gt;图像会随着 ScrollView 的滚动而滚动，然而速度减半&lt;/li&gt;
&lt;li&gt;ScrollView 自带&lt;code&gt;padding&lt;/code&gt;，形成观看图片的一个窗口。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了让图像产生视差效果，我们需要在布局上使用一点技巧。&lt;/p&gt;

&lt;p&gt;ObservableScrollView 和 ObservableListView 在处理填充的地方有一些区别，因此我们需要分开来看。&lt;/p&gt;

&lt;h1 id=&#34;scrollview&#34;&gt;ScrollView&lt;/h1&gt;

&lt;h2 id=&#34;布局&#34;&gt;布局&lt;/h2&gt;

&lt;h3 id=&#34;基本结构&#34;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;首先，如下是布局的基本结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ObservableScrollView&amp;gt;
    &amp;lt;RelativeLayout&amp;gt;
      &amp;lt;ImageView/&amp;gt;
      &amp;lt;View/&amp;gt;
      &amp;lt;TextView/&amp;gt;
    &amp;lt;/RelativeLayout&amp;gt;
  &amp;lt;/ObservableScrollView&amp;gt;
  &amp;lt;Toolbar/&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了阅读方便，这里有意地省略了属性（&lt;code&gt;android:XXX&lt;/code&gt;）和包名（&lt;code&gt;com.github.XXX&lt;/code&gt;）&lt;/p&gt;

&lt;h3 id=&#34;为什么要使用-framelayout&#34;&gt;为什么要使用 FrameLayout？&lt;/h3&gt;

&lt;p&gt;我们可以在示例 app 上看到，Toolbar 是覆盖在 ObservableScrollView 之上的，为了得到这样的效果，我们需要使用 FrameLayout 或者 RelativeLayout。&lt;/p&gt;

&lt;h3 id=&#34;observablescrollview里有什么&#34;&gt;ObservableScrollView里有什么？&lt;/h3&gt;

&lt;p&gt;ObservableScrollView 继承自 ScrollView，因此它最多只能有一个子类，然而我们需要多个子类来实现视差滚动效果，因此，需要将一个 ViewGroup 作为ObservableScrollView 的子类，再在这个 ViewGroup 里面放更多的子类布局（上面的布局中，这个子类 ViewGroup 就是 RelativeLayout ）。&lt;/p&gt;

&lt;p&gt;ImageView 是将要产生视差效果的 View，如果有需要也可以用其他的View代替。&lt;/p&gt;

&lt;p&gt;TextView 是屏幕的主要内容，它也可以用其他的 View 代替。&lt;/p&gt;

&lt;p&gt;ImagaeView 和 TextView 中间的 View 是一个锚点（&lt;code&gt;anchor&lt;/code&gt;），在后续内容中将解释为什么有这个锚点view 的存在。&lt;/p&gt;

&lt;p&gt;我们需要分开移动图像和内容，因此，它们的父类，也就是 ObservableScrollView 的子类，应该是一个&lt;code&gt;FrameLayout&lt;/code&gt; 或者&lt;code&gt;RelativeLayout&lt;/code&gt;，这一次我们使用 &lt;code&gt;RelativeLayout&lt;/code&gt; 来实现。&lt;/p&gt;

&lt;h3 id=&#34;父类移动时不要移动子类内容&#34;&gt;父类移动时不要移动子类内容&lt;/h3&gt;

&lt;p&gt;我们如何将 ScrollView 中的主要内容（这里是一个TextView）放在图像布局的下方？&lt;/p&gt;

&lt;p&gt;如果我们使用&lt;code&gt;android:layout_below&lt;/code&gt;属性来写的话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 这里省略了一些属性 --&amp;gt;
&amp;lt;RelativeLayout&amp;gt;
  &amp;lt;ImageView android:id=&amp;quot;@+id/image&amp;quot;&amp;gt;
  &amp;lt;TextView android:layout_below=&amp;quot;@id/image&amp;quot;&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的话，TextView 会跟 ImageView 保持相同的滚动速度，因为它的布局采用&lt;code&gt;android:layout_below=&amp;quot;@id/image”&lt;/code&gt; 来定义，因此我们需要使用另外的一个 &lt;code&gt;anchor view&lt;/code&gt;（锚点视图）来定义 TextView 的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 这里省略了一些属性 --&amp;gt;
&amp;lt;RelativeLayout&amp;gt;
  &amp;lt;ImageView android:id=&amp;quot;@+id/image&amp;quot;
             android:layout_height=&amp;quot;@dimen/parallax_image_height&amp;quot;&amp;gt;
  &amp;lt;View android:id=&amp;quot;@+id/anchor&amp;quot;
        android:layout_height=&amp;quot;@dimen/parallax_image_height&amp;quot;
        android:minHeight=&amp;quot;@dimen/parallax_image_height&amp;quot; /&amp;gt;
  &amp;lt;TextView android:layout_below=&amp;quot;@id/anchor&amp;quot;&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用了这个&lt;code&gt;anchor view&lt;/code&gt; 后，我们就可以单独移动ImageView了，&lt;code&gt;anchor view&lt;/code&gt; 和 TextView 会留在它们的位置上。&lt;/p&gt;

&lt;h3 id=&#34;明确设置-toolbar-内容的背景色&#34;&gt;明确设置 Toolbar 内容的背景色&lt;/h3&gt;

&lt;p&gt;我们需要为 Toolbar 上的内容明确地设置一个颜色，因为这个内容是在图片上方显示出来的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;TextView android:layout_below=&amp;quot;@id/anchor&amp;quot;
  android:background=&amp;quot;@android:color/white&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;完成整个布局&#34;&gt;完成整个布局&lt;/h3&gt;

&lt;p&gt;现在只需要设置布局的其他属性即可，例如&lt;code&gt;android:layout_width&lt;/code&gt;, &lt;code&gt;android:padding&lt;/code&gt;等等，可以在以下布局文件中查看详细的设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;res/layout/activity_parallaxtoolbarscrollview.java&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;动画效果&#34;&gt;动画效果&lt;/h2&gt;

&lt;h3 id=&#34;activity-的基本结构&#34;&gt;Activity 的基本结构&lt;/h3&gt;

&lt;p&gt;Activity 继承自v7兼容包，并且实现 &lt;code&gt;ObservableScrollViewCallbacks&lt;/code&gt; 接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ParallaxToolbarScrollViewActivity
  extends AppCompatActivity implements ObservableScrollViewCallbacks 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化-views&#34;&gt;初始化 views&lt;/h3&gt;

&lt;p&gt;然后像这样初始化 views：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private View mImageView;
private View mToolbarView;
private ObservableScrollView mScrollView;
private int mParallaxImageHeight;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_parallaxtoolbarscrollview);

  setSupportActionBar((Toolbar) findViewById(R.id.toolbar));

  mImageView = findViewById(R.id.image);
  mToolbarView = findViewById(R.id.toolbar);
  mToolbarView.setBackgroundColor(
    ScrollUtils.getColorWithAlpha(0, getResources().getColor(R.color.primary)));

  mScrollView = (ObservableScrollView) findViewById(R.id.scroll);
  mScrollView.setScrollViewCallbacks(this);

  mParallaxImageHeight = getResources().getDimensionPixelSize(
    R.dimen.parallax_image_height);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化时，Toolbar 应该是透明的，所以用&lt;code&gt;ScrollUtils&lt;/code&gt; 工具类来设置背景色的 &lt;code&gt;alpha&lt;/code&gt; 值为0，这一步是可选步骤，如果你不使用 Toolbar 的话可以忽略这个步骤。&lt;/p&gt;

&lt;h3 id=&#34;滚动时改变位置&#34;&gt;滚动时改变位置&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;ObservableScrollViewCallbacks&lt;/code&gt; 接口中的方法之一：&lt;code&gt;onScrollChanged()&lt;/code&gt; 来使图像产生动画，在这个方法里我们需要做以下事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;scrollY&lt;/code&gt; 参量改变 ImageView 在Y轴的位置&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;scrollY&lt;/code&gt; 参量改变 Toolbar 背景色的 &lt;code&gt;alpha&lt;/code&gt; 值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;改变-imageview-位置&#34;&gt;改变 ImageView 位置&lt;/h3&gt;

&lt;p&gt;只需要设置 &lt;code&gt;translateY&lt;/code&gt; 属性为一半的 &lt;code&gt;scrollY&lt;/code&gt; 即可，如果你想要改变视差效果的程度，调整不同的值（&lt;code&gt;scrollY/2&lt;/code&gt;）可即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  ViewHelper.setTranslationY(mImageView, scrollY / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;改变-toolbar-背景色的-alpha-值&#34;&gt;改变 Toolbar 背景色的 &lt;code&gt;alpha&lt;/code&gt; 值&lt;/h3&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  int baseColor = getResources().getColor(R.color.primary);
  float alpha = 0; // 待设置的alpha
  mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(alpha, baseColor));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变 &lt;code&gt;alpha&lt;/code&gt; 值有一点复杂，所以先暂时先写做 float alpha = 0。 接下来需要确认颜色的具体应用状况，完善&lt;code&gt;alpha&lt;/code&gt;的值： - 如果 ObservableScrollView 没有发生过滚动，Toolbar 是透明的。（当 &lt;code&gt;scrollY&lt;/code&gt; 等于0时, Toolbar 的&lt;code&gt;alpha&lt;/code&gt;值为0） - 如果 ObservableScrollView 发生了滚动， Toolbar 开始渐渐变得不透明，当滚动到一个特定的点，变得完全不透明。（当 scrollY 等于 mParallaxImageHeight 时, Toolbar 的 &lt;code&gt;alpha&lt;/code&gt; 值为1） 我们需要将上述情况描述成一个公式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alpha&lt;/code&gt; 值应该从0变到1，但是 &lt;code&gt;scrollY&lt;/code&gt; 值却从0变到上千，所以 &lt;code&gt;scrollY&lt;/code&gt; 应该被测量，我们用 &lt;code&gt;scrollY&lt;/code&gt; 除以 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 的值来设定 &lt;code&gt;alpha&lt;/code&gt; 值，因为当 &lt;code&gt;alpha&lt;/code&gt; 变成1时，&lt;code&gt;scrollY&lt;/code&gt; 应该跟 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 值相等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float alpha = (float) scrollY / mParallaxImageHeight;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;scrollY&lt;/code&gt; 和 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 均为int类型，需要转换为 float 类型。 但是，当 &lt;code&gt;scrollY&lt;/code&gt;值超过 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 后应该怎么办？&lt;/p&gt;

&lt;p&gt;我们可以&lt;code&gt;Math.min（）&lt;/code&gt;来限制 &lt;code&gt;alpha&lt;/code&gt;的值最大只能为1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float alpha = Math.min(1, (float) scrollY / mParallaxImageHeight);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就好了，onScrollChanged 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  int baseColor = getResources().getColor(R.color.primary);
  float alpha = Math.min(1, (float) scrollY / mParallaxImageHeight);
  mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(alpha, baseColor));
  ViewHelper.setTranslationY(mImageView, scrollY / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;恢复滚动状态&#34;&gt;恢复滚动状态&lt;/h3&gt;

&lt;p&gt;我们还需要考虑一个事情，当 Activity 恢复时，我们需要恢复滚动状态的设置， ObservableScrollView 自身会存储它的滚动位置，只需要在 &lt;code&gt;onRestoreInstanceState（）&lt;/code&gt;方法中更新 view 即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
  super.onRestoreInstanceState(savedInstanceState);
  onScrollChanged(mScrollView.getCurrentScrollY(), false, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;listview&#34;&gt;ListView&lt;/h1&gt;

&lt;h2 id=&#34;布局-1&#34;&gt;布局&lt;/h2&gt;

&lt;h3 id=&#34;基本结构-1&#34;&gt;基本结构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ImageView/&amp;gt;
  &amp;lt;View/&amp;gt;
  &amp;lt;ObservableListView/&amp;gt;
  &amp;lt;Toolbar/&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟 ScrollView 一样，我们用 FrameLayout 作为根布局，因为它可以分别移动该布局下的子 view。&lt;/p&gt;

&lt;p&gt;ImageView 是我们应该用来产生视差效果的视图。&lt;/p&gt;

&lt;p&gt;下一个视图跟 ScrollView 中的用法就不太一样了。&lt;/p&gt;

&lt;h3 id=&#34;为什么用不一样的布局&#34;&gt;为什么用不一样的布局？&lt;/h3&gt;

&lt;p&gt;跟 ScrollView 不同的是，ListView 不能拥有子视图，因此 ImageView 应该在 ListView 的外面，并且我们应该手动实现 ImageView 的移动。&lt;/p&gt;

&lt;h3 id=&#34;如何放置-imageview-和-listview&#34;&gt;如何放置 ImageView 和 ListView？&lt;/h3&gt;

&lt;p&gt;ImageView 要比 ListView 滚动得更慢，所以 ImageView 应该在 ListView 的下方，不然的话， ImageView 的底部就会盖住 ListView 的顶部。 同时，ListView 顶部应该有一个巨大的 padding 用来显示 ImageView。我们可以通过给 ListView 添加一个透明的 header view 来达到这个目的。&lt;/p&gt;

&lt;h3 id=&#34;为什么需要这个透明的-view&#34;&gt;为什么需要这个透明的 view&lt;/h3&gt;

&lt;p&gt;就像我在上面说过的，ListView 应该有一个透明的header，因此背景色应该也是透明的，但是如果我们仅仅把背景设置成透明，这样做不仅 header 透明了，ListView 中的 item 也会变成透明的。为了避免这种情况，我们可以在 ListView下 面设置一个假的背景 view 。&lt;/p&gt;

&lt;h2 id=&#34;动画&#34;&gt;动画&lt;/h2&gt;

&lt;h3 id=&#34;activity的基本结构&#34;&gt;Activity的基本结构&lt;/h3&gt;

&lt;p&gt;跟 ParallaxToolbarScrollViewActivity 一样的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ParallaxToolbarListViewActivity
  extends BaseActivity implements ObservableScrollViewCallbacks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化视图&#34;&gt;初始化视图&lt;/h3&gt;

&lt;p&gt;跟 ScrollView 一样，初始化 ObservableListView, ImageView, Toolbar等，需要注意的是 ListView 应该有一个 header view：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private View mImageView;
private View mToolbarView;
private View mListBackgroundView;
private ObservableListView mListView;
private int mParallaxImageHeight;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_parallaxtoolbarlistview) ;

  setSupportActionBar((Toolbar) findViewById(R.id.toolbar));

  mImageView = findViewById(R.id.image);
  mToolbarView = findViewById(R.id.toolbar);
  mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(0, getResources().getColor(R.color.primary)));

  mParallaxImageHeight = getResources().getDimensionPixelSize(R.dimen.parallax_image_height);

  mListView = (ObservableListView) findViewById(R.id.list);
  mListView.setScrollViewCallbacks(this);
  // Set padding view for ListView. This is the flexible space.
  View paddingView = new View(this);
  AbsListView.LayoutParams lp = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,
          mParallaxImageHeight);
  paddingView.setLayoutParams(lp);
  paddingView.setClickable(true);

  mListView.addHeaderView(paddingView);
  setDummyData(mListView);
  mListBackgroundView = findViewById(R.id.list_background);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，为了取消 header 的点击选择效果，以下代码非常重要：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paddingView.setClickable(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setDummyData（）&lt;/code&gt;用来设置内容。&lt;/p&gt;

&lt;h2 id=&#34;滚动时改变位置-1&#34;&gt;滚动时改变位置&lt;/h2&gt;

&lt;p&gt;我们用 &lt;code&gt;onScrollChanged&lt;/code&gt;方法来改变视图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们应该设置 &lt;code&gt;translateY&lt;/code&gt; 的属性为 &lt;code&gt;scrollY&lt;/code&gt;值的一半，但是并不像 ScrollView一样直接把这个值赋给 &lt;code&gt;translateY&lt;/code&gt;，当 &lt;code&gt;scrollY&lt;/code&gt; 的值变大的时候， ImageView 的 &lt;code&gt;translateY&lt;/code&gt;应该变小，因为ImageView 不是 ListView 的子类，所以我们应该用 &lt;code&gt;-scrollY/2&lt;/code&gt; 作为 &lt;code&gt;translateY&lt;/code&gt; 的值。（你可以改变”/2”的值来得到不一样的视差效果）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setTranslationY(mImageView, -scrollY / 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;改变背景视图&#34;&gt;改变背景视图&lt;/h3&gt;

&lt;p&gt;背景应该跟随着 ListView 一起移动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setTranslationY(mListBackgroundView, mParallaxImageHeight - scrollY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;code&gt;scrollY&lt;/code&gt; 超过 &lt;code&gt;mParallaxImageHeight&lt;/code&gt;后值变为负，这是不允许的。&lt;/p&gt;

&lt;p&gt;我们可以用&lt;code&gt;Math.max（）&lt;/code&gt;来避免这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setTranslationY(mListBackgroundView, Math.max(0, -scrollY + mParallaxImageHeight));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他的代码都跟 ObservableScrollView 中一样，就不赘述了。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;不同的 view 实现视差效果的方法也许是有所区别的，需要我们认真的去分析，才能实现出我们想要实现的效果。&lt;/p&gt;

&lt;p&gt;[2]: &lt;a href=&#34;http://blog.qiji.tech/archives/9310&#34;&gt;http://blog.qiji.tech/archives/9310&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>