<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <title>Thirdlibs - ChiakiMayuzumi</title>
    <meta name="generator" content="Hugo 0.15" />

    
    <meta name="description" content="A material design theme for documentations.">
    
    <link rel="canonical" href="http://chiakimayuzumi.github.io/thirdlib/">
    
    <meta name="author" content="ChiakiMayuzumi">
    

    <meta property="og:url" content="http://chiakimayuzumi.github.io/thirdlib/">
    <meta property="og:title" content="ChiakiMayuzumi">
    <meta property="og:image" content="http://chiakimayuzumi.github.io/images/cm.png">
    <meta name="apple-mobile-web-app-title" content="ChiakiMayuzumi">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://chiakimayuzumi.github.io/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="http://chiakimayuzumi.github.io/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('http://chiakimayuzumi.github.io/fonts/icon.eot?52m981');
        src: url('http://chiakimayuzumi.github.io/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('http://chiakimayuzumi.github.io/fonts/icon.woff?52m981')
               format('woff'),
             url('http://chiakimayuzumi.github.io/fonts/icon.ttf?52m981')
               format('truetype'),
             url('http://chiakimayuzumi.github.io/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/application.css">
    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://chiakimayuzumi.github.io/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu%2bMono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://chiakimayuzumi.github.io/javascripts/modernizr.js"></script>

    
    <link href="http://chiakimayuzumi.github.io/thirdlib/index.xml" rel="alternate" type="application/rss+xml" title="ChiakiMayuzumi" />
    <link href="http://chiakimayuzumi.github.io/thirdlib/index.xml" rel="feed" type="application/rss+xml" title="ChiakiMayuzumi" />
    

  </head>
  <body class="palette-primary-light red palette-accent-light green">


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        Thirdlib
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/ChiakiMayuzumi" title="@ChiakiMayuzumi on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://chiakimayuzumi.github.io/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://chiakimayuzumi.github.io/images/cm.png">
        </div>
      
      <div class="name">
        <strong>ChiakiMayuzumi </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="博客目录" href="http://chiakimayuzumi.github.io/">
	
	博客目录
</a>


  
</li>



<li>
  
    



<a  title="联系方式" href="http://chiakimayuzumi.github.io/sketch/">
	
	联系方式
</a>


  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/ChiakiMayuzumi" target="_blank" title="@ChiakiMayuzumi on GitHub">
              @ChiakiMayuzumi on GitHub
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>Pages in Thirdlib</h1>

			
			<a href="http://chiakimayuzumi.github.io/thirdlib/recyclerview/" title="ObservableScrollView分析 —— ObservableRecyclerView 源码分析">
				<h2>ObservableScrollView分析 —— ObservableRecyclerView 源码分析</h2>
			</a>

			<br>
			概述 前面的章节，我们主要介绍了如何利用开源库 ObservableScrollView 来实现出各种我们需要的滚动效果的实例和实现代码，却一直没有分析过在实现过程中所使用的一系列 ObservablexxxView 的源代码，今天我们就来看看，在开源库中 ObservableRecyclerView 的源码。 ObservableRecyclerView 关系图如下： 由图可知：ObservableRecyclerView 继承自 RecyclerView 并实现 Scrollable 接口，与此同时，ObservableRecyclerView 还持有四个类的引用，这四个类分别是：ObservableScrollViewCallbacks、ScrollState、ViewGroup 和 MotionEvent，其中： ObservableScrollViewCallbacks 是开源库所定义的一个回调接口； ScrollState 是一个枚举类，表示了滑动的三个状态：STOP、UP 和 DOWN； ViewGroup 用于在 Touch 事件拦截的过程中，指定父类 View； 当用户触摸屏幕时则会产生一个 MotionEvent 对象，在 重写 onTouchEvent() 方法和 onInterceptTouchEvent() 方法时，都需要传入 MotionEvent 参数。 Scrollable 接口方法 首先来看 Scrollable 接口，该接口是开源库所定义的一个接口，给所有接下来需要实现可观测，可滚动的控件（RecyclerView、ScrollView、ListView、WebView 和 GridView）提供了一个通用的应用程序接口，实现该接口必须实现以下几个方法： setScrollViewCallbacks(ObservableScrollViewCallbacks listener)：设置一个回调监听 addScrollViewCallbacks(ObservableScrollViewCallbacks listener)：增加一个回调监听 removeScrollViewCallbacks(ObservableScrollViewCallbacks listener)：删除一个回调监听 clearScrollViewCallbacks()：清除所有回调监听 scrollVerticallyTo(int y)：垂直滚动到坐标 y 处（y 为绝对坐标） getCurrentScrollY()：返回当前 y 坐标 setTouchInterceptionViewGroup(ViewGroup viewGroup)：设置一个触摸事件拦截的 ViewGroup ，用来将拦截事件传递到该 View 的父类 View 中去，这也是为什么

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/thirdlib/scrollview/" title="ObservableScrollView分析 —— ObservableScrollView 源码分析">
				<h2>ObservableScrollView分析 —— ObservableScrollView 源码分析</h2>
			</a>

			<br>
			概述 前面的章节，我们主要介绍了如何利用开源库 ObservableScrollView 来实现出各种我们需要的滚动效果的实例和实现代码，却一直没有分析过在实现过程中所使用的一系列 ObservablexxxView 的源代码，今天我们就来看看，在开源库中 ObservableScrollView 的源码。 ObservableScrollView 关系图如下： 由图可知：ObservableScrollView 继承自 ScrollView 并实现 Scrollable 接口，与此同时，ObservableScrollView 还持有四个类的引用，这四个类分别是：ObservableScrollViewCallbacks、ScrollState、ViewGroup 和 MotionEvent，其中： ObservableScrollViewCallbacks 是开源库所定义的一个回调接口； ScrollState 是一个枚举类，表示了滑动的三个状态：STOP、UP 和 DOWN； ViewGroup 用于在 Touch 事件拦截的过程中，指定父类 View； 当用户触摸屏幕时则会产生一个 MotionEvent 对象，在 重写 onTouchEvent() 方法和 onInterceptTouchEvent() 方法时，都需要传入 MotionEvent 参数。 Scrollable 该接口的方法已经在上一节中详细描述了，接下来我们直接看在 ObservableScrollView 中是如何实现该接口的。 具体实现 @Override public void setScrollViewCallbacks(ObservableScrollViewCallbacks listener) { mCallbacks = listener; } @Override public void addScrollViewCallbacks(ObservableScrollViewCallbacks listener) { if (mCallbackCollection == null) { mCallbackCollection = new ArrayList&lt;&gt;(); } mCallbackCollection.add(listener); } @Override public void removeScrollViewCallbacks(ObservableScrollViewCallbacks listener) { if (mCallbackCollection != null) { mCallbackCollection.remove(listener); } } @Override public void clearScrollViewCallbacks() { if (mCallbackCollection != null) { mCallbackCollection.clear(); } } @Override public void setTouchInterceptionViewGroup(ViewGroup viewGroup) { mTouchInterceptionViewGroup = viewGroup; } @Override public void scrollVerticallyTo(int y) { scrollTo(0, y); } @Override public int getCurrentScrollY() { return mScrollY; } 与上一节中 ObservableRecyclerView 的实现方法不同的是 scrollVerticallyTo() 方法，该方法更为简洁，因为它可以直接调用继承自 ScrollView 的方法 scrollTo()。 ObservableScrollViewCallbacks 该接口的方法已经在上一节中详细描述了，接下来我们直接看在 ObservableScrollView 中是如何实现该接口的。 具体实现 @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) { super.onScrollChanged(l, t, oldl, oldt); if (hasNoCallbacks()) { return; } if (getChildCount() &gt; 0) { int firstVisiblePosition = getChildAdapterPosition(getChildAt(0)); int lastVisiblePosition = getChildAdapterPosition(getChildAt(getChildCount() - 1)); for (int i = firstVisiblePosition, j = 0; i &lt;= lastVisiblePosition; i++, j++) { int childHeight = 0; View child = getChildAt(j); if (child != null) { if (mChildrenHeights.indexOfKey(i) &lt; 0 || (child.getHeight() != mChildrenHeights.get(i))) { childHeight = child.getHeight(); } } mChildrenHeights.put(i, childHeight); } View firstVisibleChild = getChildAt(0); if (firstVisibleChild != null) { if (mPrevFirstVisiblePosition &lt; firstVisiblePosition) { // scroll down int skippedChildrenHeight = 0; if (firstVisiblePosition - mPrevFirstVisiblePosition != 1) { for (int i = firstVisiblePosition - 1; i &gt; mPrevFirstVisiblePosition; i&ndash;) { if (0 &lt; mChildrenHeights.indexOfKey(i)) { skippedChildrenHeight += mChildrenHeights.get(i); } else { // Approximate each item&rsquo;s height to the first visible child.

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/thirdlib/header/" title="ObservableScrollView分析 —— Sticky header 顶部固定">
				<h2>ObservableScrollView分析 —— Sticky header 顶部固定</h2>
			</a>

			<br>
			这一节主要说明了如何实现在滚动视图中将顶部固定在屏幕最上方的效果，并给出在各个 View 上如何应用的实例，主要实例有： StickyHeaderListViewActivity StickyHeaderRecyclerViewActivity StickyHeaderScrollViewActivity StickyHeaderWebViewActivity 概述 顶部固定效果是 显示/隐藏 Toolbar 效果的更加复杂的版本，将一半的 header view 保留在屏幕的顶部。这一次我们用 ScrollView 来示范，方法套用到其他的 view 上也并不困难。 使用 ScrollView ScrollView 的布局 先看布局，以下是 ScrollView 的顶部固定样式的基本结构，比之前的 显示/隐藏 Toolbar 布局要复杂许多。 &lt;FrameLayout&gt; &lt;ObservableScrollView android:id=&quot;@+id/scroll&quot;&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot;&gt; &lt;View android:minHeight=&quot;?attr/actionBarSize&quot;/&gt; &lt;View android:minHeight=&quot;?attr/actionBarSize&quot;/&gt; &lt;TextView/&gt; &lt;/LinearLayout&gt; &lt;/ObservableScrollView&gt; &lt;LinearLayout android:id=&quot;@+id/header&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Toolbar android:id=&quot;@+id/toolbar&quot; android:minHeight=&quot;?attr/actionBarSize&quot;/&gt; &lt;TextView android:id=&quot;@+id/sticky&quot; android:layout_height=&quot;?attr/actionBarSize&quot;/&gt; &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; 在 显示/隐藏 Toolbar 样式中，我们只使用了 ObservableScrollView 和 Toolbar，这一次我们让每一个视图都变得更加复杂了。 为 ScrollView 创造顶部空间 初始化时，ScrooView 需要一个两倍体积于 ActionBar的空间，其中一半会在滑动的过程中固定住，因此简单的在 TextView 布局上使用高度 ?attr/actionBarSize 添加两个 view

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/thirdlib/toolbarblank/" title="ObservableScrollView分析 —— Toolbar上的弹性空白">
				<h2>ObservableScrollView分析 —— Toolbar上的弹性空白</h2>
			</a>

			<br>
			这一节主要说明了如何在 Toolbar 上方实现弹性空白布局，并给出在各个 View 上如何应用的实例，主要实例有： FlexibleSpaceToolbarScrollViewActivity FlexibleSpaceToolbarWebViewActivity ScrollView 实现弹性空白 ScrollView 布局 基本结构 &lt;FrameLayout&gt; &lt;ObservableScrollView android:id=&quot;@+id/scroll&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/body&quot;&gt; &lt;TextView/&gt; &lt;/FrameLayout&gt; &lt;/ObservableScrollView&gt; &lt;View android:id=&quot;@+id/flexible_space&quot;/&gt; &lt;Toolbar android:id=&quot;@+id/toolbar&quot;/&gt; &lt;RelativeLayout android:paddingLeft=&quot;@dimen/toolbar_margin_start&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot;/&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot;&gt; &lt;View android:layout_height=&quot;?attr/actionBarSize&quot;/&gt; &lt;View android:layout_height=&quot;@dimen/flexible_space_height&quot;/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;/FrameLayout&gt; 看过之前章节的话一定知道，根布局 FrameLayout 可以实现分别移动其子布局的功能。 第二个位于 ScrollView 中的 FrameLayout 布局 （@id/body）是主要的内容布局，如果需要的话，可以换成任何你想要的布局。这里我们就用一个 TextView 来充当当前布局的内容。 View（@id/flexible_space）构成了一个背景不透明的弹性空白空间，在滚动时，该视图会随着Y轴坐标的改变而垂直滚动。 Toolbar 只是一个普通的 Toolbar ，不过这个 Toolbar 没有设置标题。 接下来的 RelativeLayout 和它的子布局比较复杂，首先，TextView（@id/title） 才是真正的 title view ，其他的布局（LinearLayout，view）都只是填充，因为在这个弹性空白的样式里，TextView 里面内容的字体大小（也就是标题的字体大小）会有所变化，所以它需要额外的空间。要达到这样的动画效果，可以使得 TextView 动画起来，因此其他的填充都应该在 TextView 的外面。 想要了解其他的属性，可以自己在 app 里面查看相应的布局。

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/thirdlib/pictureblank/" title="ObservableScrollView分析 —— 使用图像的弹性空白布局">
				<h2>ObservableScrollView分析 —— 使用图像的弹性空白布局</h2>
			</a>

			<br>
			这一节主要说明了使用图像来实现弹性空白布局，并给出在各个 View 上如何应用的实例，主要实例有： FlexibleSpaceWithImageListViewActivity FlexibleSpaceWithImageRecyclerViewActivity FlexibleSpaceWithImageScrollViewActivity 想要更好的读懂本节文章，请先阅读：[Android] ObservableScrollView分析（六）—— Toolbar上的弹性空白 ScrollView 实现弹性空白 ScrollView 布局 基本结构 &lt;FrameLayout&gt; &lt;ImageView android:id=&quot;@+id/image&quot;/&gt; &lt;View android:id=&quot;@+id/overlay&quot;/&gt; &lt;ObservableScrollView android:id=&quot;@+id/scroll&quot;&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot;&gt; &lt;View/&gt; &lt;TextView/&gt; &lt;/LinearLayout&gt; &lt;/ObservableScrollView&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot;/&gt; &lt;View/&gt; &lt;/LinearLayout&gt; &lt;FloatingActionButton android:id=&quot;@+id/fab&quot;/&gt; &lt;/FrameLayout&gt; 根布局 FrameLayout 可以实现分别移动其子布局的功能。 ImageView (@id/image) 布局里放的是在移动时会产生视差效果的图片。 View (@id/overlay) 如同它的id名一样，是用来覆盖 ImageView 的一个视图。打开 demo app 中的这个Activity （FlexibleSpaceWithImageScrollViewActivity），滑动一下，你会发现图片会产生一种淡入淡出的效果，产生这个效果的原因就是覆盖在 ImageView 上面的 View 会随着滑动位置的改变而改变其不透明度。 LinearLayout 及其子布局，是整个布局中真正的标题布局。这样的布局在上一节中也出现了，所以不再赘述。 FloatingActionButton 是从 FloatingActionButton 库中导入的一个简单又炫酷的小控件。 这个控件是可选项，如果你不需要它，可以将它移除。demo app 中放入这个控件是因为它是一个非常典型的遵循 Material Design 风格的控件，也许你们会喜欢。 想要了解其他的属性，可以自己在 demo app 里面查看相应的布局。 res/layout/activity_flexiblespacewithimagescrollview.xml 初始化 省略掉那些简单的，或者跟本节无关的代码后，只放上相关的初始化代码： 将 title 的值赋给真正的 title view（TextView），然后给原来的 title 赋值为 null： mTitleView.setText(getTitle()); setTitle(null); 得到资源文件中的尺寸信息，并将它们赋给相应的属性值（这样可以简化动画部分的代码）。 mFlexibleSpaceImageHeight = getResources().getDimensionPixelSize(R.dimen.flexible_space_image_height); mFlexibleSpaceShowFabOffset = getResources().getDimensionPixelSize(R.dimen.flexible_space_show_fab_offset); mFabMargin = getResources().getDimensionPixelSize(R.dimen.margin_standard); mActionBarSize = getActionBarSize(); 得到布局视图，并将它们赋给相应的属性值（这样可以简化动画部分的代码）。 mImageView = findViewById(R.id.image); mOverlayView = findViewById(R.id.overlay); mScrollView = (ObservableScrollView) findViewById(R.id.scroll); mScrollView.setScrollViewCallbacks(this); mTitleView = (TextView) findViewById(R.id.title); mFab = findViewById(R.id.fab); 尽管跟滚动动画的实现可能没什么关系，还是需要在 onCreate（） 方法中将 floating action button (FAB) 的缩放值设置为 0，因为我们想要在一开始的时候将它隐藏，随着滚动慢慢增加缩放值从而让它显示出来。 ViewHelper.setScaleX(mFab, 0); ViewHelper.setScaleY(mFab, 0); 有必要给这个 Activity 添加上接口 implements ObservableScrollViewCallbacks 并将这些方法都实现。 动画 用 onScrollChanged() 方法来产生需要的动画 为了达到这个目标，需要实现以下的代码： - 移动图像视图和它上面的覆盖视图 - 改变覆盖视图的 alpha 值 - 移动并缩放 title view - 移动 FAB - 显示/隐藏 FAB 移动图像视图和它上面的覆盖视图 参考上一节的内容，想要移动位于 ScrollView 外面的 ImageView 视图，需要使用参数 -scrollY 并且将它除以 2 来产生视差效果。 @Override public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) { float flexibleRange = mFlexibleSpaceImageHeight - mActionBarSize; int minOverlayTransitionY = mActionBarSize - mOverlayView.getHeight(); ViewHelper.setTranslationY(mOverlayView, ScrollUtils.getFloat(-scrollY, minOverlayTransitionY, 0)); ViewHelper.setTranslationY(mImageView, ScrollUtils.getFloat(-scrollY / 2, minOverlayTransitionY, 0)); 即使希望让覆盖图层随着图像一起移动，也不需要让覆盖图层跟着图像用一样的速度移动，所以可以把覆盖图像的移动设置为 -scrollY 而非 -scrollY/2.

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/thirdlib/toolbar/" title="ObservableScrollView分析 —— 显示/隐藏 Toolbar">
				<h2>ObservableScrollView分析 —— 显示/隐藏 Toolbar</h2>
			</a>

			<br>
			#Toolbar的显示/隐藏 这一节描述了如何处理 ObservableScrollView 关于Toolbar 的显示/隐藏，并给出在各个 View 上是如何应用的实例，主要实例有： ToolbarControlBaseActivity ToolbarControlGridViewActivity ToolbarControlListViewActivity ToolbarControlRecyclerViewActivity ToolbarControlScrollViewActivity ToolbarControlWebViewActivity Toolbar 有关的文章如下： Android:Toolbar使用心得 android：Toolbar详解 Toolbar 在 Android 5.0 中被引进，如果你需要在更低版本中使用这个控件的话，需要使用 v7 appcompat library 兼容包。 #创建布局文件 我们在布局中使用 ObservableListView 和 Toolbar，并将布局放入 FrameLayout 中，FrameLayout 和 RelativeLayout 这两个布局比较擅长用来转换它们内部的单独布局。 &lt;FrameLayout xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&quot;">http://schemas.android.com/apk/res/android&quot;</a> xmlns:app=&quot;<a href="http://schemas.android.com/apk/res-auto&quot;">http://schemas.android.com/apk/res-auto&quot;</a> android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot; app:theme=&quot;@style/Toolbar&quot; /&gt; &lt;com.github.ksoichiro.android.observablescrollview.ObservableListView android:id=&quot;@+id/scrollable&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginTop=&quot;?attr/actionBarSize&quot; /&gt; &lt;/FrameLayout&gt; #如何显示/隐藏Toolbar 参考上一节内容，我们可以考虑像显示/隐藏 ActionBar 那样来处理对 Toolbar 的显示/隐藏转换，然而，Toolbar 类却并没有 ActionBar 中的 show 方法和 hide 方法。因此，我们应该自己去完成类似的方法，从而做到

			<hr>
			
			<a href="http://chiakimayuzumi.github.io/thirdlib/parallax/" title="ObservableScrollView分析 —— 视差图像 Parallax image 实现">
				<h2>ObservableScrollView分析 —— 视差图像 Parallax image 实现</h2>
			</a>

			<br>
			这一节主要说明了如何在滚动视图中产生图像的视差效果，并给出在各个 View 上是如何应用的实例，主要实例有： ParallaxToolbarScrollViewActivity ParallaxToolbarListViewActivity 概述 什么是视差滚动 视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。 说的简单点就是界面元素在滚动屏幕时发生的位置的变化，然而各个不同的元素位置变化的速度不同，导致界面内的元素有层次错落的错觉，这和我们人体的眼球效果很像。 视差滚动效果已经广泛运用到许多 app 中，起到了非常不错的效果。 视差效果 本节中讨论的视差效果，指的是具有如下行为的布局： 布局上有一张图像 图像会随着 ScrollView 的滚动而滚动，然而速度减半 ScrollView 自带padding，形成观看图片的一个窗口。 为了让图像产生视差效果，我们需要在布局上使用一点技巧。 ObservableScrollView 和 ObservableListView 在处理填充的地方有一些区别，因此我们需要分开来看。 ScrollView 布局 基本结构 首先，如下是布局的基本结构： &lt;FrameLayout&gt; &lt;ObservableScrollView&gt; &lt;RelativeLayout&gt; &lt;ImageView/&gt; &lt;View/&gt; &lt;TextView/&gt; &lt;/RelativeLayout&gt; &lt;/ObservableScrollView&gt; &lt;Toolbar/&gt; &lt;/FrameLayout&gt; 为了阅读方便，这里有意地省略了属性（android:XXX）和包名（com.github.XXX） 为什么要使用 FrameLayout？ 我们可以在示例 app 上看到，Toolbar 是覆盖在 ObservableScrollView 之上的，为了得到这样的效果，我们需要使用 FrameLayout 或者 RelativeLayout。 ObservableScrollView里有什么？ ObservableScrollView 继承自 ScrollView，因此它最多只能有一个子类，然而我们需要多个子类来实现视差滚动效果，因此，需要将一个 ViewGroup 作为ObservableScrollView 的子类，再在这个 ViewGroup 里面放更多的子类布局（上面的布局中，这个子类 ViewGroup 就是 RelativeLayout ）。 ImageView 是将要产生视差效果的 View，如果有需要也可以用其他的View代替。 TextView 是屏幕的主要内容，它也可以用其他的 View 代替。 ImagaeView 和 TextView 中间的 View 是一个锚点（anchor），在后续内容中将解释为什么有这个锚点view 的存在。 我们需要分开移动图像和内容，因此，它们的父类，也就是 ObservableScrollView 的子类，应该是一个FrameLayout 或者RelativeLayout，这一次我们使用 RelativeLayout 来实现。 父类移动时不要移动子类内容 我们如何将 ScrollView 中的主要内容（这里是一个TextView）放在图像布局的下方？ 如果我们使用android:layout_below属性来写的话： &lt;!&ndash; 这里省略了一些属性 &ndash;&gt; &lt;RelativeLayout&gt; &lt;ImageView android:id=&quot;@+id/image&quot;&gt; &lt;TextView android:layout_below=&quot;@id/image&quot;&gt; &lt;/RelativeLayout&gt; 这样写的话，TextView 会跟 ImageView 保持相同的滚动速度，因为它的布局采用android:layout_below=&quot;@id/image” 来定义，因此我们需要使用另外的一个 anchor view（锚点视图）来定义 TextView 的位置。 &lt;!&ndash; 这里省略了一些属性 &ndash;&gt; &lt;RelativeLayout&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_height=&quot;@dimen/parallax_image_height&quot;&gt; &lt;View android:id=&quot;@+id/anchor&quot; android:layout_height=&quot;@dimen/parallax_image_height&quot; android:minHeight=&quot;@dimen/parallax_image_height&quot; /&gt; &lt;TextView android:layout_below=&quot;@id/anchor&quot;&gt; &lt;/RelativeLayout&gt; 使用了这个anchor view 后，我们就可以单独移动ImageView了，anchor view 和 TextView 会留在它们的位置上。 明确设置 Toolbar 内容的背景色 我们需要为 Toolbar 上的内容明确地设置一个颜色，因为这个内容是在图片上方显示出来的。 &lt;TextView android:layout_below=&quot;@id/anchor&quot; android:background=&quot;@android:color/white&quot; /&gt; 完成整个布局 现在只需要设置布局的其他属性即可，例如android:layout_width, android:padding等等，可以在以下布局文件中查看详细的设置： res/layout/activity_parallaxtoolbarscrollview.java 动画效果 Activity 的基本结构 Activity 继承自v7兼容包，并且实现 ObservableScrollViewCallbacks 接口。 public class ParallaxToolbarScrollViewActivity extends AppCompatActivity implements ObservableScrollViewCallbacks 初始化 views 然后像这样初始化 views： private View mImageView; private View mToolbarView; private ObservableScrollView mScrollView; private int mParallaxImageHeight; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_parallaxtoolbarscrollview); setSupportActionBar((Toolbar) findViewById(R.id.toolbar)); mImageView = findViewById(R.id.image); mToolbarView = findViewById(R.id.toolbar); mToolbarView.setBackgroundColor( ScrollUtils.getColorWithAlpha(0, getResources().getColor(R.color.primary))); mScrollView = (ObservableScrollView) findViewById(R.id.scroll); mScrollView.setScrollViewCallbacks(this); mParallaxImageHeight = getResources().getDimensionPixelSize( R.dimen.parallax_image_height); } 初始化时，Toolbar 应该是透明的，所以用ScrollUtils 工具类来设置背景色的 alpha 值为0，这一步是可选步骤，如果你不使用 Toolbar 的话可以忽略这个步骤。 滚动时改变位置 使用 ObservableScrollViewCallbacks 接口中的方法之一：onScrollChanged() 来使图像产生动画，在这个方法里我们需要做以下事情： 用 scrollY 参量改变 ImageView 在Y轴的位置 用 scrollY 参量改变 Toolbar 背景色的 alpha 值 改变 ImageView 位置 只需要设置 translateY 属性为一半的 scrollY 即可，如果你想要改变视差效果的程度，调整不同的值（scrollY/2）可即可。 @Override public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) { ViewHelper.setTranslationY(mImageView, scrollY / 2); } 改变 Toolbar 背景色的 alpha 值 代码如下： @Override public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) { int baseColor = getResources().getColor(R.color.primary); float alpha = 0; // 待设置的alpha mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(alpha, baseColor)); 改变 alpha 值有一点复杂，所以先暂时先写做 float alpha = 0。 接下来需要确认颜色的具体应用状况，完善alpha的值： - 如果 ObservableScrollView 没有发生过滚动，Toolbar 是透明的。（当 scrollY 等于0时, Toolbar 的alpha值为0） - 如果 ObservableScrollView 发生了滚动， Toolbar 开始渐渐变得不透明，当滚动到一个特定的点，变得完全不透明。（当 scrollY 等于 mParallaxImageHeight 时, Toolbar 的 alpha 值为1） 我们需要将上述情况描述成一个公式。 alpha 值应该从0变到1，但是 scrollY 值却从0变到上千，所以 scrollY 应该被测量，我们用 scrollY 除以 mParallaxImageHeight 的值来设定 alpha 值，因为当 alpha 变成1时，scrollY 应该跟 mParallaxImageHeight 值相等。 float alpha = (float) scrollY / mParallaxImageHeight; 需要注意的是，scrollY 和 mParallaxImageHeight 均为int类型，需要转换为 float 类型。 但是，当 scrollY值超过 mParallaxImageHeight 后应该怎么办？ 我们可以Math.min（）来限制 alpha的值最大只能为1。 float alpha = Math.min(1, (float) scrollY / mParallaxImageHeight); 这样就好了，onScrollChanged 如下： @Override public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) { int baseColor = getResources().getColor(R.color.primary); float alpha = Math.min(1, (float) scrollY / mParallaxImageHeight); mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(alpha, baseColor)); ViewHelper.setTranslationY(mImageView, scrollY / 2); } 恢复滚动状态 我们还需要考虑一个事情，当 Activity 恢复时，我们需要恢复滚动状态的设置， ObservableScrollView 自身会存储它的滚动位置，只需要在 onRestoreInstanceState（）方法中更新 view 即可。 @Override protected void onRestoreInstanceState(Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); onScrollChanged(mScrollView.getCurrentScrollY(), false, false); } ListView 布局 基本结构 &lt;FrameLayout&gt; &lt;ImageView/&gt; &lt;View/&gt; &lt;ObservableListView/&gt; &lt;Toolbar/&gt; &lt;/FrameLayout&gt; 跟 ScrollView 一样，我们用 FrameLayout 作为根布局，因为它可以分别移动该布局下的子 view。 ImageView 是我们应该用来产生视差效果的视图。 下一个视图跟 ScrollView 中的用法就不太一样了。 为什么用不一样的布局？ 跟 ScrollView 不同的是，ListView 不能拥有子视图，因此 ImageView 应该在 ListView 的外面，并且我们应该手动实现 ImageView 的移动。 如何放置 ImageView 和 ListView？ ImageView 要比 ListView 滚动得更慢，所以 ImageView 应该在 ListView 的下方，不然的话， ImageView 的底部就会盖住 ListView 的顶部。 同时，ListView 顶部应该有一个巨大的 padding 用来显示 ImageView。我们可以通过给 ListView 添加一个透明的 header view 来达到这个目的。 为什么需要这个透明的 view 就像我在上面说过的，ListView 应该有一个透明的header，因此背景色应该也是透明的，但是如果我们仅仅把背景设置成透明，这样做不仅 header 透明了，ListView 中的 item 也会变成透明的。为了避免这种情况，我们可以在 ListView下 面设置一个假的背景 view 。 动画 Activity的基本结构 跟 ParallaxToolbarScrollViewActivity 一样的结构： public class ParallaxToolbarListViewActivity extends BaseActivity implements ObservableScrollViewCallbacks 初始化视图 跟 ScrollView 一样，初始化 ObservableListView, ImageView, Toolbar等，需要注意的是 ListView 应该有一个 header view： private View mImageView; private View mToolbarView; private View mListBackgroundView; private ObservableListView mListView; private int mParallaxImageHeight; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_parallaxtoolbarlistview) ; setSupportActionBar((Toolbar) findViewById(R.id.toolbar)); mImageView = findViewById(R.id.image); mToolbarView = findViewById(R.id.toolbar); mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(0, getResources().getColor(R.color.primary))); mParallaxImageHeight = getResources().getDimensionPixelSize(R.dimen.parallax_image_height); mListView = (ObservableListView) findViewById(R.id.list); mListView.setScrollViewCallbacks(this); // Set padding view for ListView.

			<hr>
			

			<aside class="copyright" role="note">
				
				&copy; 2016 Released under the MIT license &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://chiakimayuzumi.github.io/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;
            
            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }
        

        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//gohugo.io/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
