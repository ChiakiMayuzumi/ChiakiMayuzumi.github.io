<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ChiakiMayuzumi</title>
    <link>http://chiakimayuzumi.github.io/</link>
    <description>Recent content on ChiakiMayuzumi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Mar 2016 20:10:46 +0100</lastBuildDate>
    <atom:link href="http://chiakimayuzumi.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ExpandableListView的继承关系和设计模式</title>
      <link>http://chiakimayuzumi.github.io/apidemos/expandablelistview/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/apidemos/expandablelistview/</guid>
      <description>

&lt;h1 id=&#34;继承关系&#34;&gt;继承关系&lt;/h1&gt;

&lt;p&gt;ExpandableListView 继承关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/ExpandableListView继承关系.png&#34; alt=&#34;ExpandableListView继承关系&#34; /&gt;&lt;/p&gt;

&lt;p&gt;关于ExpandableListView 的用法可以参考ApiDemos的分析文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/archives/3852&#34;&gt;[ApiDemos] ExpandableListActivity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面来分析一下 ExpandableListView 从继承类中得到了哪些接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;继承自 Listview 中的接口：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FixedViewInfo（用来在列表内展现一个固定位置视图）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;继承自AbsListView中的接口：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SelectionBoundsAdjuster（允许当前列表项的顶级视图实现这个接口去修改它的展示的边界区域）&lt;/li&gt;
&lt;li&gt;RecyclerListener（当一个 View 由于 ListView 的滑动被系统回收到 RecycleBin 的 mScrapViews 数组时会调用 RecyclerListener 中的 onMovedToScrapHeap 方法）&lt;/li&gt;
&lt;li&gt;OnScrollListener（ Listview 分批加载用到）&lt;/li&gt;
&lt;li&gt;MultiChoiceModeListener（监听器来帮助开发者进行多选处理）&lt;/li&gt;
&lt;li&gt;LayoutParams（相当于一个 Layout 的信息包，封装了 Layout 的位置、高、宽等信息）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;继承自AdapterView的接口：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AdapterContextMenuInfo（当显示 AdapterView 的上下文菜单时为 onCreateContextMenu 回调函数提供的额外的菜单信息）&lt;/li&gt;
&lt;li&gt;OnItemClickListener（使用 ListView 的时候为 ListView 添加一个响应事件）&lt;/li&gt;
&lt;li&gt;OnItemLongClickListener（长按响应）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;继承自ViewGroup的接口：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MarginLayoutParams（用于定义和边缘的空白）&lt;/li&gt;
&lt;li&gt;OnHierarchyChangeListener（监听 ViewGroup 并包括其继承者之中的增加和删除孩子的情况）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expandablelistadapter&#34;&gt;ExpandableListAdapter&lt;/h1&gt;

&lt;p&gt;一个接口，将基础数据链接到一个 ExpandableListView。 此接口的实施将提供访问Child的数据（由组分类），并实例化的 Child 和 Group。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;getChildId (int groupPosition, int childPosition) 获取与在给定组给予孩子相关的数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getChildrenCount (int groupPosition) 返回在指定 Group 的 Child 数目。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getGroupView (int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) （类似于 ListView 的 getView 方法）,每次加载组列表时都会执行该方法重新绘制页面。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getChildView,当展开分组时会调用此方法来绘制当前分组的子项。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expandablelistview主要方法&#34;&gt;ExpandableListView主要方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;expandGroup (int groupPos) ;//在分组列表视图中 展开一组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;setSelectedGroup (int groupPosition) ;//设置选择指定的组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;setSelectedChild (int groupPosition, int childPosition, boolean shouldExpandGroup);//设置选择指定的子项&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getPackedPositionGroup (long packedPosition);//返回所选择的组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getPackedPositionForChild (int groupPosition, int childPosition) ;//返回所选择的子项&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getPackedPositionType (long packedPosition);//返回所选择项的类型（Child,Group）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;isGroupExpanded (int groupPosition);//判断此组是否展开&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;expandableListView.setDivider();这个是设定每个Group之间的分割线&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;expandableListView.setGroupIndicator();这个是设定每个Group之前的那个图标&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;expandableListView.collapseGroup(int group); 将第group组收起&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;设计模式&#34;&gt;设计模式&lt;/h1&gt;

&lt;p&gt;由于 ExpandableListView 继承自 ListView ，并且也需要设置适配器 ExpandableListAdapter，因此 ExpandableListView 也运用了适配器模式，并且是对象适配器模式。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/UML_对象适配器.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/UML_对象适配器.png&#34; alt=&#34;UML_对象适配器&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;适配器模式介绍见文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/archives/5692&#34;&gt;[Android]设计模式-适配器模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大致用法如下：&lt;/p&gt;

&lt;p&gt;//定义
  expandableListView = (ExpandableListView)findViewById(R.id.expendlist);&lt;/p&gt;

&lt;p&gt;//设置适配器
  adapter = new MyExpandableListViewAdapter(this);&lt;/p&gt;

&lt;p&gt;expandableListView.setAdapter(adapter);&lt;/p&gt;

&lt;p&gt;//适配器代码
   class MyExpandableListViewAdapter extends BaseExpandableListAdapter {&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;｝&lt;/p&gt;

&lt;p&gt;为什么ExpandableListView要使用Adapter呢？跟ListView一样，需要能够显示各式各样的视图，每个人需要的显示效果各不相同，显示的数据类型、数量等也千变万化。那么如何隔离这种变化尤为重要。&lt;/p&gt;

&lt;p&gt;通过增加一个 Adapter 层，可以来应对变化，将 ExpandableListView 需要的接口抽象到 Adapter 对象中，这样只要用户实现了 Adapter 的接口，ListView 就可以按照用户设定的显示效果、数量、数据来显示特定的 Item View。&lt;/p&gt;

&lt;p&gt;通过代理数据集来告知数据的个数( getChildrenCount函数 )以及每个数据的类型( getChildId函数 )，最重要的是要解决 Item View 的输出。Item View 千变万化，但终究它都是 View 类型，Adapter 统一将 Item View 输出为 View ( getGroupView函数 )，这样就很好的应对了 Item View的可变性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;适配器模式的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。&lt;/li&gt;
&lt;li&gt;更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— ObservableRecyclerView 源码分析</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/recyclerview/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/recyclerview/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;前面的章节，我们主要介绍了如何利用开源库 ObservableScrollView 来实现出各种我们需要的滚动效果的实例和实现代码，却一直没有分析过在实现过程中所使用的一系列 &lt;code&gt;ObservablexxxView&lt;/code&gt; 的源代码，今天我们就来看看，在开源库中 ObservableRecyclerView 的源码。
ObservableRecyclerView 关系图如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableRecyclerView-源码分析.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableRecyclerView-源码分析.png&#34; alt=&#34;ObservableRecyclerView 源码分析&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由图可知：ObservableRecyclerView 继承自 RecyclerView 并实现 Scrollable 接口，与此同时，ObservableRecyclerView 还持有四个类的引用，这四个类分别是：ObservableScrollViewCallbacks、ScrollState、ViewGroup 和 MotionEvent，其中：&lt;/p&gt;

&lt;p&gt;ObservableScrollViewCallbacks 是开源库所定义的一个回调接口；&lt;/p&gt;

&lt;p&gt;ScrollState 是一个枚举类，表示了滑动的三个状态：&lt;code&gt;STOP&lt;/code&gt;、&lt;code&gt;UP&lt;/code&gt; 和 &lt;code&gt;DOWN&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;ViewGroup 用于在 Touch 事件拦截的过程中，指定父类 View；&lt;/p&gt;

&lt;p&gt;当用户触摸屏幕时则会产生一个 MotionEvent 对象，在 重写 &lt;code&gt;onTouchEvent()&lt;/code&gt; 方法和 &lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 方法时，都需要传入 MotionEvent 参数。&lt;/p&gt;

&lt;h2 id=&#34;scrollable&#34;&gt;Scrollable&lt;/h2&gt;

&lt;h3 id=&#34;接口方法&#34;&gt;接口方法&lt;/h3&gt;

&lt;p&gt;首先来看 Scrollable 接口，该接口是开源库所定义的一个接口，给所有接下来需要实现可观测，可滚动的控件（RecyclerView、ScrollView、ListView、WebView 和 GridView）提供了一个通用的应用程序接口，实现该接口必须实现以下几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;setScrollViewCallbacks(ObservableScrollViewCallbacks listener)：设置一个回调监听&lt;/li&gt;
&lt;li&gt;addScrollViewCallbacks(ObservableScrollViewCallbacks listener)：增加一个回调监听&lt;/li&gt;
&lt;li&gt;removeScrollViewCallbacks(ObservableScrollViewCallbacks listener)：删除一个回调监听&lt;/li&gt;
&lt;li&gt;clearScrollViewCallbacks()：清除所有回调监听&lt;/li&gt;
&lt;li&gt;scrollVerticallyTo(int y)：垂直滚动到坐标 y 处（y 为绝对坐标）&lt;/li&gt;
&lt;li&gt;getCurrentScrollY()：返回当前 y 坐标&lt;/li&gt;
&lt;li&gt;setTouchInterceptionViewGroup(ViewGroup viewGroup)：设置一个触摸事件拦截的 ViewGroup ，用来将拦截事件传递到该 View 的父类 View 中去，这也是为什么 ObservableRecyclerView 类中会有 ViewGroup 类的引用的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结一下 Scrollable 接口，主要完成对滚动控件回调接口的设置、增加、删除和清理的工作，还能实现滚动的功能，返回当前垂直方向上的坐标，并且对拦截事件的处理进行相关设置。&lt;/p&gt;

&lt;h3 id=&#34;具体实现&#34;&gt;具体实现&lt;/h3&gt;

&lt;p&gt;在 ObservableRecyclerView 中，这些方法分别是如何实现的？接下来让我们看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
  public void setScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
    mCallbacks = listener;
  }

  @Override
  public void addScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
    if (mCallbackCollection == null) {
      mCallbackCollection = new ArrayList&amp;lt;&amp;gt;();
    }
    mCallbackCollection.add(listener);
  }

  @Override
  public void removeScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
    if (mCallbackCollection != null) {
      mCallbackCollection.remove(listener);
    }
  }

  @Override
  public void clearScrollViewCallbacks() {
    if (mCallbackCollection != null) {
      mCallbackCollection.clear();
    }
  }

  @Override
  public void setTouchInterceptionViewGroup(ViewGroup viewGroup) {
    mTouchInterceptionViewGroup = viewGroup;
  }

  @Override
  public void scrollVerticallyTo(int y) {
    View firstVisibleChild = getChildAt(0);
    if (firstVisibleChild != null) {
      int baseHeight = firstVisibleChild.getHeight();
      int position = y / baseHeight;
      scrollVerticallyToPosition(position);
    }
  }
  
  @Override
  public int getCurrentScrollY() {
    return mScrollY;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ObservableRecyclerView 持有一个 ArrayList，如果需要添加多个回调接口，则将添加的接口放入该容器中，删除和清理操作也是基于该容器的操作。注意一下  &lt;code&gt;scrollVerticallyTo()&lt;/code&gt; 方法的实现，需要结合 &lt;code&gt;scrollVerticallyToPosition()&lt;/code&gt; 方法一起阅读：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void scrollVerticallyToPosition(int position) {
    LayoutManager lm = getLayoutManager();

    if (lm != null &amp;amp;&amp;amp; lm instanceof LinearLayoutManager) {
      ((LinearLayoutManager) lm).scrollToPositionWithOffset(position, 0);
    } else {
      scrollToPosition(position);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，在 &lt;code&gt;scrollVerticallyToPosition()&lt;/code&gt; 方法中，针对 LayoutManager 的类型会有一个判断，如果 LayoutManager 是 LinearLayoutManager，执行 &lt;code&gt;scrollToPositionWithOffset()&lt;/code&gt; 方法，否则执行 &lt;code&gt;scrollToPosition()&lt;/code&gt; 方法，完成最后的滚动操作。&lt;/p&gt;

&lt;h2 id=&#34;observablescrollviewcallbacks&#34;&gt;ObservableScrollViewCallbacks&lt;/h2&gt;

&lt;h3 id=&#34;接口方法-1&#34;&gt;接口方法&lt;/h3&gt;

&lt;p&gt;ObservableRecyclerView 持有 ObservableScrollViewCallbacks 的引用,该接口也是开源库所定义的接口，当使用 ObservableRecyclerView 的时候，由用户自己定义滚动时的回调函数，该接口中的方法如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onScrollChanged(int scrollY, boolean firstScroll, boolean dragging):在滚动状态发生改变的时候调用，但是不会在第一次加载页面的时候调用，如果需要在该方法中初始化布局，需要手动去调用一下。&lt;/li&gt;
&lt;li&gt;onDownMotionEvent():手指按下的事件发生时的回调函数。&lt;/li&gt;
&lt;li&gt;onUpOrCancelMotionEvent(ScrollState scrollState):手指抬起的事件发生或者滚动事件被取消时的回调函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;具体实现-1&#34;&gt;具体实现&lt;/h3&gt;

&lt;p&gt;总的来说，在使用的时候，设置监听后重写回调接口中的这三个方法，已经足够实现我们所希望的滚动监听效果了。还记得最简单的那个 ActionBar 的 &lt;code&gt;显示/隐藏&lt;/code&gt; 示例吗？首先，让 Activity 实现该接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ActionBarControlRecyclerViewActivity extends BaseActivity implements ObservableScrollViewCallbacks ……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们在 onCreate 中初始化 ObservableRecyclerView，并为它设置滚动监听：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObservableRecyclerView recyclerView = (ObservableRecyclerView) findViewById(R.id.recycler);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        recyclerView.setHasFixedSize(true);
        recyclerView.setScrollViewCallbacks(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置好监听后，必须要实现以上三个方法，为了达到 ActionBar 的 &lt;code&gt;显示/隐藏&lt;/code&gt; 效果，需要这样实现方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
    public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
    }

    @Override
    public void onDownMotionEvent() {
    }

    @Override
    public void onUpOrCancelMotionEvent(ScrollState scrollState) {
        ActionBar ab = getSupportActionBar();
        if (ab == null) {
            return;
        }
        if (scrollState == ScrollState.UP) {
            if (ab.isShowing()) {
                ab.hide();
            }
        } else if (scrollState == ScrollState.DOWN) {
            if (!ab.isShowing()) {
                ab.show();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了这个效果的实现。&lt;/p&gt;

&lt;p&gt;注意，由于该效果的代码是放在 &lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; 这个方法中，当你在滑动该页面的同时，并不会出现 &lt;code&gt;显示/隐藏&lt;/code&gt; 的效果，而是要在手指抬起的瞬间才会产生相应的效果，如果你希望在滚动的同时产生 &lt;code&gt;显示/隐藏&lt;/code&gt; 的效果，应该将实现该效果的代码放入 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法中去。&lt;/p&gt;

&lt;h2 id=&#34;observablerecyclerview-其他重要方法&#34;&gt;ObservableRecyclerView 其他重要方法&lt;/h2&gt;

&lt;p&gt;下面我们来看一下 ObservableRecyclerView 中其他的重要的方法，其中有些是重写的父类方法，有些是自己定义的方法。&lt;/p&gt;

&lt;p&gt;重写父类的方法有：
- onRestoreInstanceState(Parcelable state)
- onSaveInstanceState()
- onScrollChanged(int l, int t, int oldl, int oldt)
- onInterceptTouchEvent(MotionEvent ev)
- onTouchEvent(MotionEvent ev)
- getChildAdapterPosition(View child)
自己的方法：
- init()
- dispatchOnDownMotionEvent()
- dispatchOnScrollChanged(int scrollY, boolean firstScroll, boolean dragging)
- dispatchOnUpOrCancelMotionEvent(ScrollState scrollState)
- hasNoCallbacks()
以及一个内部类：&lt;code&gt;SavedState&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;保存状态&#34;&gt;保存状态&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 和 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 以及内部类 &lt;code&gt;SavedState&lt;/code&gt; 完成一些临时性的状态的保存工作，需要保存的属性如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mPrevFirstVisiblePosition;
private int mPrevFirstVisibleChildHeight = -1;
private int mPrevScrolledChildrenHeight;
private int mPrevScrollY;
private int mScrollY;
private SparseIntArray mChildrenHeights;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某个时刻 Activity 因为系统回收资源的问题要被杀掉，通过 onSaveInstanceState 将有机会保存其用户界面状态，使得将来用户返回到 Activity 时能通过  onCreate(Bundle) 或者 onRestoreInstanceState(Bundle) 恢复界面的状态。&lt;/p&gt;

&lt;h3 id=&#34;onscrollchanged&#34;&gt;onScrollChanged&lt;/h3&gt;

&lt;p&gt;onScrollChanged(int l, int t, int oldl, int oldt)
重写 View 中的方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
  protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if (hasNoCallbacks()) {
      return;
    }
    if (getChildCount() &amp;gt; 0) {
      int firstVisiblePosition = getChildAdapterPosition(getChildAt(0));
      int lastVisiblePosition = getChildAdapterPosition(getChildAt(getChildCount() - 1));
      for (int i = firstVisiblePosition, j = 0; i &amp;lt;= lastVisiblePosition; i++, j++) {
        int childHeight = 0;
        View child = getChildAt(j);
        if (child != null) {
          if (mChildrenHeights.indexOfKey(i) &amp;lt; 0 || (child.getHeight() != mChildrenHeights.get(i))) {
            childHeight = child.getHeight();
          }
        }
        mChildrenHeights.put(i, childHeight);
      }

      View firstVisibleChild = getChildAt(0);
      if (firstVisibleChild != null) {
        if (mPrevFirstVisiblePosition &amp;lt; firstVisiblePosition) {
          // 向下滑动
          int skippedChildrenHeight = 0;
          if (firstVisiblePosition - mPrevFirstVisiblePosition != 1) {
            for (int i = firstVisiblePosition - 1; i &amp;gt; mPrevFirstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // 把每个 item 的高度近似为第一个可见子 View 的高度
                // 这样计算也许不正确，但如果不这样做，当从底部向上滑动时scrollY会出错
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight += mPrevFirstVisibleChildHeight + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition &amp;lt; mPrevFirstVisiblePosition) {
          // 向上滑动
          int skippedChildrenHeight = 0;
          if (mPrevFirstVisiblePosition - firstVisiblePosition != 1) {
            for (int i = mPrevFirstVisiblePosition - 1; i &amp;gt; firstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // 把每个 item 的高度近似为第一个可见子 View 的高度
                // 这样计算也许不正确，但如果不这样做，当从底部向上滑动时 scrollY 会出错
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight -= firstVisibleChild.getHeight() + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition == 0) {
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
          mPrevScrolledChildrenHeight = 0;
        }
        if (mPrevFirstVisibleChildHeight &amp;lt; 0) {
          mPrevFirstVisibleChildHeight = 0;
        }
        mScrollY = mPrevScrolledChildrenHeight - firstVisibleChild.getTop() + getPaddingTop();
        mPrevFirstVisiblePosition = firstVisiblePosition;

        dispatchOnScrollChanged(mScrollY, mFirstScroll, mDragging);
        if (mFirstScroll) {
          mFirstScroll = false;
        }

        if (mPrevScrollY &amp;lt; mScrollY) {
          //向下
          mScrollState = ScrollState.UP;
        } else if (mScrollY &amp;lt; mPrevScrollY) {
          //向上
          mScrollState = ScrollState.DOWN;
        } else {
          mScrollState = ScrollState.STOP;
        }
        mPrevScrollY = mScrollY;
      }
    }
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码我们可以得知：
1、没有设置回调的话，直接返回，不会将触摸事件进行分发；
2、子布局的数量大于0的情况下，获取第一个子布局的位置 &lt;code&gt;firstVisiblePosition&lt;/code&gt; 和最后一个子布局的位置 &lt;code&gt;lastVisiblePosition&lt;/code&gt;；
3、循环遍历所有子布局，当 SparseIntArray 容器中没有保存该子布局的高度，或者保存的值跟该子布局现在的高度不一致时，将该值存入容器中；
4、比较 &lt;code&gt;mPrevFirstVisiblePosition&lt;/code&gt; 和 &lt;code&gt;firstVisiblePosition&lt;/code&gt; 的差值，判断此时的滑动方向（是 &lt;code&gt;UP&lt;/code&gt; 还是 &lt;code&gt;DOWN&lt;/code&gt;），分别求 &lt;code&gt;mPrevScrolledChildrenHeight&lt;/code&gt; 和 &lt;code&gt;mPrevFirstVisibleChildHeight&lt;/code&gt; 的大小，最终求得 &lt;code&gt;mScrollY&lt;/code&gt; 的值，调用 &lt;code&gt;dispatchOnScrollChanged()&lt;/code&gt;，让回调方法去实现最终的 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h3 id=&#34;事件分发&#34;&gt;事件分发&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 和 &lt;code&gt;onTouchEvent()&lt;/code&gt; 重写了 ViegGroup 中的方法，前者完成对触摸事件的拦截，如果检测到手指按下，则调用方法&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;。在方法 &lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;中，对事件进行处理，处理方式为：如果设置了回调，就调用回调方法中的&lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法（具体是什么操作需要用户自己在使用时实现），如果存放回调接口的容器不为零，将遍历容器中的每一个接口，调用每个接口的 &lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法。
&lt;code&gt;onTouchEvent()&lt;/code&gt; 方法中，如果检测到触摸事件被取消，则调用&lt;code&gt;dispatchOnUpOrCancelMotionEvent()&lt;/code&gt; 方法，跟上面的&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;方法类似，也会调用回调方法中的&lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; 方法，或者遍历容器。&lt;/p&gt;

&lt;p&gt;而当检测到触摸事件为 &lt;code&gt;MOVE&lt;/code&gt; 时，情况就复杂了许多，我们看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      case MotionEvent.ACTION_MOVE:
        if (mPrevMoveEvent == null) {
          mPrevMoveEvent = ev;
        }
        float diffY = ev.getY() - mPrevMoveEvent.getY();
        mPrevMoveEvent = MotionEvent.obtainNoHistory(ev);
        if (getCurrentScrollY() - diffY &amp;lt;= 0) {

          if (mIntercepted) {
            return false;
          }

          final ViewGroup parent;
          if (mTouchInterceptionViewGroup == null) {
            parent = (ViewGroup) getParent();
          } else {
            parent = mTouchInterceptionViewGroup;
          }

          float offsetX = 0;
          float offsetY = 0;
          for (View v = this; v != null &amp;amp;&amp;amp; v != parent; v = (View) v.getParent()) {
            offsetX += v.getLeft() - v.getScrollX();
            offsetY += v.getTop() - v.getScrollY();
          }
          
          final MotionEvent event = MotionEvent.obtainNoHistory(ev);
          event.offsetLocation(offsetX, offsetY);

          if (parent.onInterceptTouchEvent(event)) {
            mIntercepted = true;

            event.setAction(MotionEvent.ACTION_DOWN);

            post(new Runnable() {
              @Override
              public void run() {
                parent.dispatchTouchEvent(event);
              }
            });
            return false;
          }
          return super.onTouchEvent(ev);
        }
        break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该方法中，&lt;code&gt;mTouchInterceptionViewGroup&lt;/code&gt; 将设置好的拦截 View 赋值给 &lt;code&gt;parent&lt;/code&gt;，如果没有设置，则自动赋值当前 View 的父类给 &lt;code&gt;parent&lt;/code&gt;。得到 &lt;code&gt;parent&lt;/code&gt; 以后，就可以完成物理坐标向逻辑坐标的转换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event.offsetLocation(offsetX, offsetY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果父类已经将该事件拦截，则返回 false，并且启动线程调用父类的 &lt;code&gt;dispatchTouchEvent()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h3 id=&#34;getchildadapterposition-和-init&#34;&gt;getChildAdapterPosition 和 init&lt;/h3&gt;

&lt;p&gt;最后，&lt;code&gt;getChildAdapterPosition()&lt;/code&gt; 方法重写自 View 中的方法，根据 &lt;code&gt;recyclerViewLibraryVersion&lt;/code&gt; 的值判断是调用&lt;code&gt;getChildAdapterPosition()&lt;/code&gt; 还是 &lt;code&gt;getChildPosition()&lt;/code&gt;，而 &lt;code&gt;init()&lt;/code&gt; 方法在构造器中被调用，它新建一个SparseIntArray（比 HashMap 效率更高，可以提高性能），同时调用 &lt;code&gt;checkLibraryVersion()&lt;/code&gt; 检查 RecyclerView 库的版本号。&lt;/p&gt;

&lt;p&gt;ObservableRecyclerView 的源码分析到这里也就差不多了，通过阅读 ObservableRecyclerView 的源码，又学到了许多的知识，尤其是巩固了之前学的不是很明白的 View 的事件拦截和事件处理这部分的内容，让我受益匪浅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— ObservableScrollView 源码分析</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/scrollview/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/scrollview/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;前面的章节，我们主要介绍了如何利用开源库 ObservableScrollView 来实现出各种我们需要的滚动效果的实例和实现代码，却一直没有分析过在实现过程中所使用的一系列 &lt;code&gt;ObservablexxxView&lt;/code&gt; 的源代码，今天我们就来看看，在开源库中 ObservableScrollView 的源码。&lt;/p&gt;

&lt;p&gt;ObservableScrollView 关系图如下：
&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableScrollView-源码分析.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ObservableScrollView-源码分析.png&#34; alt=&#34;ObservableScrollView 源码分析&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由图可知：ObservableScrollView 继承自 ScrollView 并实现 Scrollable 接口，与此同时，ObservableScrollView 还持有四个类的引用，这四个类分别是：ObservableScrollViewCallbacks、ScrollState、ViewGroup 和 MotionEvent，其中：&lt;/p&gt;

&lt;p&gt;ObservableScrollViewCallbacks 是开源库所定义的一个回调接口；&lt;/p&gt;

&lt;p&gt;ScrollState 是一个枚举类，表示了滑动的三个状态：&lt;code&gt;STOP&lt;/code&gt;、&lt;code&gt;UP&lt;/code&gt; 和 &lt;code&gt;DOWN&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;ViewGroup 用于在 Touch 事件拦截的过程中，指定父类 View；&lt;/p&gt;

&lt;p&gt;当用户触摸屏幕时则会产生一个 MotionEvent 对象，在 重写 &lt;code&gt;onTouchEvent()&lt;/code&gt; 方法和 &lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 方法时，都需要传入 MotionEvent 参数。&lt;/p&gt;

&lt;h2 id=&#34;scrollable&#34;&gt;Scrollable&lt;/h2&gt;

&lt;p&gt;该接口的方法已经在上一节中详细描述了，接下来我们直接看在 ObservableScrollView 中是如何实现该接口的。&lt;/p&gt;

&lt;h3 id=&#34;具体实现&#34;&gt;具体实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Override
    public void setScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        mCallbacks = listener;
    }

    @Override
    public void addScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        if (mCallbackCollection == null) {
            mCallbackCollection = new ArrayList&amp;lt;&amp;gt;();
        }
        mCallbackCollection.add(listener);
    }

    @Override
    public void removeScrollViewCallbacks(ObservableScrollViewCallbacks listener) {
        if (mCallbackCollection != null) {
            mCallbackCollection.remove(listener);
        }
    }

    @Override
    public void clearScrollViewCallbacks() {
        if (mCallbackCollection != null) {
            mCallbackCollection.clear();
        }
    }
    
    @Override
    public void setTouchInterceptionViewGroup(ViewGroup viewGroup) {
        mTouchInterceptionViewGroup = viewGroup;
    }

    @Override
    public void scrollVerticallyTo(int y) {
        scrollTo(0, y);
    }

    @Override
    public int getCurrentScrollY() {
        return mScrollY;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与上一节中 ObservableRecyclerView 的实现方法不同的是  &lt;code&gt;scrollVerticallyTo()&lt;/code&gt; 方法，该方法更为简洁，因为它可以直接调用继承自 ScrollView 的方法 &lt;code&gt;scrollTo()&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;observablescrollviewcallbacks&#34;&gt;ObservableScrollViewCallbacks&lt;/h2&gt;

&lt;p&gt;该接口的方法已经在上一节中详细描述了，接下来我们直接看在 ObservableScrollView 中是如何实现该接口的。&lt;/p&gt;

&lt;h3 id=&#34;具体实现-1&#34;&gt;具体实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Override
  protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if (hasNoCallbacks()) {
      return;
    }
    if (getChildCount() &amp;gt; 0) {
      int firstVisiblePosition = getChildAdapterPosition(getChildAt(0));
      int lastVisiblePosition = getChildAdapterPosition(getChildAt(getChildCount() - 1));
      for (int i = firstVisiblePosition, j = 0; i &amp;lt;= lastVisiblePosition; i++, j++) {
        int childHeight = 0;
        View child = getChildAt(j);
        if (child != null) {
          if (mChildrenHeights.indexOfKey(i) &amp;lt; 0 || (child.getHeight() != mChildrenHeights.get(i))) {
            childHeight = child.getHeight();
          }
        }
        mChildrenHeights.put(i, childHeight);
      }

      View firstVisibleChild = getChildAt(0);
      if (firstVisibleChild != null) {
        if (mPrevFirstVisiblePosition &amp;lt; firstVisiblePosition) {
          // scroll down
          int skippedChildrenHeight = 0;
          if (firstVisiblePosition - mPrevFirstVisiblePosition != 1) {
            for (int i = firstVisiblePosition - 1; i &amp;gt; mPrevFirstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // Approximate each item&#39;s height to the first visible child.
                // It may be incorrect, but without this, scrollY will be broken
                // when scrolling from the bottom.
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight += mPrevFirstVisibleChildHeight + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition &amp;lt; mPrevFirstVisiblePosition) {
          // scroll up
          int skippedChildrenHeight = 0;
          if (mPrevFirstVisiblePosition - firstVisiblePosition != 1) {
            for (int i = mPrevFirstVisiblePosition - 1; i &amp;gt; firstVisiblePosition; i--) {
              if (0 &amp;lt; mChildrenHeights.indexOfKey(i)) {
                skippedChildrenHeight += mChildrenHeights.get(i);
              } else {
                // Approximate each item&#39;s height to the first visible child.
                // It may be incorrect, but without this, scrollY will be broken
                // when scrolling from the bottom.
                skippedChildrenHeight += firstVisibleChild.getHeight();
              }
            }
          }
          mPrevScrolledChildrenHeight -= firstVisibleChild.getHeight() + skippedChildrenHeight;
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
        } else if (firstVisiblePosition == 0) {
          mPrevFirstVisibleChildHeight = firstVisibleChild.getHeight();
          mPrevScrolledChildrenHeight = 0;
        }
        if (mPrevFirstVisibleChildHeight &amp;lt; 0) {
          mPrevFirstVisibleChildHeight = 0;
        }
        mScrollY = mPrevScrolledChildrenHeight - firstVisibleChild.getTop() + getPaddingTop();
        mPrevFirstVisiblePosition = firstVisiblePosition;

        dispatchOnScrollChanged(mScrollY, mFirstScroll, mDragging);
        if (mFirstScroll) {
          mFirstScroll = false;
        }

        if (mPrevScrollY &amp;lt; mScrollY) {
          //down
          mScrollState = ScrollState.UP;
        } else if (mScrollY &amp;lt; mPrevScrollY) {
          //up
          mScrollState = ScrollState.DOWN;
        } else {
          mScrollState = ScrollState.STOP;
        }
        mPrevScrollY = mScrollY;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析详解可以参考上一节的方法。&lt;/p&gt;

&lt;h2 id=&#34;observablescrollview-其他重要方法&#34;&gt;ObservableScrollView 其他重要方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;onRestoreInstanceState(Parcelable state)&lt;/li&gt;
&lt;li&gt;onSaveInstanceState()&lt;/li&gt;
&lt;li&gt;onScrollChanged(int l, int t, int oldl, int oldt)&lt;/li&gt;
&lt;li&gt;onInterceptTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;li&gt;onTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;li&gt;getChildAdapterPosition(View child)
自己的方法：&lt;/li&gt;
&lt;li&gt;dispatchOnDownMotionEvent()&lt;/li&gt;
&lt;li&gt;dispatchOnScrollChanged(int scrollY, boolean firstScroll, boolean dragging)&lt;/li&gt;
&lt;li&gt;dispatchOnUpOrCancelMotionEvent(ScrollState scrollState)&lt;/li&gt;
&lt;li&gt;hasNoCallbacks()
以及一个内部类：&lt;code&gt;SavedState&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;保存状态&#34;&gt;保存状态&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 和 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 以及内部类 &lt;code&gt;SavedState&lt;/code&gt; 完成一些临时性的状态的保存工作，需要保存的属性如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mPrevScrollY;
private int mScrollY;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某个时刻 Activity 因为系统回收资源的问题要被杀掉，通过 onSaveInstanceState 将有机会保存其用户界面状态，使得将来用户返回到 Activity 时能通过  onCreate(Bundle) 或者 onRestoreInstanceState(Bundle) 恢复界面的状态。&lt;/p&gt;

&lt;h3 id=&#34;onscrollchanged&#34;&gt;onScrollChanged&lt;/h3&gt;

&lt;p&gt;onScrollChanged(int l, int t, int oldl, int oldt)
重写 View 中的方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
    protected void onScrollChanged(int l, int t, int oldl, int oldt) {
        super.onScrollChanged(l, t, oldl, oldt);
        if (hasNoCallbacks()) {
            return;
        }
        mScrollY = t;

        dispatchOnScrollChanged(t, mFirstScroll, mDragging);
        if (mFirstScroll) {
            mFirstScroll = false;
        }

        if (mPrevScrollY &amp;lt; t) {
            mScrollState = ScrollState.UP;
        } else if (t &amp;lt; mPrevScrollY) {
            mScrollState = ScrollState.DOWN;
        }
        mPrevScrollY = t;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码我们可以得知：
1、没有设置回调的话，直接返回，不会将触摸事件进行分发；
2、如果 &lt;code&gt;mPrevScrollY&lt;/code&gt; 小于 &lt;code&gt;t&lt;/code&gt;，则滚动状态为 &lt;code&gt;UP&lt;/code&gt;，如果 &lt;code&gt;mPrevScrollY&lt;/code&gt; 大于 &lt;code&gt;t&lt;/code&gt;，则滚动状态为 &lt;code&gt;DOWN&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;事件分发&#34;&gt;事件分发&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 和 &lt;code&gt;onTouchEvent()&lt;/code&gt; 重写了 ViegGroup 中的方法，前者完成对触摸事件的拦截，如果检测到手指按下，则调用方法&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;。在方法 &lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;中，对事件进行处理，处理方式为：如果设置了回调，就调用回调方法中的&lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法（具体是什么操作需要用户自己在使用时实现），如果存放回调接口的容器不为零，将遍历容器中的每一个接口，调用每个接口的 &lt;code&gt;onDownMotionEvent()&lt;/code&gt; 方法。
&lt;code&gt;onTouchEvent()&lt;/code&gt; 方法中，如果检测到触摸事件被取消，则调用&lt;code&gt;dispatchOnUpOrCancelMotionEvent()&lt;/code&gt; 方法，跟上面的&lt;code&gt;dispatchOnDownMotionEvent()&lt;/code&gt;方法类似，也会调用回调方法中的&lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; 方法，或者遍历容器。
而当检测到触摸事件为 &lt;code&gt;MOVE&lt;/code&gt; 时，情况依然复杂，我们看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case MotionEvent.ACTION_MOVE:
                if (mPrevMoveEvent == null) {
                    mPrevMoveEvent = ev;
                }
                float diffY = ev.getY() - mPrevMoveEvent.getY();
                mPrevMoveEvent = MotionEvent.obtainNoHistory(ev);
                if (getCurrentScrollY() - diffY &amp;lt;= 0) {
                    // Can&#39;t scroll anymore.

                    if (mIntercepted) {
                        // Already dispatched ACTION_DOWN event to parents, so stop here.
                        return false;
                    }

                    // Apps can set the interception target other than the direct parent.
                    final ViewGroup parent;
                    if (mTouchInterceptionViewGroup == null) {
                        parent = (ViewGroup) getParent();
                    } else {
                        parent = mTouchInterceptionViewGroup;
                    }

                    // Get offset to parents. If the parent is not the direct parent,
                    // we should aggregate offsets from all of the parents.
                    float offsetX = 0;
                    float offsetY = 0;
                    for (View v = this; v != null &amp;amp;&amp;amp; v != parent; v = (View) v.getParent()) {
                        offsetX += v.getLeft() - v.getScrollX();
                        offsetY += v.getTop() - v.getScrollY();
                    }
                    final MotionEvent event = MotionEvent.obtainNoHistory(ev);
                    event.offsetLocation(offsetX, offsetY);

                    if (parent.onInterceptTouchEvent(event)) {
                        mIntercepted = true;

                        // If the parent wants to intercept ACTION_MOVE events,
                        // we pass ACTION_DOWN event to the parent
                        // as if these touch events just have began now.
                        event.setAction(MotionEvent.ACTION_DOWN);

                        // Return this onTouchEvent() first and set ACTION_DOWN event for parent
                        // to the queue, to keep events sequence.
                        post(new Runnable() {
                            @Override
                            public void run() {
                                parent.dispatchTouchEvent(event);
                            }
                        });
                        return false;
                    }
                
                    return super.onTouchEvent(ev);
                }
                break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该方法中，&lt;code&gt;mTouchInterceptionViewGroup&lt;/code&gt; 将设置好的拦截 View 赋值给 &lt;code&gt;parent&lt;/code&gt;，如果没有设置，则自动赋值当前 View 的父类给 &lt;code&gt;parent&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果父类已经将该事件拦截，则返回 false，并且启动线程调用父类的 &lt;code&gt;dispatchTouchEvent()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;ObservableScrollView 的源码分析到这里也就差不多了，通过阅读 ObservableScrollView 的源码，跟上一节的 ObservableRecyclerView 源码进行了对比，也让我再一次了解到了 RecyclerView 跟 ScrollView 的不同之处。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— Sticky header 顶部固定</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/header/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/header/</guid>
      <description>

&lt;p&gt;这一节主要说明了如何实现在滚动视图中将顶部固定在屏幕最上方的效果，并给出在各个 View 上如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;StickyHeaderListViewActivity&lt;/li&gt;
&lt;li&gt;StickyHeaderRecyclerViewActivity&lt;/li&gt;
&lt;li&gt;StickyHeaderScrollViewActivity&lt;/li&gt;
&lt;li&gt;StickyHeaderWebViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;顶部固定效果是 &lt;code&gt;显示/隐藏 Toolbar&lt;/code&gt; 效果的更加复杂的版本，将一半的 &lt;code&gt;header view&lt;/code&gt; 保留在屏幕的顶部。这一次我们用 ScrollView 来示范，方法套用到其他的 view 上也并不困难。&lt;/p&gt;

&lt;h2 id=&#34;使用-scrollview&#34;&gt;使用 ScrollView&lt;/h2&gt;

&lt;h3 id=&#34;scrollview-的布局&#34;&gt;ScrollView 的布局&lt;/h3&gt;

&lt;p&gt;先看布局，以下是 ScrollView 的顶部固定样式的基本结构，比之前的 &lt;code&gt;显示/隐藏 Toolbar&lt;/code&gt; 布局要复杂许多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ObservableScrollView android:id=&amp;quot;@+id/scroll&amp;quot;&amp;gt;
    &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
      &amp;lt;View android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
      &amp;lt;View android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
      &amp;lt;TextView/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
  &amp;lt;/ObservableScrollView&amp;gt;
  &amp;lt;LinearLayout
    android:id=&amp;quot;@+id/header&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
    &amp;lt;Toolbar
      android:id=&amp;quot;@+id/toolbar&amp;quot;
      android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
    &amp;lt;TextView
      android:id=&amp;quot;@+id/sticky&amp;quot;
      android:layout_height=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
  &amp;lt;/LinearLayout&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;显示/隐藏 Toolbar&lt;/code&gt; 样式中，我们只使用了 ObservableScrollView 和 Toolbar，这一次我们让每一个视图都变得更加复杂了。&lt;/p&gt;

&lt;h4 id=&#34;为-scrollview-创造顶部空间&#34;&gt;为 ScrollView 创造顶部空间&lt;/h4&gt;

&lt;p&gt;初始化时，ScrooView 需要一个两倍体积于 ActionBar的空间，其中一半会在滑动的过程中固定住，因此简单的在 TextView 布局上使用高度  &lt;code&gt;?attr/actionBarSize&lt;/code&gt; 添加两个 view 就可以了。&lt;/p&gt;

&lt;p&gt;也可以直接用确定的 dp 值来添加一个 view 即可，不过这样的话，就不能更好的适应不同尺寸的屏幕。&lt;/p&gt;

&lt;p&gt;需要注意的是，TextView 是 ScrollView 里的实际内容。你可以用其他的 view 来替换它。&lt;/p&gt;

&lt;h4 id=&#34;为-toolbar-制作固定部分&#34;&gt;为 Toolbar 制作固定部分&lt;/h4&gt;

&lt;p&gt;跟显示/隐藏 Toolbar不同的是，这里我们用 &lt;code&gt;LinearLayout&lt;/code&gt; 替换掉了之前的 Toolbar 布局，这个 &lt;code&gt;LinearLayout&lt;/code&gt; 里面包涵了一个 Toolbar 和一个 TextView，这里 TextView 将会是被固定的部分，你也可以用一些其他更复杂的 view 来代替。&lt;/p&gt;

&lt;h3 id=&#34;使用-scrollview-的回调让视图动画起来&#34;&gt;使用 ScrollView 的回调让视图动画起来&lt;/h3&gt;

&lt;p&gt;使用了两个回调： &lt;code&gt;onScrollChanged()&lt;/code&gt; 和  &lt;code&gt;onUpOrCancelMotionEvent()&lt;/code&gt; ，让视图动起来，我们需要实现下面的动画效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 ScrollView 滚动时，让 Toolbar 和固定 view 都动起来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Toolbar 会随着滚动移出屏幕，但是当我们再滚动屏幕的时候，固定的视图必须保持在屏幕的顶部。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Toolbar 还未完全移出屏幕，停止滚动时：如果我们正在上滑，则完全隐藏 Toolbar；如果我们正在下滑，则完全显示 Toolbar。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;向下滚动 ScrollView 并且抬起手指后，&lt;code&gt;header view&lt;/code&gt; 会立即出现，这被称为快速恢复模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;scrollview-滚动时移动-header-view&#34;&gt;ScrollView 滚动时移动 header view&lt;/h4&gt;

&lt;p&gt;重写方法 &lt;code&gt;onScrollChanged()&lt;/code&gt;，先写上伪代码 &lt;code&gt;if (dragging)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    // 完成剩下的代码
  //} else { // ScrollView 按照惯性滑动
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只想在拖拽的时候去移动 view，否则我们就无法实现上述的第三种情况：当滚动结束后自动的显示或者隐藏 Toolbar 。&lt;/p&gt;

&lt;p&gt;下一步，完成 &lt;code&gt;header view&lt;/code&gt; 的动画。&lt;/p&gt;

&lt;p&gt;首先，创建一个属性 &lt;code&gt;mHeaderView&lt;/code&gt; 并在 &lt;code&gt;onCreate()&lt;/code&gt; 里初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mHeaderView = findViewById(R.id.header);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mHeaderView&lt;/code&gt; 的高度随着 &lt;code&gt;scrollY&lt;/code&gt; 变量的增长而减少，因此代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    ViewHelper.setTranslationY(mHeaderView, -scrollY);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;固定的-view-应该留在屏幕顶端&#34;&gt;固定的 view 应该留在屏幕顶端&lt;/h4&gt;

&lt;p&gt;如果按照上面的写法，整个 &lt;code&gt;header view&lt;/code&gt; 都会随着滚动完全消失，这不是我们希望看到的结果，&lt;code&gt;mHeaderView&lt;/code&gt; 应该在移动到 Toolbar 高度以后就停止减少。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    int toolbarHeight = mToolbarView.getHeight();
    ViewHelper.setTranslationY(mHeaderView, Math.max(-toolbarHeight, -scrollY));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以把固定的部分一直留在顶部。&lt;/p&gt;

&lt;h4 id=&#34;toolbar-未完全消失时&#34;&gt;Toolbar 未完全消失时&lt;/h4&gt;

&lt;p&gt;我们应该使用 &lt;code&gt;onUpOrCancelMotionEvent&lt;/code&gt; 方法来达到我们想要达到的效果。&lt;/p&gt;

&lt;p&gt;如果向下滑，Toolbar 应该完全显示；如果向上滑，Toolbar 应该完全隐藏：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
  if (scrollState == ScrollState.DOWN) {
    showToolbar();
  } else if (scrollState == ScrollState.UP) {
    hideToolbar();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当我们上滑并且滚动的少于 Toolbar 高度时，隐藏 Toolbar 的时候会使得 ScrollView 的顶部出现一段空白，所以我们需要在&lt;code&gt;scrollY&lt;/code&gt; 少于 Toolbar 高度的时候使它显示而不是隐藏。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
  if (scrollState == ScrollState.DOWN) {
    showToolbar();
  } else if (scrollState == ScrollState.UP) {
    int toolbarHeight = mToolbarView.getHeight();
    int scrollY = mScrollView.getCurrentScrollY();
    if (toolbarHeight &amp;lt;= scrollY) {
      hideToolbar();
    } else {
      showToolbar();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候滑动状态变为停止（或者null）后， &lt;code&gt;header view&lt;/code&gt;  也会停止滑动，为了避免这种情况发生，我们写上else分支的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
  if (scrollState == ScrollState.DOWN) {
    showToolbar();
  } else if (scrollState == ScrollState.UP) {
    int toolbarHeight = mToolbarView.getHeight();
    int scrollY = mScrollView.getCurrentScrollY();
    if (toolbarHeight &amp;lt;= scrollY) {
      hideToolbar();
    } else {
      showToolbar();
    }
  } else {
    // 就算onScrollChanged 发生的时候scrollY没有改变，toolbar也应该调整位置
    if (!toolbarIsShown() &amp;amp;&amp;amp; !toolbarIsHidden()) {
      showToolbar();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将没写完的方法都写完。&lt;/p&gt;

&lt;p&gt;可以使用 &lt;code&gt;ViewPropertyAnimator.animate()&lt;/code&gt; 这样简单而又不改变 view 高度的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean toolbarIsShown() {
  return ViewHelper.getTranslationY(mHeaderView) == 0;
}

private boolean toolbarIsHidden() {
  return ViewHelper.getTranslationY(mHeaderView) == -mToolbarView.getHeight();
}

private void showToolbar() {
  float headerTranslationY = ViewHelper.getTranslationY(mHeaderView);
  if (headerTranslationY != 0) {
    ViewPropertyAnimator.animate(mHeaderView).cancel();
    ViewPropertyAnimator.animate(mHeaderView).translationY(0).setDuration(200).start();
  }
}

private void hideToolbar() {
  float headerTranslationY = ViewHelper.getTranslationY(mHeaderView);
  int toolbarHeight = mToolbarView.getHeight();
  if (headerTranslationY != -toolbarHeight) {
    ViewPropertyAnimator.animate(mHeaderView).cancel();
    ViewPropertyAnimator.animate(mHeaderView).translationY(-toolbarHeight).setDuration(200).start();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;ViewPropertyAnimator.animate()&lt;/code&gt; 后，在接下来的 200ms 会运行动画效果。如果下一个动画（ &lt;code&gt;showToolbar()&lt;/code&gt; 或者 &lt;code&gt;hideToolbar()&lt;/code&gt; ）在这个动画运行的时候被调用，则当前动画会被取消，因此在调用  &lt;code&gt;start()&lt;/code&gt; 之前，我们先调用 &lt;code&gt;ViewPropertyAnimator.animate(mHeaderView).cancel()&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;上滑让-header-view-滚动起来&#34;&gt;上滑让 header view 滚动起来&lt;/h4&gt;

&lt;p&gt;基本功能都快完成了，接下来还有一个地方没有实现。&lt;/p&gt;

&lt;p&gt;当我们滚动了很大一段距离以后，只需要稍稍向上滚动一点，即可显示 header view，但是当我们再向下滚动的时候，&lt;code&gt;header view&lt;/code&gt; 不会跟随 ScrollView 滚动。&lt;/p&gt;

&lt;p&gt;所以，即使在 &lt;code&gt;scrollY&lt;/code&gt; 比 Toolbar 的高度还要大的情况下，我们也要让它滚动起来。&lt;/p&gt;

&lt;p&gt;只需要计算第一次触摸屏幕的点和当前点的距离即可，当这个距离比 Toolbar 的高度要大，&lt;code&gt;header view&lt;/code&gt; 就不应该再滚动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mBaseTranslationY;

@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  if (dragging) {
    int toolbarHeight = mToolbarView.getHeight();
    if (firstScroll) { // 添加这个if分句
      float currentHeaderTranslationY = ViewHelper.getTranslationY(mHeaderView);
      if (-toolbarHeight &amp;lt; currentHeaderTranslationY) {
        mBaseTranslationY = scrollY;
      }
    }
    // 把 -scrollY 换成 -(scrollY - mBaseTranslationY)
    float headerTranslationY = Math.max(-toolbarHeight, -(scrollY - mBaseTranslationY));
    ViewPropertyAnimator.animate(mHeaderView).cancel();
    ViewHelper.setTranslationY(mHeaderView, headerTranslationY);
  }
}

@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
    // 滚动结束后清零
    mBaseTranslationY = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是发现了一个奇怪的事情，&lt;code&gt;header view&lt;/code&gt; 离开了屏幕的最顶端，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ScrollView异常.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/ScrollView异常.png&#34; alt=&#34;ScrollView异常&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是因为 &lt;code&gt;headerTranslationY&lt;/code&gt; 可以变得比0要大，应该将这个值用 &lt;code&gt;Math.min()&lt;/code&gt; 限定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float headerTranslationY = Math.min(0, Math.max(-toolbarHeight, -(scrollY - mBaseTranslationY));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果觉得表达太复杂，还可以使用本开源库提供的一个小的工具类 &lt;code&gt;ScrollUtils&lt;/code&gt;，可以将上面的 &lt;code&gt;Math.min(max, Math.max(min, value))&lt;/code&gt;替换成 &lt;code&gt;ScrollUtils.getFloat()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float headerTranslationY = ScrollUtils.getFloat(-(scrollY - mBaseTranslationY), -toolbarHeight, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成啦。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;当需要实现复杂的滚动和动画效果时，一定要仔细分析清楚其中的逻辑，将问题有条理的分开解决，这样才会达到自己想要的效果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— Toolbar上的弹性空白</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/toolbarblank/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/toolbarblank/</guid>
      <description>

&lt;p&gt;这一节主要说明了如何在 Toolbar 上方实现弹性空白布局，并给出在各个 View 上如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FlexibleSpaceToolbarScrollViewActivity&lt;/li&gt;
&lt;li&gt;FlexibleSpaceToolbarWebViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scrollview-实现弹性空白&#34;&gt;ScrollView 实现弹性空白&lt;/h2&gt;

&lt;h3 id=&#34;scrollview-布局&#34;&gt;ScrollView 布局&lt;/h3&gt;

&lt;h4 id=&#34;基本结构&#34;&gt;基本结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ObservableScrollView android:id=&amp;quot;@+id/scroll&amp;quot;&amp;gt;
    &amp;lt;FrameLayout android:id=&amp;quot;@+id/body&amp;quot;&amp;gt;
      &amp;lt;TextView/&amp;gt;
    &amp;lt;/FrameLayout&amp;gt;
  &amp;lt;/ObservableScrollView&amp;gt;
  &amp;lt;View android:id=&amp;quot;@+id/flexible_space&amp;quot;/&amp;gt;
  &amp;lt;Toolbar android:id=&amp;quot;@+id/toolbar&amp;quot;/&amp;gt;
  &amp;lt;RelativeLayout android:paddingLeft=&amp;quot;@dimen/toolbar_margin_start&amp;quot;&amp;gt;
    &amp;lt;TextView android:id=&amp;quot;@+id/title&amp;quot;/&amp;gt;
    &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
      &amp;lt;View android:layout_height=&amp;quot;?attr/actionBarSize&amp;quot;/&amp;gt;
      &amp;lt;View android:layout_height=&amp;quot;@dimen/flexible_space_height&amp;quot;/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
  &amp;lt;/RelativeLayout&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看过之前章节的话一定知道，根布局 FrameLayout 可以实现分别移动其子布局的功能。
第二个位于 ScrollView 中的 FrameLayout 布局 （&lt;code&gt;@id/body&lt;/code&gt;）是主要的内容布局，如果需要的话，可以换成任何你想要的布局。这里我们就用一个 TextView 来充当当前布局的内容。&lt;/p&gt;

&lt;p&gt;View（&lt;code&gt;@id/flexible_space&lt;/code&gt;）构成了一个背景不透明的弹性空白空间，在滚动时，该视图会随着Y轴坐标的改变而垂直滚动。&lt;/p&gt;

&lt;p&gt;Toolbar 只是一个普通的 Toolbar ，不过这个 Toolbar 没有设置标题。&lt;/p&gt;

&lt;p&gt;接下来的 RelativeLayout 和它的子布局比较复杂，首先，TextView（&lt;code&gt;@id/title&lt;/code&gt;） 才是真正的 &lt;code&gt;title view&lt;/code&gt; ，其他的布局（LinearLayout，view）都只是填充，因为在这个弹性空白的样式里，TextView 里面内容的字体大小（也就是标题的字体大小）会有所变化，所以它需要额外的空间。要达到这样的动画效果，可以使得 TextView 动画起来，因此其他的填充都应该在 TextView 的外面。&lt;/p&gt;

&lt;p&gt;想要了解其他的属性，可以自己在 app 里面查看相应的布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res/layout/activity_flexiblespacetoolbarscrollview.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;初始化开始，将 Toolbar 设置成为 ActionBar ，并让其显示返回（ &lt;code&gt;homeAsUp&lt;/code&gt; ）箭头。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_flexiblespacetoolbarscrollview);

  setSupportActionBar((Toolbar) findViewById(R.id.toolbar));
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到这个 Activity 的标题并将它设置到 ID 为 &lt;code&gt;@id/title&lt;/code&gt; 的 TextView。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mTitleView = (TextView) findViewById(R.id.title);
  mTitleView.setText(getTitle());
  setTitle(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后初始化其他的视图和属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private View mFlexibleSpaceView;
private View mToolbarView;
private TextView mTitleView;
private int mFlexibleSpaceHeight;

@Override
protected void onCreate(Bundle savedInstanceState) {
  // 省略前面已经说明过的代码
  mFlexibleSpaceView = findViewById(R.id.flexible_space);
  mToolbarView = findViewById(R.id.toolbar);

  final ObservableScrollView scrollView = (ObservableScrollView) findViewById(R.id.scroll);
  scrollView.setScrollViewCallbacks(this);

  mFlexibleSpaceHeight = getResources().getDimensionPixelSize(R.dimen.flexible_space_height);
  int flexibleSpaceAndToolbarHeight = mFlexibleSpaceHeight + getActionBarSize();

  findViewById(R.id.body).setPadding(0, flexibleSpaceAndToolbarHeight, 0, 0);
  mFlexibleSpaceView.getLayoutParams().height = flexibleSpaceAndToolbarHeight;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以在 Activity 的声明后面添加 &lt;code&gt;implements ObservableScrollViewCallbacks&lt;/code&gt; 来得到上面的方法。&lt;/p&gt;

&lt;h3 id=&#34;动画&#34;&gt;动画&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法产生需要的动画效果。我们必须要实现以下的代码：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;移动弹性空白空间&lt;/li&gt;
&lt;li&gt;移动并缩放标题（&lt;code&gt;title view&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;移动弹性空白空间&#34;&gt;移动弹性空白空间&lt;/h4&gt;

&lt;p&gt;实现起来较为简单，只需要用 &lt;code&gt;scrollY&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  ViewHelper.setTranslationY(mFlexibleSpaceView, -scrollY);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;缩放标题&#34;&gt;缩放标题&lt;/h3&gt;

&lt;p&gt;需要思考的问题是如何改变字体的大小？直接在布局修改字体的 &lt;code&gt;size&lt;/code&gt; 显然是不可以的，应该考虑用缩放的效果去实现字体大小的改变。&lt;/p&gt;

&lt;p&gt;缩放的值从 &lt;code&gt;1&lt;/code&gt; 变化到 &lt;code&gt;1.x&lt;/code&gt;，你可以改变这个 &lt;code&gt;.x&lt;/code&gt; 的值，来达到你想要的缩放效果。或者可以使用弹性空白和 Toolbar 的高度来计算出一个最大的缩放值，也就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float maxScale = (float) (mFlexibleSpaceHeight - mToolbarView.getHeight()) / mToolbarView.getHeight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缩放值（指的是 &lt;code&gt;.x&lt;/code&gt; 值）从 0 变化到最大值 &lt;code&gt;maxScale&lt;/code&gt;，可以这样来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 对scrollY的值进行限制
int adjustedScrollY = (int) ScrollUtils.getFloat(scrollY, 0, mFlexibleSpaceHeight);

// scrollY为0时，缩放值应该为最大
// scrollY达到mFlexibleSpaceHeight的值时，缩放值应该为0 
float scale = maxScale * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当缩放视图的时候，我们需要设置一个缩放的中心点，也就是 &lt;code&gt;pivotX&lt;/code&gt; 和 &lt;code&gt;pivotY&lt;/code&gt; 两个参数，应该设置为 &lt;code&gt;（0，0）&lt;/code&gt; 。默认的缩放点如下图左，设置后的缩放点如下图右：
&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/滚动中心点设置.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/滚动中心点设置.png&#34; alt=&#34;滚动中心点设置&#34; /&gt;&lt;/a&gt;
先设置缩放中心点，然后改变缩放值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 设置标题的缩放中心点 (0, 0)
ViewHelper.setPivotX(mTitleView, 0);
ViewHelper.setPivotY(mTitleView, 0);

// 缩放标题
ViewHelper.setScaleX(mTitleView, 1 + scale);
ViewHelper.setScaleY(mTitleView, 1 + scale);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动标题&#34;&gt;移动标题&lt;/h4&gt;

&lt;p&gt;移动标题的实现较为复杂，我们先看下图：
&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/计算TextView的最大值.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/05/计算TextView的最大值.png&#34; alt=&#34;计算TextView的最大值&#34; /&gt;&lt;/a&gt;
最小的 &lt;code&gt;translationY&lt;/code&gt; 明显应该为 0 ，需要思考的是如何得到最大的 &lt;code&gt;translationY&lt;/code&gt; 值，从图中可以看出，最大的 &lt;code&gt;translationY&lt;/code&gt; 可以由 &lt;code&gt;ht1 + hf - ht2&lt;/code&gt; 计算得出，所以代码应该这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxTitleTranslationY = mToolbarView.getHeight() + mFlexibleSpaceHeight - (int) (mTitleView.getHeight() * (1 + scale));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;scrollY&lt;/code&gt; 来改变这个值，&lt;code&gt;scrollY&lt;/code&gt; 应该被限定，并且早就被计算为 &lt;code&gt;adjustedScrollY&lt;/code&gt; 值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; int titleTranslationY = (int) (maxTitleTranslationY * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight);
  ViewHelper.setTranslationY(mTitleView, titleTranslationY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，将转换和缩放的代码完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  ViewHelper.setTranslationY(mFlexibleSpaceView, -scrollY);

  // 计算缩放值
  int adjustedScrollY = (int) ScrollUtils.getFloat(scrollY, 0, mFlexibleSpaceHeight);
  float maxScale = (float) (mFlexibleSpaceHeight - mToolbarView.getHeight()) / mToolbarView.getHeight();
  float scale = maxScale * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight;

  // 设置标题的缩放中心点 (0, 0)
  ViewHelper.setPivotX(mTitleView, 0);
  ViewHelper.setPivotY(mTitleView, 0);

  // 缩放标题
  ViewHelper.setScaleX(mTitleView, 1 + scale);
  ViewHelper.setScaleY(mTitleView, 1 + scale);

  // 移动标题
  int maxTitleTranslationY = mToolbarView.getHeight() + mFlexibleSpaceHeight - (int) (mTitleView.getHeight() * (1 + scale));
  int titleTranslationY = (int) (maxTitleTranslationY * ((float) mFlexibleSpaceHeight - adjustedScrollY) / mFlexibleSpaceHeight);
  ViewHelper.setTranslationY(mTitleView, titleTranslationY);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;调整-title-的初始状态&#34;&gt;调整 &lt;code&gt;title&lt;/code&gt; 的初始状态&lt;/h4&gt;

&lt;p&gt;也许你会注意到，当页面初始启动的时候，标题会固定在屏幕的顶部，而我们需要的应该是一开始就让它呆在头部视图的最下面，并且应该是最大的字体。&lt;/p&gt;

&lt;p&gt;出现这样的情况是因为在刚开始进入页面时，&lt;code&gt;onScrollChanged()&lt;/code&gt; 方法不会被调用，如果要改善，方法是在布局好 view 后立即调用 &lt;code&gt;onScrollChanged()&lt;/code&gt;。你也可以通过使用 &lt;code&gt;ViewTreeObserver#addOnGlobalLayoutListener()&lt;/code&gt; 处理这种布局方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
  // 其他的初始化代码省略
  ViewTreeObserver vto = mTitleView.getViewTreeObserver();
  vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
      if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.JELLY_BEAN) {
        view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
      } else {
        view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
      }
      updateFlexibleSpaceText(scrollView.getCurrentScrollY());
    }
  });
}

@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  updateFlexibleSpaceText(scrollY);
}

private void updateFlexibleSpaceText(scrollY) {
  // 省略原始动画代码
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将下面的 &lt;code&gt;ViewTreeObserver&lt;/code&gt; 代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewTreeObserver vto = mTitleView.getViewTreeObserver();
vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
  @Override
  public void onGlobalLayout() {
    if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.JELLY_BEAN) {
      view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
    } else {
      view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
    }
    updateFlexibleSpaceText(scrollView.getCurrentScrollY());
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ScrollUtils.addOnGlobalLayoutListener(mTitleView, new Runnable() {
  @Override
  public void run() {
    updateFlexibleSpaceText(scrollView.getCurrentScrollY());
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成了整个弹性空白效果的实现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— 使用图像的弹性空白布局</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/pictureblank/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/pictureblank/</guid>
      <description>

&lt;p&gt;这一节主要说明了使用图像来实现弹性空白布局，并给出在各个 View 上如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FlexibleSpaceWithImageListViewActivity&lt;/li&gt;
&lt;li&gt;FlexibleSpaceWithImageRecyclerViewActivity&lt;/li&gt;
&lt;li&gt;FlexibleSpaceWithImageScrollViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想要更好的读懂本节文章，请先阅读：&lt;a href=&#34;http://blog.qiji.tech/archives/10525&#34;&gt;[Android] ObservableScrollView分析（六）—— Toolbar上的弹性空白&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;scrollview-实现弹性空白&#34;&gt;ScrollView 实现弹性空白&lt;/h2&gt;

&lt;h3 id=&#34;scrollview-布局&#34;&gt;ScrollView 布局&lt;/h3&gt;

&lt;h4 id=&#34;基本结构&#34;&gt;基本结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
    &amp;lt;ImageView android:id=&amp;quot;@+id/image&amp;quot;/&amp;gt;
    &amp;lt;View android:id=&amp;quot;@+id/overlay&amp;quot;/&amp;gt;
    &amp;lt;ObservableScrollView android:id=&amp;quot;@+id/scroll&amp;quot;&amp;gt;
        &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
            &amp;lt;View/&amp;gt;
            &amp;lt;TextView/&amp;gt;
        &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;/ObservableScrollView&amp;gt;
    &amp;lt;LinearLayout android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;
        &amp;lt;TextView android:id=&amp;quot;@+id/title&amp;quot;/&amp;gt;
        &amp;lt;View/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;FloatingActionButton android:id=&amp;quot;@+id/fab&amp;quot;/&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根布局 FrameLayout 可以实现分别移动其子布局的功能。&lt;/p&gt;

&lt;p&gt;ImageView (&lt;code&gt;@id/image&lt;/code&gt;) 布局里放的是在移动时会产生视差效果的图片。&lt;/p&gt;

&lt;p&gt;View (&lt;code&gt;@id/overlay&lt;/code&gt;) 如同它的id名一样，是用来覆盖 ImageView 的一个视图。打开 &lt;code&gt;demo app&lt;/code&gt; 中的这个Activity （&lt;code&gt;FlexibleSpaceWithImageScrollViewActivity&lt;/code&gt;），滑动一下，你会发现图片会产生一种淡入淡出的效果，产生这个效果的原因就是覆盖在 ImageView 上面的 View 会随着滑动位置的改变而改变其不透明度。&lt;/p&gt;

&lt;p&gt;LinearLayout 及其子布局，是整个布局中真正的标题布局。这样的布局在上一节中也出现了，所以不再赘述。&lt;/p&gt;

&lt;p&gt;FloatingActionButton 是从 &lt;code&gt;FloatingActionButton&lt;/code&gt; 库中导入的一个简单又炫酷的小控件。
这个控件是可选项，如果你不需要它，可以将它移除。demo app 中放入这个控件是因为它是一个非常典型的遵循 Material Design 风格的控件，也许你们会喜欢。&lt;/p&gt;

&lt;p&gt;想要了解其他的属性，可以自己在 &lt;code&gt;demo app&lt;/code&gt; 里面查看相应的布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res/layout/activity_flexiblespacewithimagescrollview.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;省略掉那些简单的，或者跟本节无关的代码后，只放上相关的初始化代码：&lt;/p&gt;

&lt;p&gt;将 &lt;code&gt;title&lt;/code&gt; 的值赋给真正的 &lt;code&gt;title view&lt;/code&gt;（TextView），然后给原来的 &lt;code&gt;title&lt;/code&gt; 赋值为 &lt;code&gt;null&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mTitleView.setText(getTitle());
setTitle(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到资源文件中的尺寸信息，并将它们赋给相应的属性值（这样可以简化动画部分的代码）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mFlexibleSpaceImageHeight = getResources().getDimensionPixelSize(R.dimen.flexible_space_image_height);
mFlexibleSpaceShowFabOffset = getResources().getDimensionPixelSize(R.dimen.flexible_space_show_fab_offset);
mFabMargin = getResources().getDimensionPixelSize(R.dimen.margin_standard);
mActionBarSize = getActionBarSize();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到布局视图，并将它们赋给相应的属性值（这样可以简化动画部分的代码）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mImageView = findViewById(R.id.image);
mOverlayView = findViewById(R.id.overlay);
mScrollView = (ObservableScrollView) findViewById(R.id.scroll);
mScrollView.setScrollViewCallbacks(this);
mTitleView = (TextView) findViewById(R.id.title);
mFab = findViewById(R.id.fab);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管跟滚动动画的实现可能没什么关系，还是需要在 &lt;code&gt;onCreate（）&lt;/code&gt; 方法中将 floating action button (FAB) 的缩放值设置为 0，因为我们想要在一开始的时候将它隐藏，随着滚动慢慢增加缩放值从而让它显示出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setScaleX(mFab, 0);
ViewHelper.setScaleY(mFab, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有必要给这个 Activity 添加上接口 &lt;code&gt;implements ObservableScrollViewCallbacks&lt;/code&gt; 并将这些方法都实现。&lt;/p&gt;

&lt;h3 id=&#34;动画&#34;&gt;动画&lt;/h3&gt;

&lt;p&gt;用 &lt;code&gt;onScrollChanged()&lt;/code&gt; 方法来产生需要的动画
为了达到这个目标，需要实现以下的代码：
- 移动图像视图和它上面的覆盖视图
- 改变覆盖视图的 &lt;code&gt;alpha&lt;/code&gt; 值
- 移动并缩放 &lt;code&gt;title view&lt;/code&gt;
- 移动 FAB
- 显示/隐藏 FAB&lt;/p&gt;

&lt;h4 id=&#34;移动图像视图和它上面的覆盖视图&#34;&gt;移动图像视图和它上面的覆盖视图&lt;/h4&gt;

&lt;p&gt;参考上一节的内容，想要移动位于 ScrollView 外面的 ImageView 视图，需要使用参数 &lt;code&gt;-scrollY&lt;/code&gt; 并且将它除以 2 来产生视差效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  float flexibleRange = mFlexibleSpaceImageHeight - mActionBarSize;
  int minOverlayTransitionY = mActionBarSize - mOverlayView.getHeight();
  ViewHelper.setTranslationY(mOverlayView, ScrollUtils.getFloat(-scrollY, minOverlayTransitionY, 0));
  ViewHelper.setTranslationY(mImageView, ScrollUtils.getFloat(-scrollY / 2, minOverlayTransitionY, 0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使希望让覆盖图层随着图像一起移动，也不需要让覆盖图层跟着图像用一样的速度移动，所以可以把覆盖图像的移动设置为 &lt;code&gt;-scrollY&lt;/code&gt; 而非 &lt;code&gt;-scrollY/2&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;改变覆盖视图的-alpha-值&#34;&gt;改变覆盖视图的 &lt;code&gt;alpha&lt;/code&gt; 值&lt;/h4&gt;

&lt;p&gt;计算 &lt;code&gt;alpha&lt;/code&gt; 的值，只需要将 &lt;code&gt;scrollY&lt;/code&gt; 转换一下，让它在滚动的过程中 &lt;code&gt;alpha&lt;/code&gt; 值能从 0 变到 1。具体的操作是用 &lt;code&gt;scrollY&lt;/code&gt; 除以 &lt;code&gt;flexibleRange&lt;/code&gt;（这个值已经在上面初始化过了），同时用工具类的方法 &lt;code&gt;ScrollUtils.getFloat()&lt;/code&gt; 将它限定在 0 到 1 之间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ViewHelper.setAlpha(mOverlayView, ScrollUtils.getFloat((float) scrollY / flexibleRange, 0, 1));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动并缩放-title-view&#34;&gt;移动并缩放 &lt;code&gt;title view&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;跟上一节的做法基本上一样，不同的地方只是如何去计算缩放值以及 &lt;code&gt;translationY&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  // 省略了上面已经解释过的代码

  float scale = 1 + ScrollUtils.getFloat((flexibleRange - scrollY) / flexibleRange, 0, MAX_TEXT_SCALE_DELTA);
  ViewHelper.setPivotX(mTitleView, 0);
  ViewHelper.setPivotY(mTitleView, 0);
  ViewHelper.setScaleX(mTitleView, scale);
  ViewHelper.setScaleY(mTitleView, scale);

  int maxTitleTranslationY = (int) (mFlexibleSpaceImageHeight - mTitleView.getHeight() * scale);
  int titleTranslationY = maxTitleTranslationY - scrollY;
  ViewHelper.setTranslationY(mTitleView, titleTranslationY);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动fab&#34;&gt;移动FAB&lt;/h4&gt;

&lt;p&gt;基本思想是改变 FAB 的 &lt;code&gt;translationY&lt;/code&gt; 参数，然而在 &lt;code&gt;pre-Honeycomb&lt;/code&gt; 的设备上，当你用 &lt;code&gt;setOnClickListener（）&lt;/code&gt; 方法时可能不会起作用，为了解决这个问题，可以通过设置 FrameLayout 的 &lt;code&gt;margin&lt;/code&gt; 值，然后调用 &lt;code&gt;requestLayout（）&lt;/code&gt; 再次布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  // 省略了上面已经解释过的代码

  int maxFabTranslationY = mFlexibleSpaceImageHeight - mFab.getHeight() / 2;
  float fabTranslationY = ScrollUtils.getFloat(
      -scrollY + mFlexibleSpaceImageHeight - mFab.getHeight() / 2,
      mActionBarSize - mFab.getHeight() / 2,
      maxFabTranslationY);
  if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.HONEYCOMB) {
    FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mFab.getLayoutParams();
    lp.leftMargin = mOverlayView.getWidth() - mFabMargin - mFab.getWidth();
    lp.topMargin = (int) fabTranslationY;
    mFab.requestLayout();
  } else {
    ViewHelper.setTranslationX(mFab, mOverlayView.getWidth() - mFabMargin - mFab.getWidth());
    ViewHelper.setTranslationY(mFab, fabTranslationY);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算 &lt;code&gt;maxFabTranslationY&lt;/code&gt; 的表达式 &lt;code&gt;- mFab.getHeight() / 2&lt;/code&gt; 表明有一半高度的 FAB 会覆盖在图片的上方，有一个层叠的效果。&lt;/p&gt;

&lt;p&gt;也许你会认为 &lt;code&gt;fabTranslationY&lt;/code&gt; 值的计算表达式 &lt;code&gt;mActionBarSize - mFab.getHeight() / 2&lt;/code&gt; 的最小值可能没有意义，但是当你快速滚动视图的时候，这个最小值的计算是需要的，如果滚动速度快过了 FAB 缩放值变为 0 的速度，FAB 看起来就好像是突然消失了一样。&lt;/p&gt;

&lt;h4 id=&#34;显示-隐藏-fab&#34;&gt;显示/隐藏 FAB&lt;/h4&gt;

&lt;p&gt;显示或者隐藏 FAB 的效果比较简单，如果 FAB 的移动距离超过了某个阈值，就将它隐藏，否则，就显示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  // 省略了上面已经解释过的代码

  if (fabTranslationY &amp;lt; mFlexibleSpaceShowFabOffset) {
    hideFab();
  } else {
    showFab();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要自己将 &lt;code&gt;hideFab（）&lt;/code&gt; 和 &lt;code&gt;showFab（）&lt;/code&gt; 方法的代码完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean mFabIsShown;

  private void showFab() {
    if (!mFabIsShown) {
      ViewPropertyAnimator.animate(mFab).cancel();
      ViewPropertyAnimator.animate(mFab).scaleX(1).scaleY(1).setDuration(200).start();
      mFabIsShown = true;
    }
  }

  private void hideFab() {
    if (mFabIsShown) {
      ViewPropertyAnimator.animate(mFab).cancel();
      ViewPropertyAnimator.animate(mFab).scaleX(0).scaleY(0).setDuration(200).start();
      mFabIsShown = false;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义了一个状态变量来表明 FAB 目前是否显示。&lt;/p&gt;

&lt;p&gt;到这里就完成了整个图像弹性空白的布局。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;一个 view 的动画效果，也许刚开始看起来很复杂，但是，只要能搞清楚它的布局层次，将动画拆分成若干个子动画，并找到每个布局层次在坐标改变的时候对应的移动规律，就能够理解整个动画效果背后的玄机。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— 显示/隐藏 Toolbar</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/toolbar/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/toolbar/</guid>
      <description>&lt;p&gt;#Toolbar的显示/隐藏&lt;/p&gt;

&lt;p&gt;这一节描述了如何处理 ObservableScrollView 关于Toolbar 的显示/隐藏，并给出在各个 View 上是如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ToolbarControlBaseActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlGridViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlListViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlRecyclerViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlScrollViewActivity&lt;/li&gt;
&lt;li&gt;ToolbarControlWebViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Toolbar 有关的文章如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/archives/6058&#34;&gt;Android:Toolbar使用心得&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tuicool.com/articles/7BJBZb&#34;&gt;android：Toolbar详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Toolbar 在 Android 5.0 中被引进，如果你需要在更低版本中使用这个控件的话，需要使用 v7 appcompat library 兼容包。&lt;/p&gt;

&lt;p&gt;#创建布局文件&lt;/p&gt;

&lt;p&gt;我们在布局中使用 ObservableListView 和 Toolbar，并将布局放入 FrameLayout 中，FrameLayout 和 RelativeLayout 这两个布局比较擅长用来转换它们内部的单独布局。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
android:layout_width=&amp;quot;match_parent&amp;quot;
android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

&amp;lt;android.support.v7.widget.Toolbar
android:id=&amp;quot;@+id/toolbar&amp;quot;
android:layout_width=&amp;quot;match_parent&amp;quot;
android:layout_height=&amp;quot;wrap_content&amp;quot;
android:background=&amp;quot;?attr/colorPrimary&amp;quot;
android:minHeight=&amp;quot;?attr/actionBarSize&amp;quot;
app:popupTheme=&amp;quot;@style/Theme.AppCompat.Light.DarkActionBar&amp;quot;
app:theme=&amp;quot;@style/Toolbar&amp;quot; /&amp;gt;

&amp;lt;com.github.ksoichiro.android.observablescrollview.ObservableListView
android:id=&amp;quot;@+id/scrollable&amp;quot;
android:layout_width=&amp;quot;match_parent&amp;quot;
android:layout_height=&amp;quot;match_parent&amp;quot;
android:layout_marginTop=&amp;quot;?attr/actionBarSize&amp;quot; /&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#如何显示/隐藏Toolbar&lt;/p&gt;

&lt;p&gt;参考上一节内容，我们可以考虑像显示/隐藏 ActionBar 那样来处理对 Toolbar 的显示/隐藏转换，然而，Toolbar 类却并没有 ActionBar 中的 show 方法和 hide 方法。因此，我们应该自己去完成类似的方法，从而做到 Toolbar 的显示/隐藏，初步设想如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onUpOrCancelMotionEvent(ScrollState scrollState) {
if (scrollState == ScrollState.UP) {
if (toolbarIsShown()) {   // 需要完成方法
hideToolbar(); // 需要完成方法
}
} else if (scrollState == ScrollState.DOWN) {
if (toolbarIsHidden()) { // 需要完成方法
showToolbar(); // 需要完成方法
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们开始完成方法前，应该确认一下，是否还要支持Honeycomb（API Level 11）之前的设备，因为我们可能需要使用一些合适的动画接口，这些接口可能不再支持上述设备。&lt;/p&gt;

&lt;p&gt;如果你需要兼容，可以用 NineOldAndroids 这个动画开源库，由于 View 的属性动画在 Android API 11 及其以后才支持，该库的作用就是让 API 11 以下的系统也能够正常的使用属性动画。&lt;/p&gt;

&lt;p&gt;在这个项目里面，我们使用的就是这个动画库，如果你不打算兼容 API 11 以下的设备，请将 ViewHelper.methodName(viewObject) 换成  viewObject.methodName()，否则可能无法正常运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NineOldAndroids: ViewHelper.getTranslationY(mToolbar)
Platform API:    mToolbar.getTranslationY()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你使用 NineOldAndroids 开源库，需要在 build.grade 中加入依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
compile &#39;com.nineoldandroids:library:2.4.0&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们来写我们需要实现的方法。为了避免冗余的显示隐藏转换，我们需要判断一下 Toolbar 现在的状态，是否出现或者隐藏。使用合适的动画接口（或者NineOldAndroids）我们只需要判断 translationY 的值就可以知道 Toolbar 此时的状态了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean toolbarIsShown() {
// Toolbar 在Y轴坐标为0，也就是正在显示
return ViewHelper.getTranslationY(mToolbar) == 0;
}

private boolean toolbarIsHidden() {
// Toolbar 在屏幕外，并且Y坐标的绝对值等于它的高度，也就是正在隐藏
return ViewHelper.getTranslationY(mToolbar) == -mToolbar.getHeight();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断完状态后，接下来就可以完善我们自己定义的 show 和 hide 方法代码了，先写好伪代码来简化问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void showToolbar() {
moveToolbar(0);
}

private void hideToolbar() {
moveToolbar(-mToolbar.getHeight());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们完成了 moveToolbar 方法，那么应该就可以就可以实现 Toolbar 的显示转换了。&lt;/p&gt;

&lt;p&gt;大部分的动画代码都跟属性值的计算相结合，如何正确的计算是一个非常关键的问题，虽然我们将方法命名为 moveToolbar，还需要注意一点，那就是在上一节中，不仅 ActionBar 移动了，view（Observable*View）的高度也改变了，我们需要把这一个功能也实现出来。&lt;/p&gt;

&lt;p&gt;为了使用改变的属性值，我们可以使用  ValueAnimator，它有一个回调方法叫  onAnimationUpdate，我们可以在这个方法里面得到动画的进度。ValueAnimator 自身不会有动画发生，我们需要使用一个变量来让动画实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ValueAnimator animator = ValueAnimator.ofFloat(0, 100).setDuration(200);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
@Override
public void onAnimationUpdate(ValueAnimator animation) {
float value = (float) animation.getAnimatedValue();
// 这里可以对 value 值做任何事情
}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，本地变量 value 在 200ms 内从 0f 变到 100f，在这种情况下，我们应该将 Toolbar 的 translationY 属性改变，并且将Observable*View高度也改变一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void moveToolbar(float toTranslationY) {
ValueAnimator animator = ValueAnimator.ofFloat(ViewHelper.getTranslationY(mToolbar), toTranslationY).setDuration(200);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
@Override
public void onAnimationUpdate(ValueAnimator animation) {
float translationY = (float) animation.getAnimatedValue();
ViewHelper.setTranslationY(mToolbar, translationY);
ViewHelper.setTranslationY((View) mScrollable, translationY);
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) ((View) mScrollable).getLayoutParams();
lp.height = (int) -translationY + getScreenHeight() - lp.topMargin;
((View) mScrollable).requestLayout();
}
});
animator.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;translationY从 ViewHelper.getTranslationY(mToolbar)( 等于current translationY) 变到了 toTranslationY，
为了显示隐藏 Toolbar 的，我们只需要调用ViewHelper.setTranslationY()。要改变最外层布局（FrameLayout）的高度，设置  FrameLayout.LayoutParams 参数，并通过调用requestLayout() 方法来更新。&lt;/p&gt;

&lt;p&gt;最好检查一下目前的 translationY 值，看是否已经等于 toTranslationY，如果是，就停止动画更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void moveToolbar(float toTranslationY) {
// 检查当前Y坐标
if (ViewHelper.getTranslationY(mToolbar) == toTranslationY) {
return;
}
// 省略……
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ObservableScrollView分析 —— 视差图像 Parallax image 实现</title>
      <link>http://chiakimayuzumi.github.io/thirdlib/parallax/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/thirdlib/parallax/</guid>
      <description>

&lt;p&gt;这一节主要说明了如何在滚动视图中产生图像的视差效果，并给出在各个 View 上是如何应用的实例，主要实例有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ParallaxToolbarScrollViewActivity&lt;/li&gt;
&lt;li&gt;ParallaxToolbarListViewActivity&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;h2 id=&#34;什么是视差滚动&#34;&gt;什么是视差滚动&lt;/h2&gt;

&lt;p&gt;视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。&lt;/p&gt;

&lt;p&gt;说的简单点就是界面元素在滚动屏幕时发生的位置的变化，然而各个不同的元素位置变化的速度不同，导致界面内的元素有层次错落的错觉，这和我们人体的眼球效果很像。&lt;/p&gt;

&lt;p&gt;视差滚动效果已经广泛运用到许多 app 中，起到了非常不错的效果。&lt;/p&gt;

&lt;h2 id=&#34;视差效果&#34;&gt;视差效果&lt;/h2&gt;

&lt;p&gt;本节中讨论的视差效果，指的是具有如下行为的布局：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;布局上有一张图像&lt;/li&gt;
&lt;li&gt;图像会随着 ScrollView 的滚动而滚动，然而速度减半&lt;/li&gt;
&lt;li&gt;ScrollView 自带&lt;code&gt;padding&lt;/code&gt;，形成观看图片的一个窗口。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了让图像产生视差效果，我们需要在布局上使用一点技巧。&lt;/p&gt;

&lt;p&gt;ObservableScrollView 和 ObservableListView 在处理填充的地方有一些区别，因此我们需要分开来看。&lt;/p&gt;

&lt;h1 id=&#34;scrollview&#34;&gt;ScrollView&lt;/h1&gt;

&lt;h2 id=&#34;布局&#34;&gt;布局&lt;/h2&gt;

&lt;h3 id=&#34;基本结构&#34;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;首先，如下是布局的基本结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ObservableScrollView&amp;gt;
    &amp;lt;RelativeLayout&amp;gt;
      &amp;lt;ImageView/&amp;gt;
      &amp;lt;View/&amp;gt;
      &amp;lt;TextView/&amp;gt;
    &amp;lt;/RelativeLayout&amp;gt;
  &amp;lt;/ObservableScrollView&amp;gt;
  &amp;lt;Toolbar/&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了阅读方便，这里有意地省略了属性（&lt;code&gt;android:XXX&lt;/code&gt;）和包名（&lt;code&gt;com.github.XXX&lt;/code&gt;）&lt;/p&gt;

&lt;h3 id=&#34;为什么要使用-framelayout&#34;&gt;为什么要使用 FrameLayout？&lt;/h3&gt;

&lt;p&gt;我们可以在示例 app 上看到，Toolbar 是覆盖在 ObservableScrollView 之上的，为了得到这样的效果，我们需要使用 FrameLayout 或者 RelativeLayout。&lt;/p&gt;

&lt;h3 id=&#34;observablescrollview里有什么&#34;&gt;ObservableScrollView里有什么？&lt;/h3&gt;

&lt;p&gt;ObservableScrollView 继承自 ScrollView，因此它最多只能有一个子类，然而我们需要多个子类来实现视差滚动效果，因此，需要将一个 ViewGroup 作为ObservableScrollView 的子类，再在这个 ViewGroup 里面放更多的子类布局（上面的布局中，这个子类 ViewGroup 就是 RelativeLayout ）。&lt;/p&gt;

&lt;p&gt;ImageView 是将要产生视差效果的 View，如果有需要也可以用其他的View代替。&lt;/p&gt;

&lt;p&gt;TextView 是屏幕的主要内容，它也可以用其他的 View 代替。&lt;/p&gt;

&lt;p&gt;ImagaeView 和 TextView 中间的 View 是一个锚点（&lt;code&gt;anchor&lt;/code&gt;），在后续内容中将解释为什么有这个锚点view 的存在。&lt;/p&gt;

&lt;p&gt;我们需要分开移动图像和内容，因此，它们的父类，也就是 ObservableScrollView 的子类，应该是一个&lt;code&gt;FrameLayout&lt;/code&gt; 或者&lt;code&gt;RelativeLayout&lt;/code&gt;，这一次我们使用 &lt;code&gt;RelativeLayout&lt;/code&gt; 来实现。&lt;/p&gt;

&lt;h3 id=&#34;父类移动时不要移动子类内容&#34;&gt;父类移动时不要移动子类内容&lt;/h3&gt;

&lt;p&gt;我们如何将 ScrollView 中的主要内容（这里是一个TextView）放在图像布局的下方？&lt;/p&gt;

&lt;p&gt;如果我们使用&lt;code&gt;android:layout_below&lt;/code&gt;属性来写的话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 这里省略了一些属性 --&amp;gt;
&amp;lt;RelativeLayout&amp;gt;
  &amp;lt;ImageView android:id=&amp;quot;@+id/image&amp;quot;&amp;gt;
  &amp;lt;TextView android:layout_below=&amp;quot;@id/image&amp;quot;&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的话，TextView 会跟 ImageView 保持相同的滚动速度，因为它的布局采用&lt;code&gt;android:layout_below=&amp;quot;@id/image”&lt;/code&gt; 来定义，因此我们需要使用另外的一个 &lt;code&gt;anchor view&lt;/code&gt;（锚点视图）来定义 TextView 的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 这里省略了一些属性 --&amp;gt;
&amp;lt;RelativeLayout&amp;gt;
  &amp;lt;ImageView android:id=&amp;quot;@+id/image&amp;quot;
             android:layout_height=&amp;quot;@dimen/parallax_image_height&amp;quot;&amp;gt;
  &amp;lt;View android:id=&amp;quot;@+id/anchor&amp;quot;
        android:layout_height=&amp;quot;@dimen/parallax_image_height&amp;quot;
        android:minHeight=&amp;quot;@dimen/parallax_image_height&amp;quot; /&amp;gt;
  &amp;lt;TextView android:layout_below=&amp;quot;@id/anchor&amp;quot;&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用了这个&lt;code&gt;anchor view&lt;/code&gt; 后，我们就可以单独移动ImageView了，&lt;code&gt;anchor view&lt;/code&gt; 和 TextView 会留在它们的位置上。&lt;/p&gt;

&lt;h3 id=&#34;明确设置-toolbar-内容的背景色&#34;&gt;明确设置 Toolbar 内容的背景色&lt;/h3&gt;

&lt;p&gt;我们需要为 Toolbar 上的内容明确地设置一个颜色，因为这个内容是在图片上方显示出来的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;TextView android:layout_below=&amp;quot;@id/anchor&amp;quot;
  android:background=&amp;quot;@android:color/white&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;完成整个布局&#34;&gt;完成整个布局&lt;/h3&gt;

&lt;p&gt;现在只需要设置布局的其他属性即可，例如&lt;code&gt;android:layout_width&lt;/code&gt;, &lt;code&gt;android:padding&lt;/code&gt;等等，可以在以下布局文件中查看详细的设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;res/layout/activity_parallaxtoolbarscrollview.java&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;动画效果&#34;&gt;动画效果&lt;/h2&gt;

&lt;h3 id=&#34;activity-的基本结构&#34;&gt;Activity 的基本结构&lt;/h3&gt;

&lt;p&gt;Activity 继承自v7兼容包，并且实现 &lt;code&gt;ObservableScrollViewCallbacks&lt;/code&gt; 接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ParallaxToolbarScrollViewActivity
  extends AppCompatActivity implements ObservableScrollViewCallbacks 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化-views&#34;&gt;初始化 views&lt;/h3&gt;

&lt;p&gt;然后像这样初始化 views：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private View mImageView;
private View mToolbarView;
private ObservableScrollView mScrollView;
private int mParallaxImageHeight;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_parallaxtoolbarscrollview);

  setSupportActionBar((Toolbar) findViewById(R.id.toolbar));

  mImageView = findViewById(R.id.image);
  mToolbarView = findViewById(R.id.toolbar);
  mToolbarView.setBackgroundColor(
    ScrollUtils.getColorWithAlpha(0, getResources().getColor(R.color.primary)));

  mScrollView = (ObservableScrollView) findViewById(R.id.scroll);
  mScrollView.setScrollViewCallbacks(this);

  mParallaxImageHeight = getResources().getDimensionPixelSize(
    R.dimen.parallax_image_height);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化时，Toolbar 应该是透明的，所以用&lt;code&gt;ScrollUtils&lt;/code&gt; 工具类来设置背景色的 &lt;code&gt;alpha&lt;/code&gt; 值为0，这一步是可选步骤，如果你不使用 Toolbar 的话可以忽略这个步骤。&lt;/p&gt;

&lt;h3 id=&#34;滚动时改变位置&#34;&gt;滚动时改变位置&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;ObservableScrollViewCallbacks&lt;/code&gt; 接口中的方法之一：&lt;code&gt;onScrollChanged()&lt;/code&gt; 来使图像产生动画，在这个方法里我们需要做以下事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;scrollY&lt;/code&gt; 参量改变 ImageView 在Y轴的位置&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;scrollY&lt;/code&gt; 参量改变 Toolbar 背景色的 &lt;code&gt;alpha&lt;/code&gt; 值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;改变-imageview-位置&#34;&gt;改变 ImageView 位置&lt;/h3&gt;

&lt;p&gt;只需要设置 &lt;code&gt;translateY&lt;/code&gt; 属性为一半的 &lt;code&gt;scrollY&lt;/code&gt; 即可，如果你想要改变视差效果的程度，调整不同的值（&lt;code&gt;scrollY/2&lt;/code&gt;）可即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  ViewHelper.setTranslationY(mImageView, scrollY / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;改变-toolbar-背景色的-alpha-值&#34;&gt;改变 Toolbar 背景色的 &lt;code&gt;alpha&lt;/code&gt; 值&lt;/h3&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  int baseColor = getResources().getColor(R.color.primary);
  float alpha = 0; // 待设置的alpha
  mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(alpha, baseColor));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变 &lt;code&gt;alpha&lt;/code&gt; 值有一点复杂，所以先暂时先写做 float alpha = 0。 接下来需要确认颜色的具体应用状况，完善&lt;code&gt;alpha&lt;/code&gt;的值： - 如果 ObservableScrollView 没有发生过滚动，Toolbar 是透明的。（当 &lt;code&gt;scrollY&lt;/code&gt; 等于0时, Toolbar 的&lt;code&gt;alpha&lt;/code&gt;值为0） - 如果 ObservableScrollView 发生了滚动， Toolbar 开始渐渐变得不透明，当滚动到一个特定的点，变得完全不透明。（当 scrollY 等于 mParallaxImageHeight 时, Toolbar 的 &lt;code&gt;alpha&lt;/code&gt; 值为1） 我们需要将上述情况描述成一个公式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alpha&lt;/code&gt; 值应该从0变到1，但是 &lt;code&gt;scrollY&lt;/code&gt; 值却从0变到上千，所以 &lt;code&gt;scrollY&lt;/code&gt; 应该被测量，我们用 &lt;code&gt;scrollY&lt;/code&gt; 除以 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 的值来设定 &lt;code&gt;alpha&lt;/code&gt; 值，因为当 &lt;code&gt;alpha&lt;/code&gt; 变成1时，&lt;code&gt;scrollY&lt;/code&gt; 应该跟 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 值相等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float alpha = (float) scrollY / mParallaxImageHeight;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;scrollY&lt;/code&gt; 和 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 均为int类型，需要转换为 float 类型。 但是，当 &lt;code&gt;scrollY&lt;/code&gt;值超过 &lt;code&gt;mParallaxImageHeight&lt;/code&gt; 后应该怎么办？&lt;/p&gt;

&lt;p&gt;我们可以&lt;code&gt;Math.min（）&lt;/code&gt;来限制 &lt;code&gt;alpha&lt;/code&gt;的值最大只能为1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float alpha = Math.min(1, (float) scrollY / mParallaxImageHeight);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就好了，onScrollChanged 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
  int baseColor = getResources().getColor(R.color.primary);
  float alpha = Math.min(1, (float) scrollY / mParallaxImageHeight);
  mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(alpha, baseColor));
  ViewHelper.setTranslationY(mImageView, scrollY / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;恢复滚动状态&#34;&gt;恢复滚动状态&lt;/h3&gt;

&lt;p&gt;我们还需要考虑一个事情，当 Activity 恢复时，我们需要恢复滚动状态的设置， ObservableScrollView 自身会存储它的滚动位置，只需要在 &lt;code&gt;onRestoreInstanceState（）&lt;/code&gt;方法中更新 view 即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
  super.onRestoreInstanceState(savedInstanceState);
  onScrollChanged(mScrollView.getCurrentScrollY(), false, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;listview&#34;&gt;ListView&lt;/h1&gt;

&lt;h2 id=&#34;布局-1&#34;&gt;布局&lt;/h2&gt;

&lt;h3 id=&#34;基本结构-1&#34;&gt;基本结构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FrameLayout&amp;gt;
  &amp;lt;ImageView/&amp;gt;
  &amp;lt;View/&amp;gt;
  &amp;lt;ObservableListView/&amp;gt;
  &amp;lt;Toolbar/&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟 ScrollView 一样，我们用 FrameLayout 作为根布局，因为它可以分别移动该布局下的子 view。&lt;/p&gt;

&lt;p&gt;ImageView 是我们应该用来产生视差效果的视图。&lt;/p&gt;

&lt;p&gt;下一个视图跟 ScrollView 中的用法就不太一样了。&lt;/p&gt;

&lt;h3 id=&#34;为什么用不一样的布局&#34;&gt;为什么用不一样的布局？&lt;/h3&gt;

&lt;p&gt;跟 ScrollView 不同的是，ListView 不能拥有子视图，因此 ImageView 应该在 ListView 的外面，并且我们应该手动实现 ImageView 的移动。&lt;/p&gt;

&lt;h3 id=&#34;如何放置-imageview-和-listview&#34;&gt;如何放置 ImageView 和 ListView？&lt;/h3&gt;

&lt;p&gt;ImageView 要比 ListView 滚动得更慢，所以 ImageView 应该在 ListView 的下方，不然的话， ImageView 的底部就会盖住 ListView 的顶部。 同时，ListView 顶部应该有一个巨大的 padding 用来显示 ImageView。我们可以通过给 ListView 添加一个透明的 header view 来达到这个目的。&lt;/p&gt;

&lt;h3 id=&#34;为什么需要这个透明的-view&#34;&gt;为什么需要这个透明的 view&lt;/h3&gt;

&lt;p&gt;就像我在上面说过的，ListView 应该有一个透明的header，因此背景色应该也是透明的，但是如果我们仅仅把背景设置成透明，这样做不仅 header 透明了，ListView 中的 item 也会变成透明的。为了避免这种情况，我们可以在 ListView下 面设置一个假的背景 view 。&lt;/p&gt;

&lt;h2 id=&#34;动画&#34;&gt;动画&lt;/h2&gt;

&lt;h3 id=&#34;activity的基本结构&#34;&gt;Activity的基本结构&lt;/h3&gt;

&lt;p&gt;跟 ParallaxToolbarScrollViewActivity 一样的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ParallaxToolbarListViewActivity
  extends BaseActivity implements ObservableScrollViewCallbacks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化视图&#34;&gt;初始化视图&lt;/h3&gt;

&lt;p&gt;跟 ScrollView 一样，初始化 ObservableListView, ImageView, Toolbar等，需要注意的是 ListView 应该有一个 header view：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private View mImageView;
private View mToolbarView;
private View mListBackgroundView;
private ObservableListView mListView;
private int mParallaxImageHeight;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_parallaxtoolbarlistview) ;

  setSupportActionBar((Toolbar) findViewById(R.id.toolbar));

  mImageView = findViewById(R.id.image);
  mToolbarView = findViewById(R.id.toolbar);
  mToolbarView.setBackgroundColor(ScrollUtils.getColorWithAlpha(0, getResources().getColor(R.color.primary)));

  mParallaxImageHeight = getResources().getDimensionPixelSize(R.dimen.parallax_image_height);

  mListView = (ObservableListView) findViewById(R.id.list);
  mListView.setScrollViewCallbacks(this);
  // Set padding view for ListView. This is the flexible space.
  View paddingView = new View(this);
  AbsListView.LayoutParams lp = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,
          mParallaxImageHeight);
  paddingView.setLayoutParams(lp);
  paddingView.setClickable(true);

  mListView.addHeaderView(paddingView);
  setDummyData(mListView);
  mListBackgroundView = findViewById(R.id.list_background);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，为了取消 header 的点击选择效果，以下代码非常重要：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paddingView.setClickable(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setDummyData（）&lt;/code&gt;用来设置内容。&lt;/p&gt;

&lt;h2 id=&#34;滚动时改变位置-1&#34;&gt;滚动时改变位置&lt;/h2&gt;

&lt;p&gt;我们用 &lt;code&gt;onScrollChanged&lt;/code&gt;方法来改变视图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们应该设置 &lt;code&gt;translateY&lt;/code&gt; 的属性为 &lt;code&gt;scrollY&lt;/code&gt;值的一半，但是并不像 ScrollView一样直接把这个值赋给 &lt;code&gt;translateY&lt;/code&gt;，当 &lt;code&gt;scrollY&lt;/code&gt; 的值变大的时候， ImageView 的 &lt;code&gt;translateY&lt;/code&gt;应该变小，因为ImageView 不是 ListView 的子类，所以我们应该用 &lt;code&gt;-scrollY/2&lt;/code&gt; 作为 &lt;code&gt;translateY&lt;/code&gt; 的值。（你可以改变”/2”的值来得到不一样的视差效果）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setTranslationY(mImageView, -scrollY / 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;改变背景视图&#34;&gt;改变背景视图&lt;/h3&gt;

&lt;p&gt;背景应该跟随着 ListView 一起移动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setTranslationY(mListBackgroundView, mParallaxImageHeight - scrollY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;code&gt;scrollY&lt;/code&gt; 超过 &lt;code&gt;mParallaxImageHeight&lt;/code&gt;后值变为负，这是不允许的。&lt;/p&gt;

&lt;p&gt;我们可以用&lt;code&gt;Math.max（）&lt;/code&gt;来避免这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewHelper.setTranslationY(mListBackgroundView, Math.max(0, -scrollY + mParallaxImageHeight));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他的代码都跟 ObservableScrollView 中一样，就不赘述了。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;不同的 view 实现视差效果的方法也许是有所区别的，需要我们认真的去分析，才能实现出我们想要实现的效果。&lt;/p&gt;

&lt;p&gt;[2]: &lt;a href=&#34;http://blog.qiji.tech/archives/9310&#34;&gt;http://blog.qiji.tech/archives/9310&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TextSwitcher 使用和源码分析</title>
      <link>http://chiakimayuzumi.github.io/apidemos/textswitcher/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/apidemos/textswitcher/</guid>
      <description>

&lt;h1 id=&#34;代码地址&#34;&gt;代码地址&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ChiakiMayuzumi/TextSwitcherTest&#34; title=&#34;github&#34;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;textswitcher介绍&#34;&gt;TextSwitcher介绍&lt;/h1&gt;

&lt;p&gt;在 Java doc 中 TextSwitcher 是这样被描述的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specialized ViewSwitcher that contains only children of type TextView. A TextSwitcher is useful to animate a label on screen. Whenever setText(CharSequence) is called, TextSwitcher animates the current text out and animates the new text in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，TextSwitcher：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有个 TextView 子视图&lt;/li&gt;
&lt;li&gt;在文本更新时，能够让旧文本淡出，新文本淡入，从而呈现平滑切换的动画效果&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;textswitcher使用方法&#34;&gt;TextSwitcher使用方法&lt;/h1&gt;

&lt;p&gt;下面通过最上面的简单代码来讲述如何使用 TestSwitcher&lt;/p&gt;

&lt;p&gt;首先，在 layout 中添加一个 TextSwitcher 的控件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;TextSwitcher
      android:id=&amp;quot;@+id/textSwitcher&amp;quot;
      android:layout_width=&amp;quot;match_parent&amp;quot;
      android:layout_height=&amp;quot;wrap_content&amp;quot;
      android:onClick=&amp;quot;next&amp;quot;
      /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 MainActivity 中进行 ViewFactory 的设置（用于生产视图）：&lt;/p&gt;

&lt;p&gt;textSwitcher.setFactory(new ViewFactory() {
              @Override
              public View makeView() {
                  TextView tv = new TextView(MainActivity.this);
                  tv.setTextSize(20);
                  tv.setTextColor(Color.BLUE);
                  FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
                  lp.gravity = Gravity.CENTER;
                  tv.setLayoutParams(lp);
                  return tv;
              }
          });&lt;/p&gt;

&lt;p&gt;接下来为 textswitcher 设置淡入淡出动画：&lt;/p&gt;

&lt;p&gt;textSwitcher.setInAnimation(AnimationUtils.loadAnimation(
                  getApplicationContext(), android.R.anim.fade_in));
          textSwitcher.setOutAnimation(AnimationUtils.loadAnimation(
                  getApplicationContext(), android.R.anim.fade_out));&lt;/p&gt;

&lt;p&gt;然后通过执行 textswitcher.setText（……） 来切换需要切换的文本，结果如下（转换效果是淡入淡出的，没有动图体现不出效果）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果1.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果1-169x300.png&#34; alt=&#34;TestSwitcherTest结果1&#34; width=&#34;169&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-7144&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果2.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果2-169x300.png&#34; alt=&#34;TestSwitcherTest结果2&#34; width=&#34;169&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-7145&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果3.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果3-169x300.png&#34; alt=&#34;TestSwitcherTest结果3&#34; width=&#34;169&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-7146&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果4.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TestSwitcherTest结果4-169x300.png&#34; alt=&#34;TestSwitcherTest结果4&#34; width=&#34;169&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-7147&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;源码分析&#34;&gt;源码分析&lt;/h1&gt;

&lt;p&gt;学会了如何使用 TextSwitcher 后，我们来试着从源码分析它是如何实现文本切换功能的。&lt;/p&gt;

&lt;h2 id=&#34;textswither继承关系&#34;&gt;TextSwither继承关系&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TextSwitcher继承图.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/TextSwitcher继承图.png&#34; alt=&#34;TextSwitcher继承图&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从中我们可以得知：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;继承自 FrameLayout，所以其子View层叠地放置着&lt;/li&gt;
&lt;li&gt;继承自 ViewAnimator ，所以其持有两个 Animation 对象，用于呈现淡出、渐入等动画效果&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;textswither构造方法&#34;&gt;TextSwither构造方法&lt;/h2&gt;

&lt;p&gt;TextSwither 有两种构造方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TextSwitcher(Context context) 创建一个新的空TextSwitcher，参数 context 为应用程序上下文；&lt;/li&gt;
&lt;li&gt;TextSwitcher(Context context, AttributeSet attrs) 使用提供的context和attributes来创建一个空的TextSwitcher，参数 context 和 attrs 分别为应用程序环境和属性集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;textswither重要方法&#34;&gt;TextSwither重要方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;addView&lt;/strong&gt;(View child, int index, ViewGroup.LayoutParams params)&lt;/p&gt;

&lt;p&gt;根据指定的布局参数新增一个子视图，参数如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;child：新增的子视图&lt;/li&gt;
&lt;li&gt;index：新增子视图的位置&lt;/li&gt;
&lt;li&gt;params：新增子视图的布局参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public void setText(CharSequence text) {
      final TextView t = (TextView) getNextView();
      t.setText(text);
      showNext();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;setCurrentText&lt;/strong&gt;(CharSequence text)&lt;/p&gt;

&lt;p&gt;设置当前显示的文本视图的文字内容，非动画方式显示，参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;text：需要显示的新文本内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public void setCurrentText(CharSequence text) {
      ((TextView)getCurrentView()).setText(text);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;setText&lt;/strong&gt;(CharSequence text)&lt;/p&gt;

&lt;p&gt;设置下一视图的文本内容并切换到下一视图。可以动画的退出当前文本内容，显示下一文本内容，参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;text：需要显示的新文本内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public void setText(CharSequence text) {
      final TextView t = (TextView) getNextView();
      t.setText(text);
      showNext();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终调用了 android.widget.ViewAnimator 的 showOnly 方法：&lt;/p&gt;

&lt;p&gt;void showOnly(int childIndex, boolean animate) {
          final int count = getChildCount();
          for (int i = 0; i &amp;lt; count; i++) {
              final View child = getChildAt(i);
              if (i == childIndex) {
                  if (animate &amp;amp;&amp;amp; mInAnimation != null) {
                      // 让新 TextView 演示进入动画
                      child.startAnimation(mInAnimation);
                  }
                  child.setVisibility(View.VISIBLE);
                  mFirstTime = false;
              } else {
                  if (animate &amp;amp;&amp;amp; mOutAnimation != null &amp;amp;&amp;amp; child.getVisibility() == View.VISIBLE) {
                      // 让旧 TextView 演示淡出动画
                      child.startAnimation(mOutAnimation);
                  } else if (child.getAnimation() == mInAnimation)
                      child.clearAnimation();
                  child.setVisibility(View.GONE);
              }
          }
      }&lt;/p&gt;

&lt;p&gt;在实现的过程中不得不提到接口 ViewSwitcher.ViewFactory，使用时需要注意一定要实现 public abstract View makeView () 方法，它的作用是创建一个用于添加到视图转换器(ViewSwitcher)中的新视图，返回值是 View （一个视图）。&lt;/p&gt;

&lt;p&gt;我们还需要追溯到 ViewSwithcer 的源码去探究一下 setFactory 方法、setInAnimation 方法和 setOutAnimation 方法的源代码和作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;setFactory&lt;/strong&gt;(ViewFactory factory)&lt;/p&gt;

&lt;p&gt;设置用来生成将在视图转换器中切换的两个视图的工厂。也可以调用两次 addView(android.view.View, int, android.view.ViewGroup.LayoutParams) 来替代使用工厂的方法。也就是说设置 ViewFactory 和使用 addView 都可以手动添加一个 View 到 ViewSwithcer 中。&lt;/p&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;p&gt;public void setFactory(ViewFactory factory) {
          mFactory = factory;
          // 构建一个子View
          obtainView();
          // 再构建一个子View
          obtainView();
      }&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;setInAnimation&lt;/strong&gt;(Animation inAnimation)&lt;/p&gt;

&lt;p&gt;就是设置 ViewAnimator 所持有的 Animation 对象。&lt;/p&gt;

&lt;p&gt;源码（以 setInAnimation 为例）：&lt;/p&gt;

&lt;p&gt;public void setInAnimation(Animation inAnimation) {
          mInAnimation = inAnimation;
      }&lt;/p&gt;

&lt;p&gt;关于 TextSwitcher 的源码分析暂时就到这里。&lt;/p&gt;

&lt;h1 id=&#34;设计方法&#34;&gt;设计方法&lt;/h1&gt;

&lt;p&gt;TextSwitcher 使用了工厂方法模式，通过 setFactory 来设置 ViewFactory 工厂，从而在每次转换的时候生成需要的 View。&lt;/p&gt;

&lt;h1 id=&#34;布局&#34;&gt;布局&lt;/h1&gt;

&lt;p&gt;由于其继承了 FrameLayout，Framelayout 是从左上角开始叠加显示图形的，所以 Test 代码的布局中，即使设置了居中，在运行后 TextSwitcher 也不会居中显示。&lt;/p&gt;

&lt;p&gt;那如何设置 textswitcher 的 childview 居中呢？Framelayout 不支持 gravity 属性，所以 textswitcher 也没有。只能设置 child 的 layout_gravity,代码如下：&lt;/p&gt;

&lt;p&gt;FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
                  lp.gravity = Gravity.CENTER;
                  tv.setLayoutParams(lp);&lt;/p&gt;

&lt;p&gt;然后就能居中显示了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using StarterNetworkActivity to make easier HTTP request</title>
      <link>http://chiakimayuzumi.github.io/androidstartkit/starternetworkactivity/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/androidstartkit/starternetworkactivity/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/qijitech/android-starter-kit&#34;&gt;android-starter-kit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;android-starter-kit&lt;/code&gt; is a fast development kit for Android developer,and this topic describes how to use &lt;code&gt;StarterNetworkActivity&lt;/code&gt; to make your new activity’s HTTP requests easier.&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;To make the HTTP requests, we could use some third-party libraries such as &lt;code&gt;retrofit 2.0&lt;/code&gt;,which is known as a type-safe HTTP client for Android and Java.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;android-starter-kit&lt;/code&gt; simply encapsulates &lt;code&gt;retrofit 2.0&lt;/code&gt; in it so if you are familiar with &lt;code&gt;retrofit 2.0&lt;/code&gt;,it won’t be difficult for you to use &lt;code&gt;StarterNetworkActivity&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-to-use&#34;&gt;How to use&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;android-starter-kit&lt;/code&gt; demo App ,&lt;code&gt;LoginActivity&lt;/code&gt; shows how to use &lt;code&gt;StarterNetworkActivity&lt;/code&gt;,so let’s see the source code in :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  com.smartydroid.android.kit.demo.ui.activity.LoginActivity
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;preparations&#34;&gt;Preparations&lt;/h2&gt;

&lt;p&gt;Preparations must be done before using &lt;code&gt;StarterNetworkActivity&lt;/code&gt;,which contains:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a proper entity class&lt;/li&gt;
&lt;li&gt;get RetrofitBuilder with baseUrl&lt;/li&gt;
&lt;li&gt;get apiService and your own HTTP service interface&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-proper-entity-class&#34;&gt;a proper entity class&lt;/h3&gt;

&lt;p&gt;Define your own entity class which extends &lt;code&gt;Entity&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;Demo App provides an entity class named &lt;code&gt;User&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@JsonIgnoreProperties(ignoreUnknown = true) public class User extends Entity implements Account {

  public Integer id;
  public String phone;
  public String nickname;
  public String avatar;
  public String token;

  public User() {

  }
……
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get-retrofitbuilder-with-baseurl&#34;&gt;get RetrofitBuilder with baseUrl&lt;/h3&gt;

&lt;p&gt;You should get the &lt;code&gt;RetrofitBuilder&lt;/code&gt; in your Application class which extends &lt;code&gt;StarterKitApp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In demo App the Application Class is &lt;code&gt;DemoApp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class DemoApp extends StarterKitApp {
……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;DemoApp&lt;/code&gt; is a base class for those who need to maintain global application state,in which we get &lt;code&gt;RetrofitBuilder&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override public void onCreate() {

    // common config
    ……
    super.onCreate();
  ……
    // init api service
    new RetrofitBuilder.Builder()
        .accept(Profile.API_ACCEPT)
        .baseUrl(Profile.API_ENDPOINT)
        .build();
  ……
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;baseUrl &lt;code&gt;API_ENDPOINT&lt;/code&gt; is in &lt;code&gt;Profile&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Profile {

  String API_ENDPOINT = &amp;quot;http://fakerapi.qiji.tech&amp;quot;;
  ……
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get-apiservice-and-your-own-http-service-interface&#34;&gt;get ApiService and your own HTTP service interface&lt;/h3&gt;

&lt;p&gt;Retrofit turns your HTTP API into a Java interface,so write your own HTTP service interface using the defined entity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface AuthService {

  /**
   * Login Interface
   *
   * @param phone 
   * @param password 
   * @return Call
   */
  @FormUrlEncoded @POST(&amp;quot;/auth/login&amp;quot;) Call&amp;lt;User&amp;gt; login(
      @Field(&amp;quot;phone&amp;quot;) String phone,
      @Field(&amp;quot;password&amp;quot;) String password);

  @GET(&amp;quot;/user/profile&amp;quot;) Call&amp;lt;User&amp;gt; profile();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ApiService is defined to get your own HTTP service or other HTTP service with &lt;code&gt;retrofit&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ApiService {

  // create your HTTP interface with retrofit
  public static AuthService createAuthService() {
    return retrofit().create(AuthService.class);
  }
  
  // create other HTTP interface with retrofit
  public static FeedService createFeedService() {
    return retrofit().create(FeedService.class);
  }

  // get retrofit
  private static Retrofit retrofit() {
    return RetrofitBuilder.get().retrofit();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-starternetworkactivity&#34;&gt;Using StarterNetworkActivity&lt;/h2&gt;

&lt;p&gt;Define your own activity extends &lt;code&gt;StarterNetworkActivity&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LoginActivity extends StarterNetworkActivity&amp;lt;User&amp;gt; {
……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, get defined HTTP service interface in method &lt;code&gt;onCreate&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;……
 private AuthService mAuthService;

  @Override protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_login);

    mAuthService = ApiService.createAuthService();
……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following override callbacks should be paid attention to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // call before request
  @Override public void startRequest() {
    showHud(“Logining...&amp;quot;);
  }

  // call after request success with your defined entity class
  @Override public void respondSuccess(User data) {
    AccountManager.store(data);
    Snackbar.make(getWindow().getDecorView(), “Login Success”, Snackbar.LENGTH_SHORT).show();
    Intent upIntent = NavUtils.getParentActivityIntent(this);
    NavUtils.navigateUpTo(this, upIntent);
  }
  
  // call when request end
  @Override public void endRequest() {
    dismissHud();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>setupWithViewPager()后到底发生了什么？</title>
      <link>http://chiakimayuzumi.github.io/others/setupwithviewpager/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/others/setupwithviewpager/</guid>
      <description>

&lt;p&gt;相信使用过 TabLayout 和 ViewPager 的人对这个方法一定不陌生了，当我们为 ViewPager 设置好 adapter 后，需要调用 TabLayout 的 &lt;code&gt;setupWithViewPager&lt;/code&gt; 方法将 ViewPager 的引用传递进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mViewPager.setAdapter(mAdapter);
mTabLayout.setupWithViewPager(mViewPager);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么接下来问题来了，为什么 &lt;code&gt;setupWithViewPager&lt;/code&gt; 之后，ViewPager 和 TabLayout 就能关联起来呢？并且 ViewPager 设置的 adapter 中的 &lt;code&gt;PageTitle&lt;/code&gt;数据就能正确反应到每一个 Tab 中去呢？为了搞明白这些背后的操作，我认为我们有必要去查看方法 &lt;code&gt;setupWithViewPager&lt;/code&gt; 的源代码。&lt;/p&gt;

&lt;h1 id=&#34;分析-setupwithviewpager-的原理&#34;&gt;分析 setupWithViewPager() 的原理&lt;/h1&gt;

&lt;h2 id=&#34;方法源码&#34;&gt;方法源码&lt;/h2&gt;

&lt;p&gt;方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void setupWithViewPager(@Nullable final ViewPager viewPager) {
    if (mViewPager != null &amp;amp;&amp;amp; mPageChangeListener != null) {
      mViewPager.removeOnPageChangeListener(mPageChangeListener);
    }
    if (viewPager != null) {
      final PagerAdapter adapter = viewPager.getAdapter();
      if (adapter == null) {
        throw new IllegalArgumentException(&amp;quot;ViewPager does not have a PagerAdapter set&amp;quot;);
      }
      mViewPager = viewPager;

      if (mPageChangeListener == null) {
        mPageChangeListener = new TabLayoutOnPageChangeListener(this);
      }
      mPageChangeListener.reset();
      viewPager.addOnPageChangeListener(mPageChangeListener);

      setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));

      setPagerAdapter(adapter, true);
    } else {

      mViewPager = null;
      setOnTabSelectedListener(null);
      setPagerAdapter(null, true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看第一部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (mViewPager != null &amp;amp;&amp;amp; mPageChangeListener != null) {
      mViewPager.removeOnPageChangeListener(mPageChangeListener);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果已经设置过 ViewPager 了，并且也设置了PageChangeListener，则将它移除。&lt;/p&gt;

&lt;p&gt;再来第二部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  else {
    mViewPager = null;
    setOnTabSelectedListener(null);
    setPagerAdapter(null, true);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果传入了一个空的 ViewPager，就将 ViewPager，OnTabSelectedListener和PagerAdapter都设置为空。&lt;/p&gt;

&lt;p&gt;然后是第三部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (viewPager != null) {
      final PagerAdapter adapter = viewPager.getAdapter();
      if (adapter == null) {
        throw new IllegalArgumentException(&amp;quot;ViewPager does not have a PagerAdapter set&amp;quot;);
      }
      mViewPager = viewPager;

      if (mPageChangeListener == null) {
        mPageChangeListener = new TabLayoutOnPageChangeListener(this);
      }
      mPageChangeListener.reset();
      viewPager.addOnPageChangeListener(mPageChangeListener);

      setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));

      setPagerAdapter(adapter, true);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 ViewPager 不为空，则将它赋值给 PagerAdapter 类型的引用 mViewPager。ViewPager 的 adapter 类型继承自 FragmentPagerAdapter，FragmentPagerAdapter 则是继承自 PagerAdapter，所以这样赋值是没有问题的。当adapter 为 &lt;code&gt;null&lt;/code&gt; 抛出异常。&lt;/p&gt;

&lt;p&gt;将这个传入的 ViewPager 引用赋值给类私有变量 mViewPager；
如果 TabLayoutOnPageChangeListener 为空，则新建一个 TabLayoutOnPageChangeListener ，调用 &lt;code&gt;reset&lt;/code&gt; 方法，重设当前的滚动状态；
调用 ViewPager 的 &lt;code&gt;addOnPageChangeListener&lt;/code&gt; 方法，设置监听：setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));&lt;/p&gt;

&lt;p&gt;最后设置setPagerAdapter(adapter, true)，整个方法就完成了，
第一个参数就是 ViewPager 设置的 adapter 后面的参数留到下一节观察者模式讲解。&lt;/p&gt;

&lt;h2 id=&#34;两个监听的实现类&#34;&gt;两个监听的实现类&lt;/h2&gt;

&lt;p&gt;TabLayoutOnPageChangeListener 是一个监听，ViewPagerOnTabSelectedListener 是另一个监听。&lt;/p&gt;

&lt;p&gt;先来看看 TabLayoutOnPageChangeListener。主要处理的是 ViewPager 发生变化时处理回调（尤其是需要实现跟 TabLayout 的关联，也就是说，当 ViewPager 在滑动时，TabLayout 需要怎么变化）。&lt;/p&gt;

&lt;p&gt;它实现了 &lt;code&gt;ViewPager.OnPageChangeListener&lt;/code&gt; 接口，需要实现三个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels)，当当前页滚动时调用。&lt;/li&gt;
&lt;li&gt;public void onPageSelected(int position)，当一个新页面被选中时调用。
重要方法：tabLayout.selectTab(tabLayout.getTabAt(position), updateIndicator)&lt;/li&gt;
&lt;li&gt;public void onPageScrollStateChanged(int state)，当滚动状态改变时调用。
重要方法：tabLayout.setScrollPosition(position, positionOffset, updateText, updateIndicator)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有一个非接口实现方法 &lt;code&gt;reset&lt;/code&gt;，该接口重新设置了滚动状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void reset() {
    mPreviousScrollState = mScrollState = SCROLL_STATE_IDLE;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 ViewPagerOnTabSelectedListener 跟上一个监听相反，主要处理的是当 TabLayout 中的 Tab 发生点击事件时，ViewPager 需要怎么变化。它实现的是&lt;code&gt;TabLayout.OnTabSelectedListener&lt;/code&gt; 接口，需要实现三个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public void onTabSelected(Tab tab)&lt;/li&gt;
&lt;li&gt;public void onTabUnselected(Tab tab)&lt;/li&gt;
&lt;li&gt;public void onTabReselected(Tab tab)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这里，只实现了第一个方法，源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override
  public void onTabSelected(TabLayout.Tab tab) {
    mViewPager.setCurrentItem(tab.getPosition());
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是当点击 TabLayout 的某个 tab 就将与之对应的那个 position 赋值给&lt;code&gt;setCurrentItem&lt;/code&gt; 完成 ViewPager 的跳转。&lt;/p&gt;

&lt;p&gt;最后总结一下 &lt;code&gt;setupWithViewPager&lt;/code&gt; 是如何让 ViewPager 跟自身 TabLayout 产生关联的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传入 ViewPager，为该 ViewPager 设监听 TabLayoutOnPageChangeListener，这样就使得 ViewPager 在滚动状态发生改变时，TabLayout 对应的有所改变&lt;/li&gt;
&lt;li&gt;然后为TabLayout自身设置ViewPagerOnTabSelectedListener 当 TabLayout 点击状态发生改变时，ViewPager 也有相应改变。&lt;/li&gt;
&lt;li&gt;最后，将 ViewPager 设置的 adapter 也设置给自己。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;观察者模式的应用&#34;&gt;观察者模式的应用&lt;/h1&gt;

&lt;h2 id=&#34;继承关系&#34;&gt;继承关系&lt;/h2&gt;

&lt;p&gt;继承关系图如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.qiji.tech/wp-content/uploads/2016/06/TabLayout-和-ViewPager-中的观察者模式-2.png&#34;&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/06/TabLayout-和-ViewPager-中的观察者模式-2.png&#34; alt=&#34;TabLayout 和 ViewPager 中的观察者模式-2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;

&lt;p&gt;接下来开始分析 TabLayout 和 ViewPager 中用到的观察者模式。
PagerAdapter 是一个抽象类，其中包含有一个 DataSetObservable 和 DataSetObserver 的引用。&lt;/p&gt;

&lt;p&gt;PagerAdapter 中重要的方法是 &lt;code&gt;notifyDataSetChanged&lt;/code&gt;，当我们向 adapter 中增添数据后，都会调用这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void notifyDataSetChanged() {
    synchronized (this) {
      if (mViewPagerObserver != null) {
        mViewPagerObserver.onChanged();
      }
    }
    mObservable.notifyChanged();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DataSetObservable 是 Observable&lt;DataSetObserver&gt; 的具体实现类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public class DataSetObservable extends Observable&amp;lt;DataSetObserver&amp;gt; {
    public void notifyChanged() {
      synchronized(mObservers) {
        // since onChanged() is implemented by the app, it could do anything, including
        // removing itself from {@link mObservers} - and that could cause problems if
        // an iterator is used on the ArrayList {@link mObservers}.
        // to avoid such problems, just march thru the list in the reverse order.
        for (int i = mObservers.size() - 1; i &amp;gt;= 0; i--) {
          mObservers.get(i).onChanged();
        }
      }
    }

    public void notifyInvalidated() {
      synchronized (mObservers) {
        for (int i = mObservers.size() - 1; i &amp;gt;= 0; i--) {
          mObservers.get(i).onInvalidated();
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 DataSetObserver 是一个抽象类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public abstract class DataSetObserver {

    public void onChanged() {
      // Do nothing
    }

    public void onInvalidated() {
      // Do nothing
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 DataSetObserver 和 DataSetObservable 关联起来后，调用 DataSetObservable 的 &lt;code&gt;notifyChanged&lt;/code&gt; 方法时，会分别调用每一个 DataSetObserver 的 `onChanged 方法，达到通知的目的。&lt;/p&gt;

&lt;p&gt;DataSetObserver 有两个实现类，一个是 PagerAdapterObserver:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private class PagerAdapterObserver extends DataSetObserver {
    @Override
    public void onChanged() {
      populateFromPagerAdapter();
    }

    @Override
    public void onInvalidated() {
      populateFromPagerAdapter();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类位于 TabLayout 中，作用是当 &lt;code&gt;notifyChanged&lt;/code&gt; 时，重新加载 TabLayout 的布局和数据，具体实现的方法为 &lt;code&gt;populateFromPagerAdapter&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void populateFromPagerAdapter() {
    removeAllTabs();

    if (mPagerAdapter != null) {
      final int adapterCount = mPagerAdapter.getCount();
      for (int i = 0; i &amp;lt; adapterCount; i++) {
        addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false);
      }

      // Make sure we reflect the currently set ViewPager item
      if (mViewPager != null &amp;amp;&amp;amp; adapterCount &amp;gt; 0) {
        final int curItem = mViewPager.getCurrentItem();
        if (curItem != getSelectedTabPosition() &amp;amp;&amp;amp; curItem &amp;lt; getTabCount()) {
          selectTab(getTabAt(curItem));
        }
      }
    } else {
      removeAllTabs();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个是位于 ViewPager 中的 PagerObserver 类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private class PagerObserver extends DataSetObserver {
    @Override
    public void onChanged() {
      dataSetChanged();
    }
    @Override
    public void onInvalidated() {
      dataSetChanged();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体实现方法是 &lt;code&gt;dataSetChanged&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  void dataSetChanged() {
    // This method only gets called if our observer is attached, so mAdapter is non-null.

    final int adapterCount = mAdapter.getCount();
    mExpectedAdapterCount = adapterCount;
    boolean needPopulate = mItems.size() &amp;lt; mOffscreenPageLimit * 2 + 1 &amp;amp;&amp;amp;
            mItems.size() &amp;lt; adapterCount;
    int newCurrItem = mCurItem;

    boolean isUpdating = false;
    for (int i = 0; i &amp;lt; mItems.size(); i++) {
      final ItemInfo ii = mItems.get(i);
      final int newPos = mAdapter.getItemPosition(ii.object);

      if (newPos == PagerAdapter.POSITION_UNCHANGED) {
        continue;
      }

      if (newPos == PagerAdapter.POSITION_NONE) {
        mItems.remove(i);
        i--;

        if (!isUpdating) {
          mAdapter.startUpdate(this);
          isUpdating = true;
        }

        mAdapter.destroyItem(this, ii.position, ii.object);
        needPopulate = true;

        if (mCurItem == ii.position) {
          // Keep the current item in the valid range
          newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1));
          needPopulate = true;
        }
        continue;
      }

      if (ii.position != newPos) {
        if (ii.position == mCurItem) {
          // Our current item changed position. Follow it.
          newCurrItem = newPos;
        }

        ii.position = newPos;
        needPopulate = true;
      }
    }

    if (isUpdating) {
      mAdapter.finishUpdate(this);
    }

    Collections.sort(mItems, COMPARATOR);

    if (needPopulate) {
      // Reset our known page widths; populate will recompute them.
      final int childCount = getChildCount();
      for (int i = 0; i &amp;lt; childCount; i++) {
        final View child = getChildAt(i);
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        if (!lp.isDecor) {
          lp.widthFactor = 0.f;
        }
      }

      setCurrentItemInternal(newCurrItem, false, true);
      requestLayout();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的逻辑可以不用去看，注意到最后调用了 &lt;code&gt;requestLayout&lt;/code&gt; 方法进行重新布局。&lt;/p&gt;

&lt;p&gt;这样，当 adapter 的 &lt;code&gt;notifyDataSetChanged&lt;/code&gt; 方法被调用时，就会调用到 TabLayout 中的观察者 PagerAdapterObserver 的 &lt;code&gt;onChanged&lt;/code&gt; 方法，进而通过 &lt;code&gt;populateFromPagerAdapter&lt;/code&gt; 重新对 Tab 进行布局；并且调用到 ViewPager 中的观察者 PagerObserver 的 &lt;code&gt;onChanged&lt;/code&gt; 方法，进而通过 &lt;code&gt;dataSetChanged&lt;/code&gt; 重新对 ViewPager 进行布局；&lt;/p&gt;

&lt;h2 id=&#34;注册&#34;&gt;注册&lt;/h2&gt;

&lt;p&gt;最后还需要解决一个问题：观察者与被观察者是什么时候联系上的？也就是说，在整个流程中，观察者是如何注册到被观察者中去的？&lt;/p&gt;

&lt;p&gt;需要注意到的是 ViewPager 的 setAdapter方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void setAdapter(PagerAdapter adapter) {
    if (mAdapter != null) {
      mAdapter.setViewPagerObserver(null);
      mAdapter.startUpdate(this);
      for (int i = 0; i &amp;lt; mItems.size(); i++) {
        final ItemInfo ii = mItems.get(i);
        mAdapter.destroyItem(this, ii.position, ii.object);
      }
      mAdapter.finishUpdate(this);
      mItems.clear();
      removeNonDecorViews();
      mCurItem = 0;
      scrollTo(0, 0);
    }

    final PagerAdapter oldAdapter = mAdapter;
    mAdapter = adapter;
    mExpectedAdapterCount = 0;

    if (mAdapter != null) {
      if (mObserver == null) {
        mObserver = new PagerObserver();
      }
      mAdapter.setViewPagerObserver(mObserver);
      mPopulatePending = false;
      final boolean wasFirstLayout = mFirstLayout;
      mFirstLayout = true;
      mExpectedAdapterCount = mAdapter.getCount();
      if (mRestoredCurItem &amp;gt;= 0) {
        mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);
        setCurrentItemInternal(mRestoredCurItem, false, true);
        mRestoredCurItem = -1;
        mRestoredAdapterState = null;
        mRestoredClassLoader = null;
      } else if (!wasFirstLayout) {
        populate();
      } else {
        requestLayout();
      }
    }

    if (mAdapterChangeListener != null &amp;amp;&amp;amp; oldAdapter != adapter) {
      mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (mAdapter != null) {
    if (mObserver == null) {
      mObserver = new PagerObserver();
    }
    mAdapter.setViewPagerObserver(mObserver);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们去 &lt;code&gt;setViewPagerObserver&lt;/code&gt; 方法中看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  void setViewPagerObserver(DataSetObserver observer) {
    synchronized (this) {
      mViewPagerObserver = observer;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看 TabLayout 中，当调用 &lt;code&gt;setupWithViewPager&lt;/code&gt; 方法时，会调用一个方法 &lt;code&gt;setPagerAdapter&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) {
    if (mPagerAdapter != null &amp;amp;&amp;amp; mPagerAdapterObserver != null) {
      // If we already have a PagerAdapter, unregister our observer
      mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver);
    }

    mPagerAdapter = adapter;

    if (addObserver &amp;amp;&amp;amp; adapter != null) {
      // Register our observer on the new adapter
      if (mPagerAdapterObserver == null) {
        mPagerAdapterObserver = new PagerAdapterObserver();
      }
      adapter.registerDataSetObserver(mPagerAdapterObserver);
    }

    // Finally make sure we reflect the new adapter
    populateFromPagerAdapter();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;adapter.registerDataSetObserver(mPagerAdapterObserver)&lt;/code&gt;方法被调用，完成了注册任务。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>设计模式-工厂模式</title>
      <link>http://chiakimayuzumi.github.io/blabla/factory/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/blabla/factory/</guid>
      <description>

&lt;p&gt;#设计模式概要&lt;/p&gt;

&lt;p&gt;Apple 的 Cocoa Fundamentals Guide上有这样一句话：
&amp;gt; Design Pattern is a solution to a problem in a context.&lt;/p&gt;

&lt;p&gt;也就是说，设计模式是针对特定上下文的特定问题的解决方案，在忽略掉不重要的细节后，这种解决方案被抽象化，发现问题的一般性本质并将其模版化，找到普遍适用的解决方案从而形成了设计模式。&lt;/p&gt;

&lt;p&gt;设计模式的本质是面向对象方法的实际运用。具体而言，是封装、继承、多态和关联的反复使用。通过封装、继承和多态把程序的耦合度降低；用设计模式使得程序更加灵活，在支持可维护性的同时，提高系统的可复用性。&lt;/p&gt;

&lt;p&gt;设计模式主要有以下四个基本要素：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 模式名称（pattem name）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个名称用来描述模式的问题、解决方案和效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 问题（problem）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;描述了设计模式在何种情形使用。它解释了设计模式形成的前因后果，描述了特定的设计问题。问题往往就是模式必须满足的一系列先决条件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 解决方案（solution）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;描述模式的组成成分，成分之间的相互关系以及各自的指着和协作方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 效果（consequences）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;效果用来描述设计模式的利弊，效果往往是我们权衡模式是否可用的重要因素。&lt;/p&gt;

&lt;p&gt;一般来说，大家还同意模式包含以下的这些要素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;力（Force）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;举例（Example）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;末态环境（Resulting Context）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推理（Rationale）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他有关模式（Related Patterns）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;已知的应用（Known Uses）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还需要了解的是设计模式应当遵循的七大原则，包括：开-闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成/聚合复用原则、抽象原则和迪米特法则。由于篇幅有限这里不再介绍，附上别人的博客地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4e60b09d0101d1xc.html&#34;&gt;Java设计模式遵循的七大原则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后，我们可以把设计模式类比为各种武功招式，习武都崇尚无招胜有招，码代码亦是如此，达到最高境界后只记住一句内功心法：低耦合，高内聚。相信随着对设计模式的深入了解能够更加体会到这点的玄妙之处。&lt;/p&gt;

&lt;h1 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h1&gt;

&lt;p&gt;工厂模式专门负责将大量有共有接口的类实例化，可以动态决定将哪个类实例化，不必事先知道每次要实例化哪一个类。该模式往往是设计模式初学者入门的模式，可以称得上为典型又最具启发效果的模式。&lt;/p&gt;

&lt;p&gt;工厂模式有三种形态，分别是简单工厂（Simple Factory）模式，工厂方法（Factory Method）模式和抽象工厂（Abstract Factory）模式。下面就从上一节中提到的基本要素开始分析三种形态的工厂模式，通过对比来理解三种模式的作用和不同之处。&lt;/p&gt;

&lt;h2 id=&#34;名字&#34;&gt;名字&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简单工厂（Simple Factory）&lt;/strong&gt;：又称静态工厂方法模式（Static Factory Method Pattern），简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。&lt;/p&gt;

&lt;p&gt;简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例，通常它返回的类都有一个公共的父类（或者接口对象）。&lt;/p&gt;

&lt;p&gt;简单结构如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/简单工厂模式的简单结构图.png&#34; alt=&#34;简单工厂模式的简单结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在简单工厂模式中，工厂类是整个模式的关键，其包含必要的判断逻辑，能够根据外界给定的信息，决定究竟创建哪个类的实例，外界可以不用去关注对象的创建，仅需要负责“消费”对象就可以了，明确区分了责任，有利于结构的优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工厂方法（Factory Method）&lt;/strong&gt;：又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式。&lt;/p&gt;

&lt;p&gt;它定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。&lt;/p&gt;

&lt;p&gt;简单结构如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/工厂方法模式的简单结构图.png&#34; alt=&#34;工厂方法模式的简单结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;工厂方法模式是我们在简单工厂模式的基础上再次进行抽象，为了扩展的方便和修改封闭，把一些对功能的判断不在放到一个类中，而是抽象出操作的工厂接口，各个工厂再去实现这个接口，变得更为固定，就像是机械般的。逻辑判断是在客户端通过实例化哪个具体的工厂来代替了简单工厂中工厂类中的逻辑判断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;抽象工厂（Abstract Factory）&lt;/strong&gt;：又称工具箱（Kit 或Toolkit）模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂和工厂方法大致相同，不同就是一簇，是一系列的产品操作。&lt;/p&gt;

&lt;p&gt;简单的结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/抽象工厂模式的简单结构图.png&#34; alt=&#34;抽象工厂模式的简单结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;左边的等级结构代表工厂等级结构，右边的两个等级结构分别代表两个不同产品的等级结构。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下创建多个产品族中的对象，这就是抽象工厂模式的用意。&lt;/p&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;什么时候应该使用简单工厂模式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你能预测到所有产品类的情况，建议就用简单工厂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么时候应该使用工厂方法模式：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端不知道它要创建的具体是哪一个子类。&lt;/li&gt;
&lt;li&gt;一个类想要由自己的子类来定义某对象的创建过程。&lt;/li&gt;
&lt;li&gt;类将创建某对象的职责代理给一些帮助子类中的一个，并且你想要将哪一个子类作为代理的信息进行局部化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;什么时候应该使用工厂方法模式：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一个抽象工厂类，可以派生出多个具体工厂类。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个具体工厂类可以创建多个具体产品类的实例。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单工厂的工厂类方法都是静态的。&lt;/li&gt;
&lt;li&gt;简单工厂侧重于创建对象的代码复用，或者已创建实例的复用，或者创建实例的统一性；而工厂方法侧重于子类自己特定创建逻辑的实现&lt;/li&gt;
&lt;li&gt;简单工厂模式中的工厂类是为产品类实例化的核心，而工厂方法模式把初始化工作交给子类实现。&lt;/li&gt;
&lt;li&gt;工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简单工厂模式的结构：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/简单工厂模式结构图.png&#34; alt=&#34;简单工厂模式结构图&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工厂类（Creator）角色：&lt;/strong&gt;工厂方法的核心，在客户端的直接调用下创建产品对象。（具体java类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象产品（Product）角色：&lt;/strong&gt;工厂方法模式创建的对象的父类或者它们拥有共同的接口。（Java接口或Java抽象类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体产品（Concrete Product）角色：&lt;/strong&gt;工厂方法模式创建的任何对象都是这个角色的实例。（具体Java类）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;工厂方法模式的结构：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/工厂方法模式结构图.png&#34; alt=&#34;工厂方法模式结构图&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象工厂（Creator）角色：&lt;/strong&gt;工厂方法的核心，与应用程序无关。任何在模式中创对象的工厂类必须实现这个接口。（Java接口或抽象Java类）
-** 具体工厂（Concrete Creator）角色：**实现了抽象工厂接口的具体java类，与应用有密切关联，并受到应用程序的调用来创建产品对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象产品（Product）角色：&lt;/strong&gt;同简单工厂。（Java接口或抽象Java类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体产品（Concrete Product）角色：&lt;/strong&gt;同简单工厂。（具体Java类）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;抽象工厂模式的结构：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/抽象工厂模式结构图.png&#34; alt=&#34;抽象工厂模式结构图&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象工厂（Abstract Factory）角色：&lt;/strong&gt;同工厂方法。（java接口抽象java）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体工厂（Concrete Factory）角色：&lt;/strong&gt;同工厂方法。（具体java类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象产品（Abstract Product）角色：&lt;/strong&gt;同工厂方法。（java接口抽象java）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体产品类（Concrete Product）角色：&lt;/strong&gt;同工厂方法。（具体java类）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;效果&#34;&gt;效果&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简单工厂优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求，从而避免了对象的调用者与对象的实现类以硬编码方式耦合，以提高系统的可维护性、可扩展性；设计简单，产品类的等级结构不会反映到工厂类中来，产品类的等级结构变化不会影响工厂类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单工厂缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;体现在其工厂类上，该类集中了所有实例的创建逻辑，违反了高内聚的责任分配原则，当系统的具体产品类不断增多时，工厂类中条件判断过多，不利于扩展及维护，没有遵守开放—封闭原则。如果将来需要产品类，那么，在简单工厂模式中，就必须在简单工厂类中添加相应的判断语句，必然导致工厂类的修改。不修改代码的话，是无法扩展的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工厂方法的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简单工厂模式的缺点，利用工厂方法模式可以得到一定的克服。在简单工厂模式的基础上再次进行抽象，为了扩展的方便和修改封闭，把一些对功能的判断不在放到一个类中，而是抽象出操作的工厂接口，各个工厂再去实现这个接口。它遵循了“开放—封闭”原则。在同一等级结构中，支持增加任意产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工厂方法的缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;把简单工厂的内部逻辑判断转移到了客户端代码来执行；每增加一产品就要增加一个产品工厂的类，增加了额外的开发量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;抽象工厂的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;抽象工厂是应对产品族概念的。应对产品族概念而生，增加新的产品线很容易，抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建，当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;抽象工厂的缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。&lt;/p&gt;

&lt;p&gt;以上三种工厂方法在等级结构和产品族这两个方向上的支持程度不同，所以要根据情况考虑应该使用哪种方法。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;例子是我自己写的一个自动贩售饮料机的简单实现。&lt;/p&gt;

&lt;p&gt;在简单工厂模式下，创建一个DrinkFactory，通过它来产生我所需要的饮料：可乐，雪碧和芬达。&lt;/p&gt;

&lt;p&gt;饮料接口Drink：&lt;/p&gt;

&lt;p&gt;/**
   * 饮品接口
   * @author chiakimayuzumi
   *
   */
  public interface Drink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * kind 方法 表明口味
 */
 public void kind();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;具体可乐类：&lt;/p&gt;

&lt;p&gt;/**
   * 可乐
   * @author chiakimayuzumi
   *
   */
   public class Cola implements Drink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void kind() {
  System.out.println(&amp;quot;I Love Cola&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;具体雪碧类：&lt;/p&gt;

&lt;p&gt;/**
   * 雪碧
   * @author chiakimayuzumi
   *
   */
  public class Sprite implements Drink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void kind() {
  System.out.println(&amp;quot;I Love Sprite&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;具体芬达类：&lt;/p&gt;

&lt;p&gt;/**
   * 芬达
   * @author chiakimayuzumi
   *
   */
   public class Fanta implements Drink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void kind() {
  System.out.println(&amp;quot;I Love Fanta&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;工厂类：&lt;/p&gt;

&lt;p&gt;/**
   * 工厂类
   * @author chiakimayuzumi
   *
   */
  public class DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Drink produceDrink(String kind){

    Drink drink = null;
    if(kind.equals(&amp;quot;Cola&amp;quot;)){
      drink = new Cola();           
    }else if(kind.equals(&amp;quot;Sprite&amp;quot;)){
      drink = new Sprite();
    }else if(kind.equals(&amp;quot;Fanta&amp;quot;)){
      drink = new Fanta();
    }else {
      throw new IllegalArgumentException(&amp;quot;No such kind&amp;quot;);
    }
    return drink;


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;客户端调用：&lt;/p&gt;

&lt;p&gt;/**
   * 客户端调用
   * @author chiakimayuzumi
   *
   */
  public class Console {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public static void main(String[] args) {  

      Drink  drink1 = DrinkFactory.produceDrink(&amp;quot;Cola&amp;quot;);  
      drink1.kind();  

      Drink  drink2 = DrinkFactory.produceDrink(&amp;quot;Sprite&amp;quot;);  
      drink2.kind();  

      Drink  drink3 = DrinkFactory.produceDrink(&amp;quot;Fanta&amp;quot;);  
      drink3.kind();  

      Drink  drink4 = DrinkFactory.produceDrink(&amp;quot;Coffee&amp;quot;);  
      drink4.kind();  

  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;最终结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/简单工厂示例结果.png&#34; alt=&#34;简单工厂示例结果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后抛出错误是因为客户端调用了没有的饮品类型咖啡。&lt;/p&gt;

&lt;p&gt;随后，有消费者反映，希望能够买到咖啡。通过观察上述代码我们可以发现，如果需要实现这个功能，必须修改DrinkFactory中的代码。这样就违背了开闭原则。如果我们用工厂方法模式实现这个自动贩售饮料机呢？&lt;/p&gt;

&lt;p&gt;一个抽象的工厂类：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public abstract class DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  protected abstract Drink produceDrink();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;可乐工厂类：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class ColaFactory extends DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override  
  protected Drink produceDrink() {  

      return new Cola();  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;雪碧工厂类：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class SpriteFactory extends DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override  
  protected Drink produceDrink() {  

      return new Sprite();  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
芬达工厂类：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class FantaFactory extends DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override  
  protected Drink produceDrink() {  

      return new Fanta();  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;最后在客户端调用即可，如果需要增加咖啡，只需要增加具体的咖啡类和咖啡工厂类即可。&lt;/p&gt;

&lt;p&gt;咖啡类：&lt;/p&gt;

&lt;p&gt;/**
   * Coffee
   * @author chiakimayuzumi
   *
   */
   public class Coffee implements Drink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void kind() {
  System.out.println(&amp;quot;I Love Coffee&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;咖啡工厂类：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class CoffeeFactory extends DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override  
  protected Drink produceDrink() {  

      return new Coffee();  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;然后调用：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class Console {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public static void main(String[] args) {  

  Drink d1 = new ColaFactory().produceDrink();
  d1.kind();

  Drink d2 = new SpriteFactory().produceDrink();
  d2.kind();

  Drink d3 = new FantaFactory().produceDrink();
  d3.kind();

  Drink d4 = new CoffeeFactory().produceDrink();
  d4.kind();


  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/工厂方法示例结果.png&#34; alt=&#34;工厂方法示例结果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成这一步后，又有消费者反应，冬天的时候，最好能喝到热的饮料。如果要满足这样的需求，我们需要再增加的是热可乐的具体类，热雪碧的具体类，热芬达的具体类，热咖啡的具体类，热可乐工厂，热雪碧工厂，热芬达工厂，热咖啡工厂。如此繁多的类看起来是不是非常的麻烦呢。如果我们一开始就知道我们的贩售机需要提供两种类型的饮品，也就是不同的产品族，就应该用抽象工厂的模式来写代码。&lt;/p&gt;

&lt;p&gt;首先实现两个接口，一个HotDrink：&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@author chiakimayuzumi&lt;/li&gt;

&lt;li&gt;&lt;p&gt;*/&lt;br /&gt;
public interface HotDrink {&lt;/p&gt;

&lt;p&gt;public void kind();&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个ColdDrink：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public interface ColdDrink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void kind();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;然后分别让四种具体产品继承并实现，这里只贴上可乐类的代码：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */
   public class ColdCola implements ColdDrink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void kind() {
  System.out.println(&amp;quot;I Love ColdCola&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */
   public class HotCola implements HotDrink {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void kind() {
  System.out.println(&amp;quot;I Love HotCola&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;然后实现所有饮品的工厂类，这里只贴可乐工厂的代码：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class ColaFactory extends DrinkFactory {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override  
  public HotDrink produceHotDrink() {  

      return new HotCola();  
  }  

  @Override  
  public ColdDrink produceColdDrink() {  

      return new ColdCola();  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;最后客户端调用：&lt;/p&gt;

&lt;p&gt;/**
   *
   * @author chiakimayuzumi
   *
   */&lt;br /&gt;
  public class Console {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public static void main(String[] args) {  

  DrinkFactory colaFactory = new ColaFactory();
  HotDrink hotCola = colaFactory.produceHotDrink();
  ColdDrink coldCola = colaFactory.produceColdDrink();

  hotCola.kind();
  coldCola.kind();

  DrinkFactory spriteFactory = new SpriteFactory();
  HotDrink hotSprite = spriteFactory.produceHotDrink();
  ColdDrink coldSprite = spriteFactory.produceColdDrink();

  hotSprite.kind();
  coldSprite.kind();

  DrinkFactory fantaFactory = new FantaFactory();
  HotDrink hotFanta = fantaFactory.produceHotDrink();
  ColdDrink coldFanta = fantaFactory.produceColdDrink();

  hotFanta.kind();
  coldFanta.kind();

  DrinkFactory coffeeFactory = new CoffeeFactory();
  HotDrink hotCoffee = coffeeFactory.produceHotDrink();
  ColdDrink coldCoffee = coffeeFactory.produceColdDrink();

  hotCoffee.kind();
  coldCoffee.kind();



}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/02/抽象工厂示例结果.png&#34; alt=&#34;抽象工厂示例结果&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;已知的应用&#34;&gt;已知的应用&lt;/h2&gt;

&lt;p&gt;在ApiDemos中，我找到了一个有关简单工厂的简单应用，该应用主要位于graphics文件夹下，在一些处理图像的有关类中可以看到简单工厂的影子。主要是应用BitmapFactory类中的不同的静态方法多次生成满足需要的Bitmap类。&lt;/p&gt;

&lt;p&gt;例如：
AlphaBitmap类中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;InputStream is = context.getResources().openRawResource(R.drawable.app_sample_code);
mBitmap = BitmapFactory.decodeStream(is);
mBitmap2 = mBitmap.extractAlpha();
mBitmap3 = Bitmap.createBitmap(200, 200, Bitmap.Config.ALPHA_8);
drawIntoBitmap(mBitmap3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BitmapDecode类中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BitmapFactory.Options opts = new  BitmapFactory.Options();
Bitmap bm;

opts.inJustDecodeBounds = true;
bm = BitmapFactory.decodeStream(is, null, opts);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DensityActivity类中：&lt;/p&gt;

&lt;p&gt;private Bitmap loadAndPrintDpi(int id, boolean scale) {
          Bitmap bitmap;
          if (scale) {
              bitmap = BitmapFactory.decodeResource(getResources(), id);
          } else {
              BitmapFactory.Options opts = new BitmapFactory.Options();
              opts.inScaled = false;
              bitmap = BitmapFactory.decodeResource(getResources(), id, opts);
          }
          return bitmap;
      }&lt;/p&gt;

&lt;p&gt;很遗憾在ApiDemos中我暂时没有找到工厂方法和抽象工厂的应用，如果以后找到了其他的示例我会补充在这里。&lt;/p&gt;

&lt;h1 id=&#34;最后&#34;&gt;最后&lt;/h1&gt;

&lt;p&gt;这里用来记录每一次文章修改之处和补充之处。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>设计模式-组合模式</title>
      <link>http://chiakimayuzumi.github.io/blabla/composite/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/blabla/composite/</guid>
      <description>&lt;p&gt;#模式名称（pattem name）&lt;/p&gt;

&lt;p&gt;组合(Composite)模式的其它翻译名称也很多，比如合成模式、树模式等等。在《设计模式》一书中给出的定义是：
&amp;gt; 将对象以树形结构组织起来，以达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;p&gt;#问题（problem）&lt;/p&gt;

&lt;p&gt;以下情况下适用组合模式：&lt;/p&gt;

&lt;p&gt;你想表示对象的部分-整体层次结构；你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。&lt;/p&gt;

&lt;p&gt;它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。&lt;/p&gt;

&lt;p&gt;组合模式让你可以优化处理递归或分级数据结构。&lt;/p&gt;

&lt;p&gt;#解决方案（solution）&lt;/p&gt;

&lt;p&gt;在我们学习组合模式（Composite）之前，让我们先讲解一下透明方式和安全方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/透明模式结构图.jpg&#34; alt=&#34;透明模式结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;透明方式&lt;/strong&gt;：在Component中声明所有用来管理子对象的方法，如Add()方法，Remove()方法及GetChild()方法，所有实现Component接口的子类都具备这些方法，这使得Component和子类具备一致的行为接口，使得对客户端无需区别树叶和树枝对象。&lt;/p&gt;

&lt;p&gt;正由于我们的Composite和Leaf都具备一致的接口行为，但我们知道Leaf不应该具有Add()，Remove()及GetChild()方法，因为我们叶子节点不能再添加和移除节点了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/安全模式结构图.jpg&#34; alt=&#34;安全模式结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安全模式&lt;/strong&gt;：在透明模式基础上把Component中声明所有用来管理子对象的方法移到Composite中，在Composite实现子对象的管理方法，那么Leaf就没有子对象管理方法，这使得Composite和Leaf的行为接口不一致，所以客户端在调用时要知道树叶和树枝对象存在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本结构如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;抽象构件（Component）：定义参加组合的对象的共有方法和属性，可以定义一些默认的行为或属性。&lt;/p&gt;

&lt;p&gt;叶子构件（Leaf）：叶子对象，其下没有分支。&lt;/p&gt;

&lt;p&gt;树枝构件（Composit）：树枝对象，它的作用是组合树枝节点和叶子节点。&lt;/p&gt;

&lt;p&gt;#效果（consequences）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合模式的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;高层模块调用简单；一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点自由增加；使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易呀，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;组合模式的缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用组合模式后，控制树枝构件的类型不太容易。&lt;/li&gt;
&lt;li&gt;用继承的方法来增加新的行为很困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;组合模式的应用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;维护和展示部分－整体关系的场景，如树形菜单、文件和文件夹管理等能
从一个整体中能够独立出部分模块或功能的场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合模式的注意事项：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧。&lt;/p&gt;

&lt;p&gt;#示例&lt;/p&gt;

&lt;p&gt;下面分别用两种方法实现公司的树形结构。&lt;/p&gt;

&lt;p&gt;安全模式下的代码：&lt;/p&gt;

&lt;p&gt;抽象构件（Component）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;public abstract class Company {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private String name;

public Company(String name) {
  this.name = name;
}

public Company() {
}

public String getName() {
  return name;
}

public void setName(String name) {
  this.name = name;
}

protected abstract void display(int depth);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;树枝构件（Composit）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;import java.util.ArrayList;
  import java.util.List;&lt;/p&gt;

&lt;p&gt;public class ConcreteCompany extends Company {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private List&amp;lt;Company&amp;gt; cList;  

 public ConcreteCompany() {
  cList = new ArrayList&amp;lt;Company&amp;gt;();
 }

 public ConcreteCompany(String name) {
  super(name);
  cList = new ArrayList&amp;lt;Company&amp;gt;();

 }

 public void add(Company company) {
  cList.add(company);
 }

 @Override
 protected void display(int depth) {
  StringBuilder sb = new StringBuilder(&amp;quot;&amp;quot;);
  for (int i =0;i&amp;lt;depth ;i++ ) 
  {
    sb.append(&amp;quot;-&amp;quot;);
  }
 System.out.println(new String(sb) + this.getName());
 for (Company c : cList) {
  c.display(depth + 2);
  }

 }

 public void remove(Company company) {
  cList.remove(company);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;叶子构件（Leaf）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;public class FinanceDepartment extends Company {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public FinanceDepartment(){  

  }  

  public FinanceDepartment(String name){  
      super(name);  
  }  

  @Override  
  protected void display(int depth) {  
      StringBuilder sb = new StringBuilder(&amp;quot;&amp;quot;);  
      for (int i = 0; i &amp;lt; depth; i++) {  
          sb.append(&amp;quot;-&amp;quot;);  
      }  
      System.out.println(new String(sb) + this.getName() ) ;   
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;另一个叶子构件（Leaf）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;public class HRDepartment extends Company {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public HRDepartment(){  

  }  

  public HRDepartment(String name){  
      super(name);  
  }  

  @Override  
  protected void display(int depth) {  
      StringBuilder sb = new StringBuilder(&amp;quot;&amp;quot;);  
      for (int i = 0; i &amp;lt; depth; i++) {  
          sb.append(&amp;quot;-&amp;quot;);   
      }  
      System.out.println(new String(sb) + this.getName() ) ;   
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;透明模式下的代码：&lt;/p&gt;

&lt;p&gt;抽象构件（Component）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;public abstract class Company
  {
    private String name;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Company(String name) {
  this.name = name;
}

public Company() {
}

public String getName() {
  return name;
}

public void setName(String name) {
  this.name = name;
}

protected abstract void add(Company company);

protected abstract void remove(Company company);

protected abstract void display(int depth);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;树枝构件（Composit）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;import java.util.ArrayList;
  import java.util.List;&lt;/p&gt;

&lt;p&gt;public class ConcreteCompany extends Company {&lt;br /&gt;
     private List&lt;Company&gt; cList;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public ConcreteCompany() {
  cList = new ArrayList&amp;lt;Company&amp;gt;();
 }

 public ConcreteCompany(String name) {
  super(name);
  cList = new ArrayList&amp;lt;Company&amp;gt;();

 }

 @Override
 public void add(Company company) {
  cList.add(company);
 }

 @Override
 protected void display(int depth) {
  StringBuilder sb = new StringBuilder(&amp;quot;&amp;quot;);
  for (int i =0;i&amp;lt;depth ;i++ ) 
  {
    sb.append(&amp;quot;-&amp;quot;);
  }
 System.out.println(new String(sb) + this.getName());
 for (Company c : cList) {
  c.display(depth + 2);
  }

 }

 @Override
 protected void remove(Company company) {
  cList.remove(company);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;叶子构件（Leaf）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;public class FinanceDepartment extends Company {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public FinanceDepartment(){  

  }  

  public FinanceDepartment(String name){  
      super(name);  
  }  

  @Override  
  protected void add(Company company) {  

  }  

  @Override  
  protected void display(int depth) {  
      StringBuilder sb = new StringBuilder(&amp;quot;&amp;quot;);  
      for (int i = 0; i &amp;lt; depth; i++) {  
          sb.append(&amp;quot;-&amp;quot;);  
      }  
      System.out.println(new String(sb) + this.getName() ) ;   
  }  

  @Override  
  protected void remove(Company company) {  

  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;另一个叶子构件（Leaf）类：&lt;/p&gt;

&lt;p&gt;package com.test.company;&lt;/p&gt;

&lt;p&gt;public class HRDepartment extends Company {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public HRDepartment(){  

  }  

  public HRDepartment(String name){  
      super(name);  
  }  

  @Override  
  protected void add(Company company) {  

  }  

  @Override  
  protected void display(int depth) {  
      StringBuilder sb = new StringBuilder(&amp;quot;&amp;quot;);  
      for (int i = 0; i &amp;lt; depth; i++) {  
          sb.append(&amp;quot;-&amp;quot;);   
      }  
      System.out.println(new String(sb) + this.getName() ) ;   
  }  

  @Override  
  protected void remove(Company company) {  

  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;运行客户端，均能得到以下结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qiji.tech/wp-content/uploads/2016/03/结果.png&#34; alt=&#34;结果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;#Android源码中的应用&lt;/p&gt;

&lt;p&gt;在Android源码中，都能找到使用组合模式的例子，其中ViewGroup和View的结构就是非常典型的组合模式，结构图如下所示：&lt;/p&gt;

&lt;p&gt;现在来看看它们是如何利用组合模式组织在一起的，首先在View类定义了有关具体操作，然后在ViewGroup类中继承View类，并添加相关的增加、删除和查找孩子View节点，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class ViewGroup extends View implements ViewParent, ViewManager {
  ……
｝
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着看增加addView方法：&lt;/p&gt;

&lt;p&gt;/**
       * Adds a child view. If no layout parameters are already set on the child, the
       * default parameters for this ViewGroup are set on the child.
       *
       * @param child the child view to add
       *
       * @see #generateDefaultLayoutParams()
       */
      public void addView(View child) {
          addView(child, -1);
      }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ……
  public void addView(View child, int index) {
      LayoutParams params = child.getLayoutParams();
      if (params == null) {
          params = generateDefaultLayoutParams();
          if (params == null) {
              throw new IllegalArgumentException(&amp;quot;generateDefaultLayoutParams() cannot return null&amp;quot;);
          }
      }
      addView(child, index, params);
  }

……
  public void addView(View child, int width, int height) {
      final LayoutParams params = generateDefaultLayoutParams();
      params.width = width;
      params.height = height;
      addView(child, -1, params);
  }

 ……
  public void addView(View child, LayoutParams params) {
      addView(child, -1, params);
  }

  ……
  public void addView(View child, int index, LayoutParams params) {
      if (DBG) {
          System.out.println(this + &amp;quot; addView&amp;quot;);
      }

      // addViewInner() will call child.requestLayout() when setting the new LayoutParams
      // therefore, we call requestLayout() on ourselves before, so that the child&#39;s request
      // will be blocked at our level
      requestLayout();
      invalidate(true);
      addViewInner(child, index, params, false);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也有removeView方法：&lt;/p&gt;

&lt;p&gt;public void removeView(View view) {
          removeViewInternal(view);
          requestLayout();
          invalidate(true);
      }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ……
  public void removeViewInLayout(View view) {
      removeViewInternal(view);
  }

 ……
  public void removeViewsInLayout(int start, int count) {
      removeViewsInternal(start, count);
  }

 ……
  public void removeViewAt(int index) {
      removeViewInternal(index, getChildAt(index));
      requestLayout();
      invalidate(true);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;……
      public void removeViews(int start, int count) {
          removeViewsInternal(start, count);
          requestLayout();
          invalidate(true);
      }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void removeViewInternal(View view) {
      final int index = indexOfChild(view);
      if (index &amp;gt;= 0) {
          removeViewInternal(index, view);
      }
  }

  private void removeViewInternal(int index, View view) {

      if (mTransition != null) {
          mTransition.removeChild(this, view);
      }

      boolean clearChildFocus = false;
      if (view == mFocused) {
          view.clearFocusForRemoval();
          clearChildFocus = true;
      }

      if (view.getAnimation() != null ||
              (mTransitioningViews != null &amp;amp;&amp;amp; mTransitioningViews.contains(view))) {
          addDisappearingView(view);
      } else if (view.mAttachInfo != null) {
         view.dispatchDetachedFromWindow();
      }

      onViewRemoved(view);

      needGlobalAttributesUpdate(false);

      removeFromArray(index);

      if (clearChildFocus) {
          clearChildFocus(view);
      }
  }

 ……

  private void removeViewsInternal(int start, int count) {
      final View focused = mFocused;
      final boolean detach = mAttachInfo != null;
      View clearChildFocus = null;

      final View[] children = mChildren;
      final int end = start + count;

      for (int i = start; i &amp;lt; end; i++) {
          final View view = children[i];

          if (mTransition != null) {
              mTransition.removeChild(this, view);
          }

          if (view == focused) {
              view.clearFocusForRemoval();
              clearChildFocus = view;
          }

          if (view.getAnimation() != null ||
              (mTransitioningViews != null &amp;amp;&amp;amp; mTransitioningViews.contains(view))) {
              addDisappearingView(view);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} else if (detach) {
                 view.dispatchDetachedFromWindow();
              }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          needGlobalAttributesUpdate(false);

          onViewRemoved(view);
      }

      removeFromArray(start, count);

      if (clearChildFocus != null) {
          clearChildFocus(clearChildFocus);
      }
  }


  public void removeAllViews() {
      removeAllViewsInLayout();
      requestLayout();
      invalidate(true);
  }

……
  public void removeAllViewsInLayout() {
      final int count = mChildrenCount;
      if (count &amp;lt;= 0) {
          return;
      }

      final View[] children = mChildren;
      mChildrenCount = 0;

      final View focused = mFocused;
      final boolean detach = mAttachInfo != null;
      View clearChildFocus = null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;needGlobalAttributesUpdate(false);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      for (int i = count - 1; i &amp;gt;= 0; i--) {
          final View view = children[i];

          if (mTransition != null) {
              mTransition.removeChild(this, view);
          }

          if (view == focused) {
              view.clearFocusForRemoval();
              clearChildFocus = view;
          }

          if (view.getAnimation() != null ||
                  (mTransitioningViews != null &amp;amp;&amp;amp; mTransitioningViews.contains(view))) {
              addDisappearingView(view);
          } else if (detach) {
             view.dispatchDetachedFromWindow();
          }

          onViewRemoved(view);

          view.mParent = null;
          children[i] = null;
      }

      if (clearChildFocus != null) {
          clearChildFocus(clearChildFocus);
      }
  }

 ……
  protected void removeDetachedView(View child, boolean animate) {
      if (mTransition != null) {
          mTransition.removeChild(this, child);
      }

      if (child == mFocused) {
          child.clearFocus();
      }

      if ((animate &amp;amp;&amp;amp; child.getAnimation() != null) ||
              (mTransitioningViews != null &amp;amp;&amp;amp; mTransitioningViews.contains(child))) {
          addDisappearingView(child);
      } else if (child.mAttachInfo != null) {
          child.dispatchDetachedFromWindow();
      }

      onViewRemoved(child);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也有getChild方法：&lt;/p&gt;

&lt;p&gt;/**
       * Returns the view at the specified position in the group.
       *
       * @param index the position at which to get the view from
       * @return the view at the specified position or null if the position
       *         does not exist within the group
       */
      public View getChildAt(int index) {
          if (index &amp;lt; 0 || index &amp;gt;= mChildrenCount) {
              return null;
          }
          return mChildren[index];
      }&lt;/p&gt;

&lt;p&gt;具体叶子节点，如Button，它是继承TextView的，TextView是继承View的，代码如下：&lt;/p&gt;

&lt;p&gt;public class TextView extends View implements ViewTreeObserver.OnPreDrawListener {
  ……
  }&lt;/p&gt;

&lt;p&gt;其中使用（继承）到ViewGroup类的有我们常用的容器类（包装和容纳各种View），如LinearLayout、FrameLayout等，代码如下：&lt;/p&gt;

&lt;p&gt;public class LinearLayout extends ViewGroup {
      public static final int HORIZONTAL = 0;
      public static final int VERTICAL = 1;
  ……
  }&lt;/p&gt;

&lt;p&gt;public class FrameLayout extends ViewGroup {
  ……
  }&lt;/p&gt;

&lt;p&gt;public class RelativeLayout extends ViewGroup {
      private static final String LOG_TAG = &amp;ldquo;RelativeLayout&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private static final boolean DEBUG_GRAPH = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;……
  }&lt;/p&gt;

&lt;p&gt;public class AbsoluteLayout extends ViewGroup {
      public AbsoluteLayout(Context context) {
          super(context);
      }
  }
  ……&lt;/p&gt;

&lt;p&gt;#总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组合模式（Composite）采用树形层次结构来实现，只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，考虑一下组合模式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合模式（Composite）中，透明方式和安全方式的使用抉择，虽然透明方式有可能违背面向对象的SRP原则（单一职责），而安全方式没有很好的封装变化，但在实际开发时我们要根据具体的情况权衡利弊。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>博客目录</title>
      <link>http://chiakimayuzumi.github.io/</link>
      <pubDate>Tue, 08 Mar 2016 21:07:13 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/</guid>
      <description>

&lt;p&gt;点击左上角可以打开侧滑菜单哦么么哒~_ (:зゝ∠) _&lt;/p&gt;

&lt;h2 id=&#34;android-starter-kit&#34;&gt;android-starter-kit&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/androidstartkit/starternetworkactivity/&#34;&gt;Using StarterNetworkActivity to make easier HTTP request&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;开源库源码分析&#34;&gt;开源库源码分析&lt;/h2&gt;

&lt;h3 id=&#34;observablescrollview&#34;&gt;ObservableScrollView&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/recyclerview/&#34;&gt;ObservableScrollView分析 —— ObservableRecyclerView 源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/scrollview/&#34;&gt;ObservableScrollView分析 —— ObservableScrollView 源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/toolbar/&#34;&gt;ObservableScrollView分析 —— 显示/隐藏 Toolbar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/parallax/&#34;&gt;ObservableScrollView分析 —— 视差图像 Parallax image 实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/header/&#34;&gt;ObservableScrollView分析 —— Sticky header 顶部固定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/toolbarblank/&#34;&gt;ObservableScrollView分析 —— Toolbar上的弹性空白&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/thirdlib/pictureblank/&#34;&gt;ObservableScrollView分析 —— 使用图像的弹性空白布局&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;api-demos-源码分析&#34;&gt;Api Demos 源码分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/apidemos/textswitcher/&#34;&gt;TextSwitcher 使用和源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/apidemos/expandablelistview/&#34;&gt;ExpandableListView的继承关系和设计模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他源码分析&#34;&gt;其他源码分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/others/setupwithviewpager/&#34;&gt;setupWithViewPager()后到底发生了什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/blabla/factory/&#34;&gt;设计模式-工厂模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chiakimayuzumi.github.io/blabla/composite/&#34;&gt;设计模式-组合模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;随笔&#34;&gt;随笔&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>联系方式</title>
      <link>http://chiakimayuzumi.github.io/sketch/</link>
      <pubDate>Wed, 09 Mar 2016 20:10:46 +0100</pubDate>
      
      <guid>http://chiakimayuzumi.github.io/sketch/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Email: chiakimayuzumi831@gmail.com&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;QQ:243339048&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;知乎:&lt;a href=&#34;https://www.zhihu.com/people/ChiakiMayuzumi&#34;&gt;chiakimayuzumi&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>